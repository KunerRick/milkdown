{"version":3,"file":"index.es.js","sources":["../src/utility/stack.ts","../src/parser/stack-element.ts","../src/parser/stack.ts","../src/parser/state.ts","../src/parser/index.ts","../src/serializer/stack-element.ts","../src/serializer/stack.ts","../src/serializer/state.ts","../src/serializer/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { stackOverFlow } from '@milkdown/exception';\n\ntype ElInstance<U> = {\n    push: (node: U, ...rest: U[]) => void;\n};\n\ntype StackCtx<T extends ElInstance<U>, U> = {\n    readonly elements: T[];\n};\n\nexport const getStackUtil = <Node, El extends ElInstance<Node>, Ctx extends StackCtx<El, Node>>() => {\n    const size = (ctx: Ctx): number => ctx.elements.length;\n\n    const top = (ctx: Ctx): El | undefined => ctx.elements[size(ctx) - 1];\n\n    const push =\n        (ctx: Ctx) =>\n        (node: Node): void => {\n            top(ctx)?.push(node);\n        };\n\n    const open =\n        (ctx: Ctx) =>\n        (node: El): void => {\n            ctx.elements.push(node);\n        };\n\n    const close = (ctx: Ctx): El => {\n        const el = ctx.elements.pop();\n        if (!el) throw stackOverFlow();\n\n        return el;\n    };\n\n    return {\n        size,\n        top,\n        push,\n        open,\n        close,\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Node, NodeType } from '@milkdown/prose/model';\n\nimport type { Attrs } from './types';\n\nexport type StackElement = {\n    type: NodeType;\n    content: Node[];\n    attrs?: Attrs;\n    push: (node: Node, ...rest: Node[]) => void;\n    pop: () => Node | undefined;\n};\n\nconst pushElement = (element: StackElement, node: Node, ...rest: Node[]) => {\n    element.content.push(node, ...rest);\n};\n\nconst popElement = (element: StackElement): Node | undefined => element.content.pop();\n\nexport const createElement = (type: NodeType, content: Node[], attrs?: Attrs): StackElement => {\n    const element: StackElement = {\n        type,\n        content,\n        attrs,\n        push: (...args) => pushElement(element, ...args),\n        pop: () => popElement(element),\n    };\n    return element;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createNodeInParserFail, stackOverFlow } from '@milkdown/exception';\nimport { Mark, MarkType, Node, NodeType, Schema } from '@milkdown/prose/model';\n\nimport { getStackUtil } from '../utility';\nimport { createElement, StackElement } from './stack-element';\nimport type { Attrs } from './types';\n\ntype Ctx = {\n    marks: readonly Mark[];\n    readonly schema: Schema;\n    readonly elements: StackElement[];\n};\n\nconst { size, push, top, open, close } = getStackUtil<Node, StackElement, Ctx>();\n\nconst hasText = (node: Node): node is Node & { text: string } => node.isText;\n\nconst maybeMerge = (schema: Schema, a: Node, b: Node): Node | undefined => {\n    if (hasText(a) && hasText(b) && Mark.sameSet(a.marks, b.marks)) {\n        return schema.text(a.text + b.text, a.marks);\n    }\n    return;\n};\n\nconst openNode = (ctx: Ctx) => (nodeType: NodeType, attrs?: Attrs) => open(ctx)(createElement(nodeType, [], attrs));\n\nconst addNode =\n    (ctx: Ctx) =>\n    (nodeType: NodeType, attrs?: Attrs, content?: Node[]): Node => {\n        const node = nodeType.createAndFill(attrs, content, ctx.marks);\n\n        if (!node) throw createNodeInParserFail(nodeType, attrs, content);\n\n        push(ctx)(node);\n\n        return node;\n    };\n\nconst closeNode = (ctx: Ctx) => (): Node => {\n    ctx.marks = Mark.none;\n    const element = close(ctx);\n\n    return addNode(ctx)(element.type, element.attrs, element.content);\n};\n\nconst openMark =\n    (ctx: Ctx) =>\n    (markType: MarkType, attrs?: Attrs): void => {\n        const mark = markType.create(attrs);\n\n        ctx.marks = mark.addToSet(ctx.marks);\n    };\n\nconst closeMark =\n    (ctx: Ctx) =>\n    (markType: MarkType): void => {\n        ctx.marks = markType.removeFromSet(ctx.marks);\n    };\n\nconst addText =\n    (ctx: Ctx) =>\n    (text: string): void => {\n        const topElement = top(ctx);\n        if (!topElement) throw stackOverFlow();\n\n        const prevNode = topElement.pop();\n        const currNode = ctx.schema.text(text, ctx.marks);\n\n        if (!prevNode) {\n            topElement.push(currNode);\n            return;\n        }\n\n        const merged = maybeMerge(ctx.schema, prevNode, currNode);\n        if (merged) {\n            topElement.push(merged);\n            return;\n        }\n        topElement.push(prevNode, currNode);\n    };\n\nconst build = (ctx: Ctx) => () => {\n    let doc: Node | undefined = undefined;\n    do {\n        doc = closeNode(ctx)();\n    } while (size(ctx));\n\n    return doc;\n};\n\nexport const createStack = (schema: Schema) => {\n    const ctx: Ctx = {\n        marks: [],\n        elements: [],\n        schema,\n    };\n\n    return {\n        build: build(ctx),\n        openMark: openMark(ctx),\n        closeMark: closeMark(ctx),\n        addText: addText(ctx),\n        openNode: openNode(ctx),\n        addNode: addNode(ctx),\n        closeNode: closeNode(ctx),\n    };\n};\n\nexport type Stack = ReturnType<typeof createStack>;\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { parserMatchError } from '@milkdown/exception';\nimport type { MarkType, Node, NodeType, Schema } from '@milkdown/prose/model';\n\nimport { RemarkParser } from '../utility';\nimport type { Stack } from './stack';\nimport type { Attrs, InnerParserSpecMap, MarkdownNode, ParserSpecWithType } from './types';\n\ntype PS<T extends keyof Stack> = Parameters<Stack[T]>;\n\n/**\n * State for parser.\n * Transform remark AST into prosemirror state.\n */\nexport class State {\n    constructor(\n        private readonly stack: Stack,\n        public readonly schema: Schema,\n        private readonly specMap: InnerParserSpecMap,\n    ) {}\n\n    #matchTarget(node: MarkdownNode): ParserSpecWithType {\n        const result = Object.values(this.specMap).find((x) => x.match(node));\n\n        if (!result) throw parserMatchError(node);\n\n        return result;\n    }\n\n    #runNode(node: MarkdownNode) {\n        const { key, runner, is } = this.#matchTarget(node);\n\n        const proseType: NodeType | MarkType = this.schema[is === 'node' ? 'nodes' : 'marks'][key] as\n            | NodeType\n            | MarkType;\n\n        runner(this, node, proseType as NodeType & MarkType);\n    }\n\n    /**\n     * Transform a markdown string into prosemirror state.\n     *\n     * @param remark - The remark parser used.\n     * @param markdown - The markdown string needs to be parsed.\n     * @returns The state instance.\n     */\n    run = (remark: RemarkParser, markdown: string) => {\n        const tree = remark.runSync(remark.parse(markdown), markdown) as MarkdownNode;\n        this.next(tree);\n\n        return this;\n    };\n\n    /**\n     * Give the node or node list back to the state and the state will find a proper runner (by `match` method) to handle it.\n     *\n     * @param nodes - The node or node list needs to be handled.\n     *\n     * @returns The state instance.\n     */\n    next = (nodes: MarkdownNode | MarkdownNode[] = []) => {\n        [nodes].flat().forEach((node) => this.#runNode(node));\n        return this;\n    };\n\n    /**\n     * Parse current remark AST into prosemirror state.\n     *\n     * @returns Result prosemirror doc.\n     */\n    toDoc = (): Node => this.stack.build();\n\n    /**\n     * Inject root node for prosemirror state.\n     *\n     * @param node - The target markdown node.\n     * @param nodeType - The root prosemirror nodeType .\n     * @param attrs - The attribute of root type.\n     * @returns The state instance.\n     */\n    injectRoot = (node: MarkdownNode, nodeType: NodeType, attrs?: Attrs) => {\n        this.stack.openNode(nodeType, attrs);\n        this.next(node.children);\n\n        return this;\n    };\n\n    /**\n     * Add a text type prosemirror node.\n     *\n     * @param text - Text string.\n     * @returns The state instance.\n     */\n    addText = (text = '') => {\n        this.stack.addText(text);\n        return this;\n    };\n\n    /**\n     * Add a node without open or close it.\n     *\n     * @remarks\n     * It's useful for nodes which don't have content.\n     *\n     * @param nodeType - Node type of this node.\n     * @param attrs - Attributes of this node.\n     * @param content - Content of this node.\n     *\n     * @returns The added node.\n     */\n    addNode = (...args: PS<'addNode'>) => {\n        this.stack.addNode(...args);\n        return this;\n    };\n\n    /**\n     * Open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.\n     *\n     * @remarks\n     * You can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param nodeType - Node type of this node.\n     * @param attrs - Attributes of this node.\n     *\n     * @returns\n     */\n    openNode = (...args: PS<'openNode'>) => {\n        this.stack.openNode(...args);\n        return this;\n    };\n\n    /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n    closeNode = (...args: PS<'closeNode'>) => {\n        this.stack.closeNode(...args);\n        return this;\n    };\n\n    /**\n     * Open a mark, and all marks created after this method will be set as the children of the mark until a `closeMark` been called.\n     *\n     * @remarks\n     * You can imagine `openMark` as the left half of parenthesis and `closeMark` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param markType - Mark type of this mark.\n     * @param attrs - Attributes of this mark.\n     *\n     * @returns\n     */\n    openMark = (...args: PS<'openMark'>) => {\n        this.stack.openMark(...args);\n        return this;\n    };\n\n    /**\n     * Close target mark.\n     *\n     * @param markType - Mark type of this mark.\n     *\n     * @returns The mark closed.\n     */\n    closeMark = (...args: PS<'closeMark'>) => {\n        this.stack.closeMark(...args);\n        return this;\n    };\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node, Schema } from '@milkdown/prose/model';\n\nimport type { RemarkParser } from '../utility';\nimport { createStack } from './stack';\nimport { State } from './state';\nimport type { InnerParserSpecMap } from './types';\n\nexport const createParser = (schema: Schema, specMap: InnerParserSpecMap, remark: RemarkParser) => {\n    const state = new State(createStack(schema), schema, specMap);\n    return (text: string): Node => {\n        state.run(remark, text);\n        return state.toDoc();\n    };\n};\n\nexport * from './types';\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MarkdownNode } from '..';\nimport type { JSONRecord } from '../utility';\n\nexport type StackElement = {\n    type: string;\n    value?: string;\n    props: JSONRecord;\n    children?: MarkdownNode[];\n    push: (node: MarkdownNode, ...rest: MarkdownNode[]) => void;\n    pop: () => MarkdownNode | undefined;\n};\n\nconst pushElement = (element: StackElement, node: MarkdownNode, ...rest: MarkdownNode[]) => {\n    if (!element.children) {\n        element.children = [];\n    }\n    element.children.push(node, ...rest);\n};\n\nconst popElement = (element: StackElement): MarkdownNode | undefined => element.children?.pop();\n\nexport const createElement = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props: JSONRecord = {},\n): StackElement => {\n    const element: StackElement = {\n        type,\n        children,\n        props,\n        value,\n        push: (...args) => pushElement(element, ...args),\n        pop: () => popElement(element),\n    };\n    return element;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Mark } from '@milkdown/prose/model';\nimport { Root } from 'mdast';\n\nimport type { MarkdownNode } from '..';\nimport { getStackUtil, JSONRecord } from '../utility';\nimport { createElement, StackElement } from './stack-element';\n\ntype Ctx = {\n    marks: readonly Mark[];\n    readonly elements: StackElement[];\n};\n\nconst { size, push, open, close } = getStackUtil<MarkdownNode, StackElement, Ctx>();\n\nconst searchType = (child: MarkdownNode, type: string): MarkdownNode => {\n    if (child.type === type) {\n        return child;\n    }\n\n    if (child.children?.length !== 1) {\n        return child;\n    }\n\n    const searchNode = (node: MarkdownNode): MarkdownNode | null => {\n        if (node.type === type) {\n            return node;\n        }\n\n        if (node.children?.length !== 1) {\n            return null;\n        }\n\n        const [firstChild] = node.children;\n        if (!firstChild) return null;\n\n        return searchNode(firstChild);\n    };\n\n    const target = searchNode(child);\n\n    if (!target) return child;\n\n    const tmp = target.children ? [...target.children] : undefined;\n    const node = { ...child, children: tmp };\n    node.children = tmp;\n    target.children = [node];\n\n    return target;\n};\n\nconst maybeMergeChildren = (element: MarkdownNode) => {\n    const { children } = element;\n    if (!children) return element;\n\n    element.children = children.reduce((nextChildren, child, index) => {\n        if (index === 0) {\n            return [child];\n        }\n        const last = nextChildren[nextChildren.length - 1];\n        if (last && last['isMark'] && child['isMark']) {\n            child = searchType(child, last.type);\n            const { children: currChildren, ...currRest } = child;\n            const { children: prevChildren, ...prevRest } = last;\n            if (\n                child.type === last.type &&\n                currChildren &&\n                prevChildren &&\n                JSON.stringify(currRest) === JSON.stringify(prevRest)\n            ) {\n                const next = {\n                    ...prevRest,\n                    children: [...prevChildren, ...currChildren],\n                };\n                return nextChildren.slice(0, -1).concat(maybeMergeChildren(next));\n            }\n        }\n        return nextChildren.concat(child);\n    }, [] as MarkdownNode[]);\n\n    return element;\n};\n\nconst createMarkdownNode = (element: StackElement) => {\n    const node: MarkdownNode = {\n        ...element.props,\n        type: element.type,\n    };\n\n    if (element.children) {\n        node.children = element.children;\n    }\n\n    if (element.value) {\n        node['value'] = element.value;\n    }\n\n    return node;\n};\n\nconst openNode =\n    (ctx: Ctx) =>\n    (type: string, value?: string, props?: JSONRecord): void =>\n        open(ctx)(createElement(type, [], value, props));\n\nconst addNode =\n    (ctx: Ctx) =>\n    (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord): MarkdownNode => {\n        const element = createElement(type, children, value, props);\n        const node: MarkdownNode = maybeMergeChildren(createMarkdownNode(element));\n\n        push(ctx)(node);\n\n        return node;\n    };\n\nconst closeNode = (ctx: Ctx) => (): MarkdownNode => {\n    const element = close(ctx);\n\n    return addNode(ctx)(element.type, element.children, element.value, element.props);\n};\n\nconst openMark =\n    (ctx: Ctx) =>\n    (mark: Mark, type: string, value?: string, props?: JSONRecord): void => {\n        const isIn = mark.isInSet(ctx.marks);\n\n        if (isIn) {\n            return;\n        }\n        ctx.marks = mark.addToSet(ctx.marks);\n        openNode(ctx)(type, value, { ...props, isMark: true });\n    };\n\nconst closeMark =\n    (ctx: Ctx) =>\n    (mark: Mark): MarkdownNode | null => {\n        if (!mark.isInSet(ctx.marks)) return null;\n        ctx.marks = mark.type.removeFromSet(ctx.marks);\n        return closeNode(ctx)();\n    };\n\nconst build = (ctx: Ctx) => () => {\n    let doc: Root | null = null;\n    do {\n        doc = closeNode(ctx)() as Root;\n    } while (size(ctx));\n\n    return doc;\n};\n\nexport type Stack = {\n    /**\n     * Build the remark AST tree with current stack.\n     *\n     * @returns A remark AST tree.\n     */\n    build: () => Root;\n\n    /**\n     * Open a mark.\n     *\n     * @param mark - The mark need to be opened.\n     * @param type - Type of this mark.\n     * @param value - Value of this mark.\n     * @param props - Additional props of this mark.\n     *\n     * @returns\n     */\n    openMark: (mark: Mark, type: string, value?: string, props?: JSONRecord) => void;\n\n    /**\n     * Close current mark.\n     * @param mark - The prosemirror mark of target mark to be closed.\n     *\n     * @returns The mark closed, will be null if not exists.\n     */\n    closeMark: (mark: Mark) => MarkdownNode | null;\n\n    /**\n     * Open a node.\n     *\n     * @param type - Type of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns\n     */\n    openNode: (type: string, value?: string, props?: JSONRecord) => void;\n\n    /**\n     * Add a node in current position.\n     *\n     * @param type - Type of this node.\n     * @param children - Children of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The added node.\n     */\n    addNode: (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord) => MarkdownNode;\n\n    /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n    closeNode: () => MarkdownNode;\n};\n\nexport const createStack = (): Stack => {\n    const ctx: Ctx = {\n        marks: [],\n        elements: [],\n    };\n\n    return {\n        build: build(ctx),\n        openMark: openMark(ctx),\n        closeMark: closeMark(ctx),\n        openNode: openNode(ctx),\n        addNode: addNode(ctx),\n        closeNode: closeNode(ctx),\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { serializerMatchError } from '@milkdown/exception';\nimport type { Fragment, Mark as ProseMark, Node as ProseNode, Schema } from '@milkdown/prose/model';\n\nimport { RemarkParser } from '../utility';\nimport type { Stack } from './stack';\nimport type { InnerSerializerSpecMap, MarkSerializerSpec, NodeSerializerSpec } from './types';\n\nconst isFragment = (x: ProseNode | Fragment): x is Fragment => Object.prototype.hasOwnProperty.call(x, 'size');\n\ntype StateMethod<T extends keyof Stack> = (...args: Parameters<Stack[T]>) => State;\n\n/**\n * State for serializer.\n * Transform prosemirror state into remark AST.\n */\nexport class State {\n    constructor(\n        private readonly stack: Stack,\n        public readonly schema: Schema,\n        private readonly specMap: InnerSerializerSpecMap,\n    ) {}\n\n    #matchTarget<T extends ProseMark | ProseNode>(\n        node: T,\n    ): (T extends ProseNode ? NodeSerializerSpec : MarkSerializerSpec) & { key: string } {\n        const result = Object.entries(this.specMap)\n            .map(([key, spec]) => ({\n                key,\n                ...spec,\n            }))\n            .find((x) => x.match(node as ProseMark & ProseNode));\n\n        if (!result) throw serializerMatchError(node.type);\n\n        return result as never;\n    }\n\n    #runProseNode(node: ProseNode) {\n        const { runner } = this.#matchTarget(node);\n        runner(this, node);\n    }\n\n    #runProseMark(mark: ProseMark, node: ProseNode) {\n        const { runner } = this.#matchTarget(mark);\n        return runner(this, mark, node);\n    }\n\n    #runNode(node: ProseNode) {\n        const { marks } = node;\n        const getPriority = (x: ProseMark) => x.type.spec['priority'] ?? 50;\n        const tmp = [...marks].sort((a, b) => getPriority(a) - getPriority(b));\n        const unPreventNext = tmp.every((mark) => !this.#runProseMark(mark, node));\n        if (unPreventNext) {\n            this.#runProseNode(node);\n        }\n        marks.forEach((mark) => this.stack.closeMark(mark));\n    }\n\n    /**\n     * Transform a prosemirror node tree into remark AST.\n     *\n     * @param tree - The prosemirror node tree needs to be transformed.\n     *\n     * @returns The state instance.\n     */\n    run(tree: ProseNode) {\n        this.next(tree);\n\n        return this;\n    }\n\n    /**\n     * Use a remark parser to serialize current AST stored.\n     *\n     * @param remark - The remark parser needs to used.\n     * @returns Result markdown string.\n     */\n    toString = (remark: RemarkParser): string => remark.stringify(this.stack.build()) as string;\n\n    /**\n     * Give the node or node list back to the state and the state will find a proper runner (by `match` method) to handle it.\n     *\n     * @param nodes - The node or node list needs to be handled.\n     *\n     * @returns The state instance.\n     */\n    next = (nodes: ProseNode | Fragment) => {\n        if (isFragment(nodes)) {\n            nodes.forEach((node) => {\n                this.#runNode(node);\n            });\n            return this;\n        }\n        this.#runNode(nodes);\n        return this;\n    };\n\n    /**\n     * Add a node without open or close it.\n     *\n     * @remarks\n     * It's useful for nodes which don't have content.\n     *\n     * @param type - Type of this node.\n     * @param children - Children of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The added node.\n     */\n    addNode: StateMethod<'addNode'> = (...args) => {\n        this.stack.addNode(...args);\n        return this;\n    };\n\n    /**\n     * Open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.\n     *\n     * @remarks\n     * You can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param type - Type of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The state instance.\n     */\n    openNode: StateMethod<'openNode'> = (...args) => {\n        this.stack.openNode(...args);\n        return this;\n    };\n\n    /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n    closeNode: StateMethod<'closeNode'> = (...args) => {\n        this.stack.closeNode(...args);\n        return this;\n    };\n\n    /**\n     * Used when current node has marks, the serializer will auto combine marks nearby.\n     *\n     * @param mark - The mark need to be opened.\n     * @param type - Type of this mark.\n     * @param value - Value of this mark.\n     * @param props - Additional props of this mark.\n     *\n     * @returns The state instance.\n     */\n    withMark: StateMethod<'openMark'> = (...args) => {\n        this.stack.openMark(...args);\n        return this;\n    };\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node, Schema } from '@milkdown/prose/model';\n\nimport { RemarkParser } from '../utility';\nimport { createStack } from './stack';\nimport { State } from './state';\nimport type { InnerSerializerSpecMap } from './types';\n\nexport const createSerializer =\n    (schema: Schema, specMap: InnerSerializerSpecMap, remark: RemarkParser) => (content: Node) => {\n        const state = new State(createStack(), schema, specMap);\n        state.run(content);\n        return state.toString(remark);\n    };\n\nexport * from './types';\n"],"names":["pushElement","popElement","createElement","size","push","open","close","openNode","addNode","closeNode","openMark","closeMark","build","createStack","State"],"mappings":"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"}