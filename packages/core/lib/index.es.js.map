{"version":3,"file":"index.es.js","sources":["../src/internal-plugin/config.ts","../src/internal-plugin/theme.ts","../src/internal-plugin/init.ts","../src/internal-plugin/schema.ts","../src/internal-plugin/parser.ts","../src/internal-plugin/serializer.ts","../src/internal-plugin/editor-state.ts","../src/internal-plugin/editor-view.ts","../src/internal-plugin/commands.ts","../src/editor/editor.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { createTimer, CtxHandler, MilkdownPlugin } from '@milkdown/ctx';\n\nexport const ConfigReady = createTimer('ConfigReady');\n\nexport const config =\n    (configure: CtxHandler): MilkdownPlugin =>\n    (pre) => {\n        pre.record(ConfigReady);\n\n        return async (ctx) => {\n            await configure(ctx);\n            ctx.done(ConfigReady);\n        };\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport {\n    createThemeManager,\n    Emotion,\n    emotionConfigCtx,\n    emotionCtx,\n    initEmotion,\n    internalThemeKeys,\n    ThemeGlobal,\n    ThemeManager,\n    themeManagerCtx,\n    ThemeSliceKey,\n} from '@milkdown/design-system';\nimport { Plugin, PluginKey } from '@milkdown/prose/state';\n\nimport { ConfigReady } from './config';\nimport { InitReady, prosePluginsCtx } from './init';\n\nexport const themeTimerCtx = createSlice([] as Timer[], 'themeTimer');\nexport const ThemeEnvironmentReady = createTimer('ThemeEnvironmentReady');\nexport const ThemeReady = createTimer('ThemeReady');\n\nconst key = new PluginKey('MILKDOWN_THEME_RESET');\n\nexport const themeEnvironment: MilkdownPlugin = (pre) => {\n    const themeManager = createThemeManager();\n\n    pre.inject(emotionConfigCtx)\n        .inject(emotionCtx)\n        .inject(themeManagerCtx, themeManager)\n        .inject(themeTimerCtx, [ConfigReady])\n        .record(ThemeReady)\n        .record(ThemeEnvironmentReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(themeTimerCtx);\n        const emotion = initEmotion(ctx.get(emotionConfigCtx));\n\n        internalThemeKeys.forEach((key) => {\n            themeManager.inject(key as ThemeSliceKey);\n        });\n\n        ctx.set(emotionCtx, emotion);\n\n        ctx.done(ThemeEnvironmentReady);\n        ctx.done(ThemeReady);\n\n        await ctx.wait(InitReady);\n        ctx.update(prosePluginsCtx, (xs) =>\n            xs.concat(\n                new Plugin({\n                    key,\n                    view: () => {\n                        themeManager.runExecutor();\n                        return {\n                            destroy: () => {\n                                emotion.flush();\n                            },\n                        };\n                    },\n                }),\n            ),\n        );\n    };\n};\n\nexport type CreateThemePack = (emotion: Emotion, manager: ThemeManager) => void;\nexport type ThemePlugin = MilkdownPlugin & {\n    override: (overrideFn: CreateThemePack) => ThemePlugin;\n};\n\nexport const themeFactory = (createThemePack?: CreateThemePack): ThemePlugin => {\n    let overrideFn: CreateThemePack | null = null;\n    const theme: ThemePlugin = () => async (ctx) => {\n        await ctx.wait(ThemeEnvironmentReady);\n        const emotion = ctx.get(emotionCtx);\n        const themeManager = ctx.get(themeManagerCtx);\n\n        themeManager.setExecutor(() => {\n            createThemePack?.(emotion, themeManager);\n            overrideFn?.(emotion, themeManager);\n\n            internalThemeKeys.forEach((key) => {\n                if (!themeManager.has(key as ThemeSliceKey)) {\n                    console.warn('Theme key not found: ', key.sliceName);\n                }\n            });\n\n            themeManager.get(ThemeGlobal, undefined);\n        });\n    };\n    theme.override = (fn) => {\n        overrideFn = fn;\n        return theme;\n    };\n    return theme;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Slice, Timer } from '@milkdown/ctx';\nimport { InputRule } from '@milkdown/prose/inputrules';\nimport { Plugin } from '@milkdown/prose/state';\nimport { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view';\nimport { RemarkParser, RemarkPlugin } from '@milkdown/transformer';\nimport remarkParse from 'remark-parse';\nimport remarkStringify, { Options } from 'remark-stringify';\nimport { unified } from 'unified';\n\nimport type { Editor } from '../editor';\nimport { ThemeReady } from './theme';\n\nexport const InitReady = createTimer('InitReady');\n\nexport const initTimerCtx = createSlice([] as Timer[], 'initTimer');\nexport const editorCtx = createSlice({} as Editor, 'editor');\n\nexport const inputRulesCtx = createSlice([] as InputRule[], 'inputRules');\nexport const prosePluginsCtx = createSlice([] as Plugin[], 'prosePlugins');\nexport const remarkPluginsCtx = createSlice([] as RemarkPlugin[], 'remarkPlugins');\n\ntype NodeView = [nodeId: string, view: NodeViewConstructor];\nexport const nodeViewCtx = createSlice([] as NodeView[], 'nodeView');\ntype MarkView = [nodeId: string, view: MarkViewConstructor];\nexport const markViewCtx = createSlice([] as MarkView[], 'markView');\n\nexport const remarkCtx: Slice<RemarkParser> = createSlice(unified().use(remarkParse).use(remarkStringify), 'remark');\nexport const remarkStringifyDefaultOptions: Options = {};\nexport const remarkStringifyOptionsCtx = createSlice(remarkStringifyDefaultOptions, 'remarkStringifyOptions');\n\nexport const init =\n    (editor: Editor): MilkdownPlugin =>\n    (pre) => {\n        pre.inject(editorCtx, editor)\n            .inject(prosePluginsCtx)\n            .inject(remarkPluginsCtx)\n            .inject(inputRulesCtx)\n            .inject(nodeViewCtx)\n            .inject(markViewCtx)\n            .inject(remarkStringifyOptionsCtx)\n            .inject(remarkCtx, unified().use(remarkParse).use(remarkStringify))\n            .inject(initTimerCtx, [ThemeReady])\n            .record(InitReady);\n\n        return async (ctx) => {\n            await ctx.waitTimers(initTimerCtx);\n            const options = ctx.get(remarkStringifyOptionsCtx);\n            ctx.set(remarkCtx, unified().use(remarkParse).use(remarkStringify, options));\n\n            ctx.done(InitReady);\n        };\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport type { MarkSpec, NodeSpec } from '@milkdown/prose/model';\nimport { Schema } from '@milkdown/prose/model';\nimport type {\n    MarkParserSpec,\n    MarkSerializerSpec,\n    NodeParserSpec,\n    NodeSerializerSpec,\n    RemarkParser,\n} from '@milkdown/transformer';\n\nimport { InitReady, remarkCtx, remarkPluginsCtx } from '.';\n\nexport const SchemaReady = createTimer('schemaReady');\n\nexport const schemaCtx = createSlice({} as Schema, 'schema');\nexport const schemaTimerCtx = createSlice([] as Timer[], 'schemaTimer');\n\nexport type NodeSchema = {\n    readonly toMarkdown: NodeSerializerSpec;\n    readonly parseMarkdown: NodeParserSpec;\n    readonly priority?: number;\n} & Readonly<NodeSpec>;\n\nexport const nodesCtx = createSlice([] as Array<[string, NodeSchema]>, 'nodes');\n\nexport type MarkSchema = {\n    readonly toMarkdown: MarkSerializerSpec;\n    readonly parseMarkdown: MarkParserSpec;\n} & Readonly<MarkSpec>;\nexport const marksCtx = createSlice([] as Array<[string, MarkSchema]>, 'marks');\n\nconst extendPriority = <T extends NodeSchema | MarkSchema>(x: T): T => {\n    return {\n        ...x,\n        parseDOM: x.parseDOM?.map((rule) => ({ priority: x.priority, ...rule })),\n    };\n};\n\nexport const schema: MilkdownPlugin = (pre) => {\n    pre.inject(schemaCtx).inject(nodesCtx).inject(marksCtx).inject(schemaTimerCtx, [InitReady]).record(SchemaReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(schemaTimerCtx);\n\n        const remark = ctx.get(remarkCtx);\n        const remarkPlugins = ctx.get(remarkPluginsCtx);\n\n        const processor = remarkPlugins.reduce((acc: RemarkParser, plug) => acc.use(plug), remark);\n        ctx.set(remarkCtx, processor);\n\n        const nodes = Object.fromEntries(ctx.get(nodesCtx).map(([key, x]) => [key, extendPriority(x)]));\n        const marks = Object.fromEntries(ctx.get(marksCtx).map(([key, x]) => [key, extendPriority(x)]));\n\n        ctx.set(\n            schemaCtx,\n            new Schema({\n                nodes,\n                marks,\n            }),\n        );\n\n        ctx.done(SchemaReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport type { Node as ProsemirrorNode } from '@milkdown/prose/model';\nimport { createParser, InnerParserSpecMap, ParserSpecWithType } from '@milkdown/transformer';\n\nimport { marksCtx, nodesCtx } from '.';\nimport { remarkCtx } from './init';\nimport { schemaCtx, SchemaReady } from './schema';\n\nexport type Parser = (text: string) => ProsemirrorNode | undefined;\n\nexport const parserCtx = createSlice((() => undefined) as Parser, 'parser');\nexport const parserTimerCtx = createSlice([] as Timer[], 'parserTimer');\n\nexport const ParserReady = createTimer('ParserReady');\n\nexport const parser: MilkdownPlugin = (pre) => {\n    pre.inject(parserCtx).inject(parserTimerCtx, [SchemaReady]).record(ParserReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(parserTimerCtx);\n        const nodes = ctx.get(nodesCtx);\n        const marks = ctx.get(marksCtx);\n        const remark = ctx.get(remarkCtx);\n        const schema = ctx.get(schemaCtx);\n\n        const children = [\n            ...nodes.map(([id, v]) => ({ id, ...v })).map((node) => ({ ...node, is: 'node' as const })),\n            ...marks.map(([id, v]) => ({ id, ...v })).map((mark) => ({ ...mark, is: 'mark' as const })),\n        ];\n        const spec: InnerParserSpecMap = Object.fromEntries(\n            children.map(({ id, parseMarkdown, is }) => [id, { ...parseMarkdown, is, key: id } as ParserSpecWithType]),\n        );\n\n        ctx.set(parserCtx, createParser(schema, spec, remark));\n        ctx.done(ParserReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport type { Node as ProsemirrorNode } from '@milkdown/prose/model';\nimport { createSerializer } from '@milkdown/transformer';\n\nimport { remarkCtx } from './init';\nimport { marksCtx, nodesCtx, schemaCtx, SchemaReady } from './schema';\n\nexport const serializerCtx = createSlice<(node: ProsemirrorNode) => string, 'serializer'>(() => '', 'serializer');\nexport const serializerTimerCtx = createSlice([] as Timer[], 'serializerTimer');\n\nexport const SerializerReady = createTimer('SerializerReady');\n\nexport const serializer: MilkdownPlugin = (pre) => {\n    pre.inject(serializerCtx).inject(serializerTimerCtx, [SchemaReady]).record(SerializerReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(serializerTimerCtx);\n        const nodes = ctx.get(nodesCtx);\n        const marks = ctx.get(marksCtx);\n        const remark = ctx.get(remarkCtx);\n        const schema = ctx.get(schemaCtx);\n\n        const children = [...nodes, ...marks];\n        const spec = Object.fromEntries(children.map(([id, child]) => [id, child.toMarkdown]));\n\n        ctx.set(serializerCtx, createSerializer(schema, spec, remark));\n        ctx.done(SerializerReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport { docTypeError } from '@milkdown/exception';\nimport { customInputRules as createInputRules } from '@milkdown/prose';\nimport { baseKeymap } from '@milkdown/prose/commands';\nimport { keymap as createKeymap } from '@milkdown/prose/keymap';\nimport { DOMParser, Node, Schema } from '@milkdown/prose/model';\nimport { EditorState, Plugin, PluginKey } from '@milkdown/prose/state';\nimport { JSONRecord } from '@milkdown/transformer';\n\nimport { CommandsReady } from '.';\nimport { inputRulesCtx, prosePluginsCtx } from './init';\nimport { Parser, parserCtx, ParserReady } from './parser';\nimport { schemaCtx } from './schema';\nimport { SerializerReady } from './serializer';\n\nexport type DefaultValue = string | { type: 'html'; dom: HTMLElement } | { type: 'json'; value: JSONRecord };\ntype StateOptions = Parameters<typeof EditorState.create>[0];\ntype StateOptionsOverride = (prev: StateOptions) => StateOptions;\n\nexport const defaultValueCtx = createSlice('' as DefaultValue, 'defaultValue');\nexport const editorStateCtx = createSlice({} as EditorState, 'editorState');\nexport const editorStateOptionsCtx = createSlice<StateOptionsOverride>((x) => x, 'stateOptions');\nexport const editorStateTimerCtx = createSlice([] as Timer[], 'editorStateTimer');\n\nexport const EditorStateReady = createTimer('EditorStateReady');\n\nconst key = new PluginKey('MILKDOWN_STATE_TRACKER');\n\nexport const getDoc = (defaultValue: DefaultValue, parser: Parser, schema: Schema) => {\n    if (typeof defaultValue === 'string') {\n        return parser(defaultValue);\n    }\n\n    if (defaultValue.type === 'html') {\n        return DOMParser.fromSchema(schema).parse(defaultValue.dom);\n    }\n\n    if (defaultValue.type === 'json') {\n        return Node.fromJSON(schema, defaultValue.value);\n    }\n\n    throw docTypeError(defaultValue);\n};\n\nexport const editorState: MilkdownPlugin = (pre) => {\n    pre.inject(defaultValueCtx)\n        .inject(editorStateCtx)\n        .inject(editorStateOptionsCtx)\n        .inject(editorStateTimerCtx, [ParserReady, SerializerReady, CommandsReady])\n        .record(EditorStateReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(editorStateTimerCtx);\n\n        const schema = ctx.get(schemaCtx);\n        const parser = ctx.get(parserCtx);\n        const rules = ctx.get(inputRulesCtx);\n        const optionsOverride = ctx.get(editorStateOptionsCtx);\n        const prosePlugins = ctx.get(prosePluginsCtx);\n        const defaultValue = ctx.get(defaultValueCtx);\n        const doc = getDoc(defaultValue, parser, schema);\n\n        const plugins = [\n            ...prosePlugins,\n            new Plugin({\n                key,\n                state: {\n                    init: () => {\n                        // do nothing\n                    },\n                    apply: (_tr, _value, _oldState, newState) => {\n                        ctx.set(editorStateCtx, newState);\n                    },\n                },\n            }),\n            createInputRules({ rules }),\n            createKeymap(baseKeymap),\n        ];\n\n        ctx.set(prosePluginsCtx, plugins);\n\n        const options = optionsOverride({\n            schema,\n            doc,\n            plugins,\n        });\n\n        const state = EditorState.create(options);\n        ctx.set(editorStateCtx, state);\n        ctx.done(EditorStateReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, Ctx, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport { Plugin, PluginKey } from '@milkdown/prose/state';\nimport { DirectEditorProps, EditorView } from '@milkdown/prose/view';\n\nimport { editorStateCtx, EditorStateReady } from './editor-state';\nimport { InitReady, markViewCtx, nodeViewCtx, prosePluginsCtx } from './init';\n\ntype EditorOptions = Omit<DirectEditorProps, 'state'>;\n\ntype RootType = Node | undefined | null | string;\n\nexport const editorViewCtx = createSlice({} as EditorView, 'editorView');\nexport const editorViewOptionsCtx = createSlice({} as Partial<EditorOptions>, 'editorViewOptions');\nexport const rootCtx = createSlice(null as RootType, 'root');\nexport const editorViewTimerCtx = createSlice([] as Timer[], 'editorViewTimer');\nexport const rootDOMCtx = createSlice(null as unknown as HTMLElement, 'rootDOM');\n\nexport const EditorViewReady = createTimer('EditorViewReady');\n\nconst createViewContainer = (root: Node, ctx: Ctx) => {\n    const container = document.createElement('div');\n    container.className = 'milkdown';\n    root.appendChild(container);\n    ctx.set(rootDOMCtx, container);\n\n    return container;\n};\n\nconst prepareViewDom = (dom: Element) => {\n    dom.classList.add('editor');\n    dom.setAttribute('role', 'textbox');\n};\n\nconst key = new PluginKey('MILKDOWN_VIEW_CLEAR');\n\nexport const editorView: MilkdownPlugin = (pre) => {\n    pre.inject(rootCtx, document.body)\n        .inject(editorViewCtx)\n        .inject(editorViewOptionsCtx)\n        .inject(rootDOMCtx)\n        .inject(editorViewTimerCtx, [EditorStateReady])\n        .record(EditorViewReady);\n\n    return async (ctx) => {\n        await ctx.wait(InitReady);\n\n        const root = ctx.get(rootCtx) || document.body;\n        const el = typeof root === 'string' ? document.querySelector(root) : root;\n\n        ctx.update(prosePluginsCtx, (xs) => [\n            new Plugin({\n                key,\n                view: (editorView) => {\n                    const container = el ? createViewContainer(el, ctx) : undefined;\n\n                    const handleDOM = () => {\n                        if (container && el) {\n                            const editor = editorView.dom;\n                            el.replaceChild(container, editor);\n                            container.appendChild(editor);\n                        }\n                    };\n                    handleDOM();\n                    return {\n                        destroy: () => {\n                            if (container?.parentNode) {\n                                container?.parentNode.replaceChild(editorView.dom, container);\n                            }\n                            container?.remove();\n                        },\n                    };\n                },\n            }),\n            ...xs,\n        ]);\n\n        await ctx.waitTimers(editorViewTimerCtx);\n\n        const state = ctx.get(editorStateCtx);\n        const options = ctx.get(editorViewOptionsCtx);\n        const nodeViews = Object.fromEntries(ctx.get(nodeViewCtx));\n        const markViews = Object.fromEntries(ctx.get(markViewCtx));\n        const view = new EditorView(el as Node, {\n            state,\n            nodeViews,\n            markViews,\n            ...options,\n        });\n        prepareViewDom(view.dom);\n        ctx.set(editorViewCtx, view);\n        ctx.done(EditorViewReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createContainer, createSlice, createTimer, Ctx, MilkdownPlugin, Slice, Timer } from '@milkdown/ctx';\nimport { callCommandBeforeEditorView } from '@milkdown/exception';\nimport type { Command } from '@milkdown/prose/state';\n\nimport { editorViewCtx, EditorViewReady } from './editor-view';\nimport { SchemaReady } from './schema';\n\nexport type Cmd<T = undefined> = (payload?: T) => Command;\nexport type CmdKey<T = undefined> = Slice<Cmd<T>>;\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never;\n\nexport class CommandManager {\n    #container = createContainer();\n    #ctx: Ctx | null = null;\n\n    setCtx = (ctx: Ctx) => {\n        this.#ctx = ctx;\n    };\n\n    /**\n     * Create a command with provided key and command function.\n     *\n     * @param meta - The key of the command that needs to be created.\n     * @param value - The implementation of the command function.\n     */\n    create<T>(meta: CmdKey<T>, value: Cmd<T>) {\n        return meta(this.#container.sliceMap, value);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get<T extends CmdKey<any>>(slice: string): Cmd<InferParams<T>>;\n    get<T>(slice: CmdKey<T>): Cmd<T>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(slice: string | CmdKey<any>): Cmd<any>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(slice: string | CmdKey<any>): Cmd<any> {\n        return this.#container.getSlice(slice).get();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): boolean;\n    call<T>(slice: CmdKey<T>, payload?: T): boolean;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(slice: string | CmdKey<any>, payload?: any): boolean;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(slice: string | CmdKey<any>, payload?: any): boolean {\n        if (this.#ctx == null) {\n            throw callCommandBeforeEditorView();\n        }\n        const cmd = this.get(slice);\n        const command = cmd(payload);\n        const view = this.#ctx.get(editorViewCtx);\n        return command(view.state, view.dispatch, view);\n    }\n}\n\nexport type CmdTuple<T = unknown> = [key: CmdKey<T>, value: Cmd<T>];\n\nexport const createCmd = <T>(key: CmdKey<T>, value: Cmd<T>): CmdTuple => [key, value] as CmdTuple;\nexport const createCmdKey = <T = undefined>(key = 'cmdKey'): CmdKey<T> =>\n    createSlice((() => () => false) as Cmd<T>, key);\n\nexport const commandsCtx = createSlice({} as CommandManager, 'commands');\n\nexport const commandsTimerCtx = createSlice([] as Timer[], 'commandsTimer');\nexport const CommandsReady = createTimer('CommandsReady');\n\nexport const commands: MilkdownPlugin = (pre) => {\n    const commandManager = new CommandManager();\n    pre.inject(commandsCtx, commandManager).inject(commandsTimerCtx, [SchemaReady]).record(CommandsReady);\n    return async (ctx) => {\n        await ctx.waitTimers(commandsTimerCtx);\n\n        ctx.done(CommandsReady);\n        await ctx.wait(EditorViewReady);\n        commandManager.setCtx(ctx);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createClock, createContainer, Ctx, CtxHandler, MilkdownPlugin, Pre } from '@milkdown/ctx';\n\nimport {\n    commands,\n    config,\n    editorState,\n    editorView,\n    init,\n    parser,\n    schema,\n    serializer,\n    themeEnvironment,\n} from '../internal-plugin';\n\n/**\n * Get the milkdown editor constructor\n */\nexport class Editor {\n    /**\n     * Create a new editor instance.\n     *\n     * @returns The new editor instance been created.\n     */\n    static make() {\n        return new Editor();\n    }\n\n    readonly #container = createContainer();\n    readonly #clock = createClock();\n\n    readonly #plugins: Set<CtxHandler> = new Set();\n    readonly #configureList: CtxHandler[] = [];\n\n    readonly #ctx = new Ctx(this.#container, this.#clock);\n    readonly #pre = new Pre(this.#container, this.#clock);\n\n    readonly #loadInternal = () => {\n        const internalPlugins = [\n            themeEnvironment,\n            schema,\n            parser,\n            serializer,\n            commands,\n            editorState,\n            editorView,\n            init(this),\n        ];\n        const configPlugin = config(async (x) => {\n            await Promise.all(this.#configureList.map((fn) => fn(x)));\n        });\n        this.use(internalPlugins.concat(configPlugin));\n    };\n\n    /**\n     * Get the ctx of the editor.\n     *\n     * @returns The ctx of the editor.\n     */\n    get ctx() {\n        return this.#ctx;\n    }\n\n    /**\n     * Use one plugin or a list of plugins for current editor.\n     *\n     * @example\n     * ```\n     * Editor.make()\n     *   .use(plugin)\n     *   .use([pluginA, pluginB])\n     * ```\n     *\n     * @param plugins - A list of plugins, or one plugin.\n     * @returns Editor instance.\n     */\n    readonly use = (plugins: MilkdownPlugin | MilkdownPlugin[]) => {\n        [plugins].flat().forEach((plugin) => {\n            this.#plugins.add(plugin(this.#pre));\n        });\n        return this;\n    };\n\n    /**\n     * Config the context for current editor.\n     *\n     * @param configure - The function that configure current editor, can be async, with context as parameter.\n     * @returns Editor instance.\n     */\n    readonly config = (configure: CtxHandler) => {\n        this.#configureList.push(configure);\n        return this;\n    };\n\n    /**\n     * Create the editor UI.\n     *\n     * @example\n     * ```\n     * Editor.make().use(nord).use(commonmark).create()\n     * ```\n     *\n     * @returns A promise object, will be resolved as editor instance after create finish.\n     */\n    readonly create = async () => {\n        this.#loadInternal();\n        await Promise.all([...this.#plugins].map((loader) => loader(this.#ctx)));\n        return this;\n    };\n\n    /**\n     * Get the context value in a running editor on demand and return the action result.\n     *\n     * @example\n     * ```\n     * import { Editor, editorViewCtx, serializerCtx } from '@milkdown/core';\n     * async function playWithEditor() {\n     *     const editor = await Editor.make().use(commonmark).create();\n     *\n     *     const getMarkdown = () =>\n     *         editor.action((ctx) => {\n     *             const editorView = ctx.get(editorViewCtx);\n     *             const serializer = ctx.get(serializerCtx);\n     *             return serializer(editorView.state.doc);\n     *         });\n     *\n     *     // get markdown string:\n     *     getMarkdown();\n     * }\n     * ```\n     *\n     * @param action - The function that get editor context and return the action result.\n     * @returns The action result.\n     */\n    readonly action = <T>(action: (ctx: Ctx) => T) => action(this.#ctx);\n}\n"],"names":["key","createInputRules","createKeymap"],"mappings":"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"}