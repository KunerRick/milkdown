{"version":3,"file":"index.es.js","sources":["../src/context/container.ts","../src/context/shallow-clone.ts","../src/context/slice.ts","../src/plugin/ctx.ts","../src/plugin/env.ts","../src/plugin/pre.ts","../src/timing/clock.ts","../src/timing/timing.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { contextNotFound } from '@milkdown/exception';\n\nimport { $Slice, Slice } from './slice';\n\nexport type Container = {\n    readonly getSlice: <T, N extends string = string>(slice: Slice<T, N> | N) => $Slice<T, N>;\n    readonly sliceMap: Map<symbol, $Slice>;\n};\n\nexport const createContainer = (): Container => {\n    const sliceMap: Map<symbol, $Slice> = new Map();\n\n    const getSlice = <T, N extends string = string>(slice: Slice<T, N> | N): $Slice<T, N> => {\n        const context =\n            typeof slice === 'string' ? [...sliceMap.values()].find((x) => x.name === slice) : sliceMap.get(slice.id);\n\n        if (!context) {\n            const name = typeof slice === 'string' ? slice : slice.sliceName;\n            throw contextNotFound(name);\n        }\n        return context as $Slice<T, N>;\n    };\n\n    return { getSlice, sliceMap };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nexport const shallowClone = <T>(x: T): T => {\n    if (Array.isArray(x)) {\n        return [...(x as unknown[])] as unknown as T;\n    }\n    if (typeof x === 'object') {\n        return { ...x };\n    }\n    return x;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { ctxCallOutOfScope } from '@milkdown/exception';\n\nimport { shallowClone } from './shallow-clone';\n\nexport type $Slice<T = unknown, N extends string = string> = {\n    readonly id: symbol;\n    readonly name: N;\n    readonly set: (value: T) => void;\n    readonly get: () => T;\n    readonly update: (updater: (prev: T) => T) => void;\n};\n\nexport type SliceMap = Map<symbol, $Slice>;\n\nexport type Slice<T, N extends string = string> = {\n    readonly id: symbol;\n    readonly sliceName: N;\n    readonly _typeInfo: () => T;\n    (container: SliceMap, resetValue?: T): $Slice<T>;\n};\n\nexport const createSlice = <T, N extends string = string>(value: T, name: N): Slice<T, N> => {\n    const id = Symbol('Context');\n\n    const factory = (container: SliceMap, resetValue = shallowClone(value)) => {\n        let inner = resetValue;\n\n        const context: $Slice<T> = {\n            name,\n            id,\n            set: (next) => {\n                inner = next;\n            },\n            get: () => inner,\n            update: (updater) => {\n                inner = updater(inner);\n            },\n        };\n        container.set(id, context as $Slice);\n        return context;\n    };\n    factory.sliceName = name;\n    factory.id = id;\n    factory._typeInfo = (): T => {\n        throw ctxCallOutOfScope();\n    };\n\n    return factory;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { $Slice, Container, Slice } from '../context';\nimport type { Clock, Timer } from '../timing';\n\n/**\n * The ctx object that can be accessed in plugin and action.\n */\nexport class Ctx {\n    #container: Container;\n    #clock: Clock;\n\n    constructor(container: Container, clock: Clock) {\n        this.#container = container;\n        this.#clock = clock;\n    }\n\n    /**\n     * Get the slice instance.\n     *\n     * @param slice - The slice or slice name that needs to be used.\n     * @returns The slice instance.\n     */\n    readonly use = <T, N extends string = string>(slice: Slice<T, N> | N): $Slice<T, N> =>\n        this.#container.getSlice(slice);\n\n    /**\n     * Get the slice value.\n     *\n     * @param slice - The slice needs to be used.\n     * @returns The slice value.\n     */\n    readonly get = <T, N extends string>(slice: Slice<T, N>) => this.use(slice).get();\n\n    /**\n     * Set the slice value.\n     *\n     * @param slice - The slice needs to be used.\n     * @param value - The default value.\n     * @returns\n     */\n    readonly set = <T, N extends string>(slice: Slice<T, N>, value: T) => this.use(slice).set(value);\n\n    /**\n     * Update the slice by its current value.\n     *\n     * @example\n     * ```\n     * update(NumberSlice, x => x + 1);\n     * ```\n     *\n     * @param slice - The slice needs to be used.\n     * @param updater - The update function, gets current value as parameter and returns new value.\n     * @returns\n     */\n    readonly update = <T, N extends string>(slice: Slice<T, N>, updater: (prev: T) => T) =>\n        this.use(slice).update(updater);\n\n    /**\n     * Get the timer instance.\n     *\n     * @param timer - The timer needs to be used.\n     * @returns The timer instance.\n     */\n    readonly timing = (timer: Timer) => this.#clock.get(timer);\n\n    /**\n     * Wait for a timer to finish.\n     *\n     * @param timer - The timer needs to be used.\n     * @returns A promise that will be resolved when timer finish.\n     */\n    readonly wait = (timer: Timer) => this.timing(timer)();\n\n    /**\n     * Finish a timer\n     *\n     * @param timer - The timer needs to be finished.\n     * @returns\n     */\n    readonly done = (timer: Timer) => this.timing(timer).done();\n\n    /**\n     * Wait for a list of timers in target slice to be all finished.\n     *\n     * @param slice - The slice that holds a list of timer.\n     * @returns A promise that will be resolved when all timers finish.\n     */\n    readonly waitTimers = async (slice: Slice<Timer[]>) => {\n        await Promise.all(this.get(slice).map((x) => this.wait(x)));\n        return;\n    };\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { $Slice, Container, Slice } from '../context';\nimport { Clock, Timer } from '../timing';\n\nexport class Env {\n    #container: Container;\n    #clock: Clock;\n\n    constructor(container: Container, clock: Clock) {\n        this.#container = container;\n        this.#clock = clock;\n    }\n\n    /**\n     * Inject a context into current editor.\n     *\n     * @param ctx - The context needs to be injected.\n     * @param defaultValue - The default value of this context.\n     * @returns Pre.\n     */\n    readonly inject = <T>(ctx: Slice<T>, defaultValue?: T) => {\n        ctx(this.#container.sliceMap, defaultValue);\n        return this;\n    };\n\n    /**\n     * Start to record for a timer.\n     *\n     * @param timer - The timer needs to be recorded.\n     * @returns Pre.\n     */\n    readonly record = (timer: Timer) => {\n        timer(this.#clock.store);\n        return this;\n    };\n\n    /**\n     * Get the slice instance.\n     *\n     * @param slice - The slice or slice name that needs to be used.\n     * @returns The slice instance.\n     */\n    readonly use = <T, N extends string = string>(slice: Slice<T, N> | N): $Slice<T, N> =>\n        this.#container.getSlice(slice);\n\n    /**\n     * Get the slice value.\n     *\n     * @param slice - The slice needs to be used.\n     * @returns The slice value.\n     */\n    readonly get = <T, N extends string>(slice: Slice<T, N>) => this.use(slice).get();\n\n    /**\n     * Set the slice value.\n     *\n     * @param slice - The slice needs to be used.\n     * @param value - The default value.\n     * @returns\n     */\n    readonly set = <T, N extends string>(slice: Slice<T, N>, value: T) => this.use(slice).set(value);\n\n    /**\n     * Update the slice by its current value.\n     *\n     * @example\n     * ```\n     * update(NumberSlice, x => x + 1);\n     * ```\n     *\n     * @param slice - The slice needs to be used.\n     * @param updater - The update function, gets current value as parameter and returns new value.\n     * @returns\n     */\n    readonly update = <T, N extends string>(slice: Slice<T, N>, updater: (prev: T) => T) =>\n        this.use(slice).update(updater);\n\n    /**\n     * Get the timer instance.\n     *\n     * @param timer - The timer needs to be used.\n     * @returns The timer instance.\n     */\n    readonly timing = (timer: Timer) => this.#clock.get(timer);\n\n    /**\n     * Wait for a timer to finish.\n     *\n     * @param timer - The timer needs to be used.\n     * @returns A promise that will be resolved when timer finish.\n     */\n    readonly wait = (timer: Timer) => this.timing(timer)();\n\n    /**\n     * Finish a timer\n     *\n     * @param timer - The timer needs to be finished.\n     * @returns\n     */\n    readonly done = (timer: Timer) => this.timing(timer).done();\n\n    /**\n     * Wait for a list of timers in target slice to be all finished.\n     *\n     * @param slice - The slice that holds a list of timer.\n     * @returns A promise that will be resolved when all timers finish.\n     */\n    readonly waitTimers = async (slice: Slice<Timer[]>) => {\n        await Promise.all(this.get(slice).map((x) => this.wait(x)));\n        return;\n    };\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Container, Slice } from '../context';\nimport type { Clock, Timer } from '../timing';\n\nexport class Pre {\n    #container: Container;\n    #clock: Clock;\n\n    constructor(container: Container, clock: Clock) {\n        this.#container = container;\n        this.#clock = clock;\n    }\n\n    /**\n     * Inject a context into current editor.\n     *\n     * @param ctx - The context needs to be injected.\n     * @param defaultValue - The default value of this context.\n     * @returns Pre.\n     */\n    readonly inject = <T>(ctx: Slice<T>, defaultValue?: T) => {\n        ctx(this.#container.sliceMap, defaultValue);\n        return this;\n    };\n\n    /**\n     * Start to record for a timer.\n     *\n     * @param timer - The timer needs to be recorded.\n     * @returns Pre.\n     */\n    readonly record = (timer: Timer) => {\n        timer(this.#clock.store);\n        return this;\n    };\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { timerNotFound } from '@milkdown/exception';\n\nimport { Timing } from './timing';\n\nexport type ClockMap = Map<symbol, Timing>;\n\nexport type Timer = {\n    (store: ClockMap): Timing;\n    id: symbol;\n};\n\nexport type Clock = {\n    store: ClockMap;\n    get: (timer: Timer) => Timing;\n};\n\nexport const createClock = (): Clock => {\n    const store: ClockMap = new Map();\n    const get = (timer: Timer) => {\n        const meta = store.get(timer.id);\n        if (!meta) throw timerNotFound(timer.name);\n        return meta;\n    };\n\n    return {\n        store,\n        get,\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { ClockMap, Timer } from './clock';\n\nexport type Timing = {\n    (): Promise<void>;\n    done: () => void;\n};\n\nexport const createTimer = (name: string, timeout = 3000): Timer => {\n    const id = Symbol('Timer');\n\n    const timer = (store: ClockMap) => {\n        let promise: Promise<void> | null = null;\n        let listener: EventListener;\n\n        const data = Symbol(name);\n\n        const timing: Timing = () =>\n            (promise ??= new Promise((resolve, reject) => {\n                listener = (e: Event) => {\n                    if (!(e instanceof CustomEvent)) {\n                        return;\n                    }\n                    if (e.detail.id === data) {\n                        removeEventListener(name, listener);\n                        e.stopImmediatePropagation();\n                        resolve();\n                    }\n                };\n                setTimeout(() => {\n                    reject(`Timing ${name} timeout.`);\n                    removeEventListener(name, listener);\n                }, timeout);\n                addEventListener(name, listener);\n            }));\n        timing.done = () => {\n            const event = new CustomEvent(name, { detail: { id: data } });\n            dispatchEvent(event);\n        };\n\n        store.set(id, timing);\n\n        return timing;\n    };\n    timer.id = id;\n\n    return timer;\n};\n"],"names":[],"mappings":";;;;;;;;;;AAUO,MAAM,IAAkB,MAAiB;AACtC,QAAA,wBAAoC;AAanC,SAAA,EAAE,UAXQ,CAA+B,MAAyC;AAC/E,UAAA,IACF,OAAO,KAAU,WAAW,CAAC,GAAG,EAAS,OAAQ,CAAA,EAAE,KAAK,CAAC,MAAM,EAAE,SAAS,CAAK,IAAI,EAAS,IAAI,EAAM,EAAE;AAE5G,QAAI,CAAC,GAAS;AACV,YAAM,IAAO,OAAO,KAAU,WAAW,IAAQ,EAAM;AACvD,YAAM,EAAgB,CAAI;AAAA,IAC9B;AACO,WAAA;AAAA,EAAA,GAGQ;AACvB,GCvBa,IAAe,CAAI,MACxB,MAAM,QAAQ,CAAC,IACR,CAAC,GAAI,CAAe,IAE3B,OAAO,KAAM,WACN,EAAE,GAAG,MAET,GCaE,IAAc,CAA+B,GAAU,MAAyB;AACnF,QAAA,IAAK,OAAO,SAAS,GAErB,IAAU,CAAC,GAAqB,IAAa,EAAa,CAAK,MAAM;AACvE,QAAI,IAAQ;AAEZ,UAAM,IAAqB;AAAA,MACvB;AAAA,MACA;AAAA,MACA,KAAK,CAAC,MAAS;AACH,YAAA;AAAA,MACZ;AAAA,MACA,KAAK,MAAM;AAAA,MACX,QAAQ,CAAC,MAAY;AACjB,YAAQ,EAAQ,CAAK;AAAA,MACzB;AAAA,IAAA;AAEM,aAAA,IAAI,GAAI,CAAiB,GAC5B;AAAA,EAAA;AAEX,WAAQ,YAAY,GACpB,EAAQ,KAAK,GACb,EAAQ,YAAY,MAAS;AACzB,UAAM,EAAkB;AAAA,EAAA,GAGrB;AACX;;AC1CO,MAAM,EAAI;AAAA,EAIb,YAAY,GAAsB,GAAc;AAHhD;AACA;AAaA,SAAS,MAAM,CAA+B,MAC1C,QAAK,GAAW,SAAS,CAAK,GAQlC,KAAS,MAAM,CAAsB,MAAuB,KAAK,IAAI,CAAK,EAAE,OASnE,KAAA,MAAM,CAAsB,GAAoB,MAAa,KAAK,IAAI,CAAK,EAAE,IAAI,CAAK,GActF,KAAA,SAAS,CAAsB,GAAoB,MACxD,KAAK,IAAI,CAAK,EAAE,OAAO,CAAO,GAQlC,KAAS,SAAS,CAAC,MAAiB,QAAK,GAAO,IAAI,CAAK,GAQzD,KAAS,OAAO,CAAC,MAAiB,KAAK,OAAO,CAAK,KAQnD,KAAS,OAAO,CAAC,MAAiB,KAAK,OAAO,CAAK,EAAE,QAQ5C,KAAA,aAAa,OAAO,MAA0B;AACnD,YAAM,QAAQ,IAAI,KAAK,IAAI,CAAK,EAAE,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC;AAAA,IAC1D,GA7EA,QAAK,GAAa,IAClB,QAAK,GAAS;AAAA,EAClB;AA6EJ;AAnFI,mBACA;;ACLG,MAAM,EAAI;AAAA,EAIb,YAAY,GAAsB,GAAc;AAHhD;AACA;AAcS,SAAA,SAAS,CAAI,GAAe,MAC7B,GAAA,QAAK,GAAW,UAAU,CAAY,GACnC,OASF,KAAA,SAAS,CAAC,MACT,GAAA,QAAK,GAAO,KAAK,GAChB,OASX,KAAS,MAAM,CAA+B,MAC1C,QAAK,GAAW,SAAS,CAAK,GAQlC,KAAS,MAAM,CAAsB,MAAuB,KAAK,IAAI,CAAK,EAAE,OASnE,KAAA,MAAM,CAAsB,GAAoB,MAAa,KAAK,IAAI,CAAK,EAAE,IAAI,CAAK,GActF,KAAA,SAAS,CAAsB,GAAoB,MACxD,KAAK,IAAI,CAAK,EAAE,OAAO,CAAO,GAQlC,KAAS,SAAS,CAAC,MAAiB,QAAK,GAAO,IAAI,CAAK,GAQzD,KAAS,OAAO,CAAC,MAAiB,KAAK,OAAO,CAAK,KAQnD,KAAS,OAAO,CAAC,MAAiB,KAAK,OAAO,CAAK,EAAE,QAQ5C,KAAA,aAAa,OAAO,MAA0B;AACnD,YAAM,QAAQ,IAAI,KAAK,IAAI,CAAK,EAAE,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC;AAAA,IAC1D,GApGA,QAAK,GAAa,IAClB,QAAK,GAAS;AAAA,EAClB;AAoGJ;AA1GI,mBACA;;ACFG,MAAM,EAAI;AAAA,EAIb,YAAY,GAAsB,GAAc;AAHhD;AACA;AAcS,SAAA,SAAS,CAAI,GAAe,MAC7B,GAAA,QAAK,GAAW,UAAU,CAAY,GACnC,OASF,KAAA,SAAS,CAAC,MACT,GAAA,QAAK,GAAO,KAAK,GAChB,OAxBP,QAAK,GAAa,IAClB,QAAK,GAAS;AAAA,EAClB;AAwBJ;AA9BI,mBACA;ACWG,MAAM,IAAc,MAAa;AAC9B,QAAA,wBAAsB;AAOrB,SAAA;AAAA,IACH;AAAA,IACA,KARQ,CAAC,MAAiB;AAC1B,YAAM,IAAO,EAAM,IAAI,EAAM,EAAE;AAC/B,UAAI,CAAC;AAAY,cAAA,EAAc,EAAM,IAAI;AAClC,aAAA;AAAA,IAAA;AAAA,EAKP;AAER,GCrBa,IAAc,CAAC,GAAc,IAAU,QAAgB;AAC1D,QAAA,IAAK,OAAO,OAAO,GAEnB,IAAQ,CAAC,MAAoB;AAC/B,QAAI,IAAgC,MAChC;AAEE,UAAA,IAAO,OAAO,CAAI,GAElB,IAAiB,MAClB,oBAAY,IAAI,QAAQ,CAAC,GAAS,MAAW;AAC1C,UAAW,CAAC,MAAa;AACjB,qBAAe,eAGf,EAAE,OAAO,OAAO,KAChB,qBAAoB,GAAM,CAAQ,GAClC,EAAE,yBAAyB,GACnB;MACZ,GAEJ,WAAW,MAAM;AACb,UAAO,UAAU,YAAe,GAChC,oBAAoB,GAAM,CAAQ;AAAA,SACnC,CAAO,GACV,iBAAiB,GAAM,CAAQ;AAAA,IAAA,CAClC;AACL,aAAO,OAAO,MAAM;AACV,YAAA,IAAQ,IAAI,YAAY,GAAM,EAAE,QAAQ,EAAE,IAAI,EAAK,EAAA,CAAG;AAC5D,oBAAc,CAAK;AAAA,IAAA,GAGjB,EAAA,IAAI,GAAI,CAAM,GAEb;AAAA,EAAA;AAEX,WAAM,KAAK,GAEJ;AACX;"}