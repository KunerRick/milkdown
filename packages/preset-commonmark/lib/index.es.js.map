{"version":3,"file":"index.es.js","sources":["../src/supported-keys.ts","../src/mark/code-inline.ts","../src/mark/em.ts","../src/mark/link.ts","../src/mark/strong.ts","../src/mark/index.ts","../src/node/blockquote.ts","../src/node/bullet-list.ts","../src/node/code-fence.ts","../src/node/doc.ts","../src/node/hardbreak.ts","../src/node/heading.ts","../src/node/hr.ts","../src/node/image.ts","../src/node/list-item.ts","../src/node/ordered-list.ts","../src/node/paragraph.ts","../src/node/text.ts","../src/node/index.ts","../src/plugin/add-order-in-list.ts","../src/plugin/filter-html.ts","../src/plugin/inline-nodes-cursor.ts","../src/plugin/inline-sync.ts","../src/plugin/index.ts","../src/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nexport const SupportedKeys = {\n    HardBreak: 'HardBreak',\n    Blockquote: 'Blockquote',\n    BulletList: 'BulletList',\n    OrderedList: 'OrderedList',\n    CodeFence: 'CodeFence',\n    H1: 'H1',\n    H2: 'H2',\n    H3: 'H3',\n    H4: 'H4',\n    H5: 'H5',\n    H6: 'H6',\n    DowngradeHeading: 'DowngradeHeading',\n    Text: 'Text',\n    CodeInline: 'CodeInline',\n    Em: 'Em',\n    Bold: 'Bold',\n    NextListItem: 'NextListItem',\n    SinkListItem: 'SinkListItem',\n    LiftListItem: 'LiftListItem',\n} as const;\n\nexport type SupportedKeys = typeof SupportedKeys;\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { MarkType } from '@milkdown/prose/model';\nimport { createMark, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['CodeInline'];\nconst id = 'code_inline';\n\nexport const ToggleInlineCode = createCmdKey('ToggleInlineCode');\n\nexport const codeInline = createMark<Keys>((utils) => {\n    return {\n        id,\n        schema: () => ({\n            priority: 100,\n            code: true,\n            inclusive: false,\n            parseDOM: [{ tag: 'code' }],\n            toDOM: (mark) => ['code', { class: utils.getClassName(mark.attrs, 'code-inline') }],\n            parseMarkdown: {\n                match: (node) => node.type === 'inlineCode',\n                runner: (state, node, markType) => {\n                    state.openMark(markType);\n                    state.addText(node['value'] as string);\n                    state.closeMark(markType);\n                },\n            },\n            toMarkdown: {\n                match: (mark) => mark.type.name === id,\n                runner: (state, mark, node) => {\n                    state.withMark(mark, 'inlineCode', node.text || '');\n                },\n            },\n        }),\n        commands: (markType) => [\n            createCmd(ToggleInlineCode, () => (state, dispatch) => {\n                const { selection, tr } = state;\n                if (selection.empty) return false;\n                const { from, to } = selection;\n\n                const has = state.doc.rangeHasMark(from, to, markType);\n                if (has) {\n                    dispatch?.(tr.removeMark(from, to, markType));\n                    return true;\n                }\n\n                const restMarksName = Object.keys(state.schema.marks).filter((x) => x !== markType.name);\n\n                restMarksName\n                    .map((name) => state.schema.marks[name] as MarkType)\n                    .forEach((t) => {\n                        tr.removeMark(from, to, t);\n                    });\n\n                dispatch?.(tr.addMark(from, to, markType.create()));\n                return true;\n            }),\n        ],\n        shortcuts: {\n            [SupportedKeys.CodeInline]: createShortcut(ToggleInlineCode, 'Mod-e'),\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { toggleMark } from '@milkdown/prose/commands';\nimport { createMark, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['Em'];\n\nconst id = 'em';\n\nexport const ToggleItalic = createCmdKey('ToggleItalic');\nexport const em = createMark<Keys>((utils) => ({\n    id,\n    schema: () => ({\n        inclusive: false,\n        parseDOM: [\n            { tag: 'i' },\n            { tag: 'em' },\n            { style: 'font-style', getAttrs: (value) => (value === 'italic') as false },\n        ],\n        toDOM: (mark) => ['em', { class: utils.getClassName(mark.attrs, id) }],\n        parseMarkdown: {\n            match: (node) => node.type === 'emphasis',\n            runner: (state, node, markType) => {\n                state.openMark(markType);\n                state.next(node.children);\n                state.closeMark(markType);\n            },\n        },\n        toMarkdown: {\n            match: (mark) => mark.type.name === id,\n            runner: (state, mark) => {\n                state.withMark(mark, 'emphasis');\n            },\n        },\n    }),\n    commands: (markType) => [createCmd(ToggleItalic, () => toggleMark(markType))],\n    shortcuts: {\n        [SupportedKeys.Em]: createShortcut(ToggleItalic, 'Mod-i'),\n    },\n}));\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { commandsCtx, createCmd, createCmdKey, ThemeInputChipType } from '@milkdown/core';\nimport { expectDomTypeError, missingRootElement } from '@milkdown/exception';\nimport { calculateTextPosition } from '@milkdown/prose';\nimport { toggleMark } from '@milkdown/prose/commands';\nimport { Node as ProseNode } from '@milkdown/prose/model';\nimport { NodeSelection, Plugin, PluginKey, TextSelection } from '@milkdown/prose/state';\nimport { EditorView } from '@milkdown/prose/view';\nimport { createMark } from '@milkdown/utils';\n\nconst key = new PluginKey('MILKDOWN_LINK_INPUT');\n\nexport const ToggleLink = createCmdKey<string>('ToggleLink');\nexport const ModifyLink = createCmdKey<string>('ModifyLink');\nconst id = 'link';\nexport type LinkOptions = {\n    input: {\n        placeholder: string;\n        buttonText?: string;\n    };\n};\nexport const link = createMark<string, LinkOptions>((utils, options) => {\n    return {\n        id,\n        schema: () => ({\n            attrs: {\n                href: {},\n                title: { default: null },\n            },\n            parseDOM: [\n                {\n                    tag: 'a[href]',\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        return { href: dom.getAttribute('href'), title: dom.getAttribute('title') };\n                    },\n                },\n            ],\n            toDOM: (mark) => ['a', { ...mark.attrs, class: utils.getClassName(mark.attrs, id) }],\n            parseMarkdown: {\n                match: (node) => node.type === 'link',\n                runner: (state, node, markType) => {\n                    const url = node['url'] as string;\n                    const title = node['title'] as string;\n                    state.openMark(markType, { href: url, title });\n                    state.next(node.children);\n                    state.closeMark(markType);\n                },\n            },\n            toMarkdown: {\n                match: (mark) => mark.type.name === id,\n                runner: (state, mark) => {\n                    state.withMark(mark, 'link', undefined, {\n                        title: mark.attrs['title'],\n                        url: mark.attrs['href'],\n                    });\n                },\n            },\n        }),\n        commands: (markType) => [\n            createCmd(ToggleLink, (href = '') => toggleMark(markType, { href })),\n            createCmd(ModifyLink, (href = '') => (state, dispatch) => {\n                if (!dispatch) return false;\n\n                const { marks } = state.schema;\n\n                let node: ProseNode | undefined;\n                let pos = -1;\n                const { selection } = state;\n                const { from, to } = selection;\n                state.doc.nodesBetween(from, from === to ? to + 1 : to, (n, p) => {\n                    if (marks['link']?.isInSet(n.marks)) {\n                        node = n;\n                        pos = p;\n                        return false;\n                    }\n                    return;\n                });\n                if (!node) return false;\n\n                const mark = node.marks.find(({ type }) => type === markType);\n                if (!mark) return false;\n\n                const start = pos;\n                const end = pos + node.nodeSize;\n                const { tr } = state;\n                const linkMark = marks['link']?.create({ ...mark.attrs, href });\n                if (!linkMark) return false;\n                dispatch(\n                    tr\n                        .removeMark(start, end, mark)\n                        .addMark(start, end, linkMark)\n                        .setSelection(new TextSelection(tr.selection.$anchor))\n                        .scrollIntoView(),\n                );\n\n                return true;\n            }),\n        ],\n        prosePlugins: (type, ctx) => {\n            let renderOnTop = false;\n            return [\n                new Plugin({\n                    key,\n                    view: (editorView) => {\n                        const inputChipRenderer = utils.themeManager.get<ThemeInputChipType>('input-chip', {\n                            placeholder: options?.input?.placeholder ?? 'Input Web Link',\n                            buttonText: options?.input?.buttonText,\n                            onUpdate: (value) => {\n                                ctx.get(commandsCtx).call(ModifyLink, value);\n                            },\n                            calculatePosition: (view, input) => {\n                                calculateTextPosition(view, input, (start, end, target, parent) => {\n                                    const $editor = view.dom.parentElement;\n                                    if (!$editor) {\n                                        throw missingRootElement();\n                                    }\n\n                                    const selectionWidth = end.left - start.left;\n                                    let left = start.left - parent.left - (target.width - selectionWidth) / 2;\n                                    let top = start.bottom - parent.top + 14 + $editor.scrollTop;\n\n                                    if (renderOnTop) {\n                                        top = start.top - parent.top - target.height - 14 + $editor.scrollTop;\n                                    }\n\n                                    if (left < 0) left = 0;\n\n                                    return [top, left];\n                                });\n                            },\n                        });\n                        if (!inputChipRenderer) return {};\n                        const shouldDisplay = (view: EditorView) => {\n                            const { selection, doc } = view.state;\n                            const { from, to } = selection;\n\n                            if (!view.hasFocus()) {\n                                return false;\n                            }\n\n                            if (\n                                selection.empty &&\n                                selection instanceof TextSelection &&\n                                to < doc.content.size &&\n                                from < doc.content.size &&\n                                doc.rangeHasMark(from, from === to ? to + 1 : to, type)\n                            ) {\n                                renderOnTop = false;\n                                return true;\n                            }\n\n                            if (selection instanceof NodeSelection) {\n                                const { node } = selection;\n                                if (\n                                    node.type.name === 'image' &&\n                                    node.marks.findIndex((mark) => mark.type.name === id) > -1\n                                ) {\n                                    renderOnTop = true;\n                                    return true;\n                                }\n                            }\n\n                            return false;\n                        };\n                        const getCurrentLink = (view: EditorView) => {\n                            const { selection } = view.state;\n                            let node: ProseNode | undefined;\n                            const { from, to } = selection;\n                            view.state.doc.nodesBetween(from, from === to ? to + 1 : to, (n) => {\n                                if (type.isInSet(n.marks)) {\n                                    node = n;\n                                    return false;\n                                }\n                                return;\n                            });\n                            if (!node) return;\n\n                            const mark = node.marks.find((m) => m.type === type);\n                            if (!mark) return;\n\n                            const value = mark.attrs['href'];\n                            return value;\n                        };\n                        const renderByView = (view: EditorView) => {\n                            if (!view.editable) {\n                                return;\n                            }\n                            const display = shouldDisplay(view);\n                            if (display) {\n                                inputChipRenderer.show(view);\n                                inputChipRenderer.update(getCurrentLink(view));\n                            } else {\n                                inputChipRenderer.hide();\n                            }\n                        };\n                        inputChipRenderer.init(editorView);\n                        renderByView(editorView);\n\n                        return {\n                            update: (view, prevState) => {\n                                const isEqualSelection =\n                                    prevState?.doc.eq(view.state.doc) && prevState.selection.eq(view.state.selection);\n                                if (isEqualSelection) return;\n\n                                requestAnimationFrame(() => {\n                                    renderByView(view);\n                                });\n                            },\n                            destroy: () => {\n                                inputChipRenderer.destroy();\n                            },\n                        };\n                    },\n                }),\n            ];\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { toggleMark } from '@milkdown/prose/commands';\nimport { createMark, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['Bold'];\nconst id = 'strong';\nexport const ToggleBold = createCmdKey('ToggleBold');\nexport const strong = createMark<Keys>((utils) => {\n    return {\n        id,\n        schema: () => ({\n            inclusive: false,\n            parseDOM: [\n                { tag: 'b' },\n                { tag: 'strong' },\n                { style: 'font-style', getAttrs: (value) => (value === 'bold') as false },\n            ],\n            toDOM: (mark) => ['strong', { class: utils.getClassName(mark.attrs, id) }],\n            parseMarkdown: {\n                match: (node) => node.type === 'strong',\n                runner: (state, node, markType) => {\n                    state.openMark(markType);\n                    state.next(node.children);\n                    state.closeMark(markType);\n                },\n            },\n            toMarkdown: {\n                match: (mark) => mark.type.name === id,\n                runner: (state, mark) => {\n                    state.withMark(mark, 'strong');\n                },\n            },\n        }),\n        commands: (markType) => [createCmd(ToggleBold, () => toggleMark(markType))],\n        shortcuts: {\n            [SupportedKeys.Bold]: createShortcut(ToggleBold, 'Mod-b'),\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { codeInline } from './code-inline';\nimport { em } from './em';\nimport { link } from './link';\nimport { strong } from './strong';\n\nexport const marks = [codeInline(), em(), strong(), link()];\n\nexport * from './code-inline';\nexport * from './em';\nexport * from './link';\nexport * from './strong';\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { wrapIn } from '@milkdown/prose/commands';\nimport { wrappingInputRule } from '@milkdown/prose/inputrules';\nimport { createNode, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['Blockquote'];\n\nconst id = 'blockquote';\n\nexport const WrapInBlockquote = createCmdKey('WrapInBlockquote');\n\nexport const blockquote = createNode<Keys>((utils) => {\n    return {\n        id,\n        schema: () => ({\n            content: 'block+',\n            group: 'block',\n            defining: true,\n            parseDOM: [{ tag: 'blockquote' }],\n            toDOM: (node) => ['blockquote', { class: utils.getClassName(node.attrs, id) }, 0],\n            parseMarkdown: {\n                match: ({ type }) => type === id,\n                runner: (state, node, type) => {\n                    state.openNode(type).next(node.children).closeNode();\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    state.openNode('blockquote').next(node.content).closeNode();\n                },\n            },\n        }),\n        inputRules: (nodeType) => [wrappingInputRule(/^\\s*>\\s$/, nodeType)],\n        commands: (nodeType) => [createCmd(WrapInBlockquote, () => wrapIn(nodeType))],\n        shortcuts: {\n            [SupportedKeys.Blockquote]: createShortcut(WrapInBlockquote, 'Mod-Shift-b'),\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { wrapIn } from '@milkdown/prose/commands';\nimport { wrappingInputRule } from '@milkdown/prose/inputrules';\nimport { createNode, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['BulletList'];\n\nexport const WrapInBulletList = createCmdKey('WrapInBulletList');\n\nexport const bulletList = createNode<Keys>((utils) => {\n    const id = 'bullet_list';\n    return {\n        id,\n        schema: () => ({\n            content: 'listItem+',\n            group: 'block',\n            attrs: {\n                spread: {\n                    default: false,\n                },\n            },\n            parseDOM: [\n                {\n                    tag: 'ul',\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        return {\n                            spread: dom.dataset['spread'],\n                        };\n                    },\n                },\n            ],\n            toDOM: (node) => {\n                return [\n                    'ul',\n                    {\n                        'data-spread': node.attrs['spread'],\n                        class: utils.getClassName(node.attrs, 'bullet-list'),\n                    },\n                    0,\n                ];\n            },\n            parseMarkdown: {\n                match: ({ type, ordered }) => type === 'list' && !ordered,\n                runner: (state, node, type) => {\n                    const spread = node['spread'] != null ? `${node['spread']}` : 'false';\n                    state.openNode(type, { spread }).next(node.children).closeNode();\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    state\n                        .openNode('list', undefined, { ordered: false, spread: node.attrs['spread'] === 'true' })\n                        .next(node.content)\n                        .closeNode();\n                },\n            },\n        }),\n        inputRules: (nodeType) => [wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType)],\n        commands: (nodeType) => [createCmd(WrapInBulletList, () => wrapIn(nodeType))],\n        shortcuts: {\n            [SupportedKeys.BulletList]: createShortcut(WrapInBulletList, 'Mod-Alt-8'),\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey, editorViewCtx, ThemeCodeFenceType } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { setBlockType } from '@milkdown/prose/commands';\nimport { textblockTypeInputRule } from '@milkdown/prose/inputrules';\nimport { Fragment } from '@milkdown/prose/model';\nimport { NodeView } from '@milkdown/prose/view';\nimport { createNode, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['CodeFence'];\n\nconst languageOptions = [\n    '',\n    'javascript',\n    'typescript',\n    'bash',\n    'sql',\n    'json',\n    'html',\n    'css',\n    'c',\n    'cpp',\n    'java',\n    'ruby',\n    'python',\n    'go',\n    'rust',\n    'markdown',\n];\n\nexport const backtickInputRegex = /^```(?<language>[a-z]*)?[\\s\\n]$/;\nexport const tildeInputRegex = /^~~~(?<language>[a-z]*)?[\\s\\n]$/;\n\nexport const TurnIntoCodeFence = createCmdKey('TurnIntoCodeFence');\n\nconst id = 'fence';\nexport const codeFence = createNode<Keys, { languageList?: string[] }>((utils, options) => {\n    const languageList = options?.languageList || languageOptions;\n\n    return {\n        id,\n        schema: (ctx) => ({\n            content: 'text*',\n            group: 'block',\n            marks: '',\n            defining: true,\n            code: true,\n            attrs: {\n                language: {\n                    default: '',\n                },\n                fold: {\n                    default: true,\n                },\n            },\n            parseDOM: [\n                {\n                    tag: 'div.code-fence-container',\n                    preserveWhitespace: 'full',\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        return { language: dom.querySelector('pre')?.dataset['language'] };\n                    },\n                    getContent: (dom, schema) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        const text = dom.querySelector('pre')?.textContent ?? '';\n                        if (!text) {\n                            return Fragment.empty;\n                        }\n                        const textNode = schema.text(text);\n                        return Fragment.from(textNode);\n                    },\n                },\n                {\n                    tag: 'pre',\n                    preserveWhitespace: 'full',\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        return { language: dom.dataset['language'] };\n                    },\n                },\n            ],\n            toDOM: (node) => {\n                const select = document.createElement('select');\n                languageList.forEach((lang) => {\n                    const option = document.createElement('option');\n                    option.value = lang;\n                    option.innerText = !lang ? '--' : lang;\n                    if (lang === node.attrs['language']) {\n                        option.selected = true;\n                    }\n                    select.appendChild(option);\n                });\n                select.onchange = (e) => {\n                    const target = e.target;\n                    if (!(target instanceof HTMLSelectElement)) {\n                        return;\n                    }\n                    const view = ctx.get(editorViewCtx);\n                    if (!view.editable) {\n                        target.value = node.attrs['language'];\n                        return;\n                    }\n\n                    const { top, left } = target.getBoundingClientRect();\n                    const result = view.posAtCoords({ top, left });\n                    if (!result) return;\n\n                    const { tr } = view.state;\n\n                    view.dispatch(\n                        tr.setNodeMarkup(result.inside, undefined, {\n                            ...node.attrs,\n                            language: target.value,\n                        }),\n                    );\n                };\n                return [\n                    'div',\n                    {\n                        class: 'code-fence-container',\n                    },\n                    select,\n                    [\n                        'pre',\n                        {\n                            'data-language': node.attrs['language'],\n                            class: utils.getClassName(node.attrs, 'code-fence'),\n                        },\n                        ['code', { spellCheck: 'false' }, 0],\n                    ],\n                ];\n            },\n            parseMarkdown: {\n                match: ({ type }) => type === 'code',\n                runner: (state, node, type) => {\n                    const language = node['lang'] as string;\n                    const value = node['value'] as string;\n                    state.openNode(type, { language });\n                    if (value) {\n                        state.addText(value);\n                    }\n                    state.closeNode();\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    state.addNode('code', undefined, node.content.firstChild?.text || '', {\n                        lang: node.attrs['language'],\n                    });\n                },\n            },\n        }),\n        inputRules: (nodeType) => [\n            textblockTypeInputRule(backtickInputRegex, nodeType, (match) => {\n                const [ok, language] = match;\n                if (!ok) return;\n                return { language };\n            }),\n            textblockTypeInputRule(tildeInputRegex, nodeType, (match) => {\n                const [ok, language] = match;\n                if (!ok) return;\n                return { language };\n            }),\n        ],\n        commands: (nodeType) => [createCmd(TurnIntoCodeFence, () => setBlockType(nodeType))],\n        shortcuts: {\n            [SupportedKeys.CodeFence]: createShortcut(TurnIntoCodeFence, 'Mod-Alt-c'),\n        },\n        view: () => (node, view, getPos) => {\n            let currNode = node;\n\n            const onSelectLanguage = (language: string) => {\n                const { tr } = view.state;\n                view.dispatch(\n                    tr.setNodeMarkup(getPos(), undefined, {\n                        fold: true,\n                        language,\n                    }),\n                );\n            };\n            const onBlur = () => {\n                const { tr } = view.state;\n\n                view.dispatch(\n                    tr.setNodeMarkup(getPos(), undefined, {\n                        ...currNode.attrs,\n                        fold: true,\n                    }),\n                );\n            };\n            const onFocus = () => {\n                const { tr } = view.state;\n\n                view.dispatch(\n                    tr.setNodeMarkup(getPos(), undefined, {\n                        ...currNode.attrs,\n                        fold: false,\n                    }),\n                );\n            };\n\n            const renderer = utils.themeManager.get<ThemeCodeFenceType>('code-fence', {\n                onBlur,\n                onFocus,\n                onSelectLanguage,\n                editable: () => view.editable,\n                languageList,\n            });\n            if (!renderer) return {} as NodeView;\n\n            const { dom, contentDOM, onUpdate, onDestroy } = renderer;\n            onUpdate(currNode);\n\n            return {\n                dom,\n                contentDOM,\n                update: (updatedNode) => {\n                    if (updatedNode.type.name !== id) return false;\n                    currNode = updatedNode;\n                    onUpdate(currNode);\n\n                    return true;\n                },\n                destroy: onDestroy,\n            };\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createNode } from '@milkdown/utils';\n\nexport const doc = createNode(() => {\n    return {\n        id: 'doc',\n        schema: () => ({\n            content: 'block+',\n            parseMarkdown: {\n                match: ({ type }) => type === 'root',\n                runner: (state, node, type) => {\n                    state.injectRoot(node, type);\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === 'doc',\n                runner: (state, node) => {\n                    state.openNode('root');\n                    state.next(node.content);\n                },\n            },\n        }),\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { Plugin, PluginKey, Selection } from '@milkdown/prose/state';\nimport { AddMarkStep, ReplaceStep } from '@milkdown/prose/transform';\nimport { createNode, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['HardBreak'];\n\nexport const InsertHardbreak = createCmdKey('InsertHardbreak');\n\nexport const HardbreakFilterPluginKey = new PluginKey('MILKDOWN_HARDBREAK_FILTER');\n\nexport const hardbreak = createNode<\n    Keys,\n    {\n        notIn: string[];\n    }\n>((utils, options) => {\n    const notIn = options?.notIn ?? ['table', 'fence'];\n    return {\n        id: 'hardbreak',\n        schema: () => ({\n            inline: true,\n            group: 'inline',\n            selectable: false,\n            parseDOM: [{ tag: 'br' }],\n            toDOM: (node) => ['br', { class: utils.getClassName(node.attrs, 'hardbreak') }],\n            parseMarkdown: {\n                match: ({ type }) => type === 'break',\n                runner: (state, _, type) => {\n                    state.addNode(type);\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === 'hardbreak',\n                runner: (state) => {\n                    state.addNode('break');\n                },\n            },\n        }),\n        commands: (type) => [\n            createCmd(InsertHardbreak, () => (state, dispatch) => {\n                const { selection, tr } = state;\n                if (selection.empty) {\n                    // Transform two successive hardbreak into a new line\n                    const node = selection.$from.node();\n                    if (node.childCount > 0 && node.lastChild?.type.name === 'hardbreak') {\n                        dispatch?.(\n                            tr\n                                .replaceRangeWith(selection.to - 1, selection.to, state.schema.node('paragraph'))\n                                .setSelection(Selection.near(tr.doc.resolve(selection.to)))\n                                .scrollIntoView(),\n                        );\n                        return true;\n                    }\n                }\n                dispatch?.(tr.setMeta('hardbreak', true).replaceSelectionWith(type.create()).scrollIntoView());\n                return true;\n            }),\n        ],\n        shortcuts: {\n            [SupportedKeys.HardBreak]: createShortcut(InsertHardbreak, 'Shift-Enter'),\n        },\n        prosePlugins: (type) => [\n            new Plugin({\n                key: HardbreakFilterPluginKey,\n                filterTransaction: (tr, state) => {\n                    const isInsertHr = tr.getMeta('hardbreak');\n                    const [step] = tr.steps;\n                    if (isInsertHr && step) {\n                        const { from } = step as unknown as { from: number };\n                        const $from = state.doc.resolve(from);\n                        let curDepth = $from.depth;\n                        let canApply = true;\n                        while (curDepth > 0) {\n                            if (notIn.includes($from.node(curDepth).type.name)) {\n                                canApply = false;\n                            }\n                            curDepth--;\n                        }\n                        return canApply;\n                    }\n                    return true;\n                },\n            }),\n            new Plugin({\n                key: new PluginKey('MILKDOWN_HARDBREAK_MARKS'),\n                appendTransaction: (trs, _oldState, newState) => {\n                    if (!trs.length) return;\n                    const [tr] = trs;\n                    if (!tr) return;\n\n                    const [step] = tr.steps;\n\n                    const isInsertHr = tr.getMeta('hardbreak');\n                    if (isInsertHr) {\n                        if (!(step instanceof ReplaceStep)) {\n                            return;\n                        }\n                        const { from } = step as unknown as { from: number };\n                        return newState.tr.setNodeMarkup(from, type, undefined, []);\n                    }\n\n                    const isAddMarkStep = step instanceof AddMarkStep;\n                    if (isAddMarkStep) {\n                        let _tr = newState.tr;\n                        const { from, to } = step as unknown as { from: number; to: number };\n                        newState.doc.nodesBetween(from, to, (node, pos) => {\n                            if (node.type === type) {\n                                _tr = _tr.setNodeMarkup(pos, type, undefined, []);\n                            }\n                        });\n\n                        return _tr;\n                    }\n\n                    return;\n                },\n            }),\n        ],\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey, Ctx, editorViewCtx, getPalette, schemaCtx } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { cloneTr } from '@milkdown/prose';\nimport { setBlockType } from '@milkdown/prose/commands';\nimport { textblockTypeInputRule } from '@milkdown/prose/inputrules';\nimport { Fragment, Node, NodeType } from '@milkdown/prose/model';\nimport { EditorState, Plugin, PluginKey, Transaction } from '@milkdown/prose/state';\nimport { Decoration, DecorationSet } from '@milkdown/prose/view';\nimport { createNode, createShortcut, ThemeUtils } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\nconst headingIndex = Array(6)\n    .fill(0)\n    .map((_, i) => i + 1);\n\ntype Keys =\n    | SupportedKeys['H1']\n    | SupportedKeys['H2']\n    | SupportedKeys['H3']\n    | SupportedKeys['H4']\n    | SupportedKeys['H5']\n    | SupportedKeys['H6']\n    | SupportedKeys['DowngradeHeading'];\n\nexport const TurnIntoHeading = createCmdKey<number>('TurnIntoHeading');\nexport const DowngradeHeading = createCmdKey('DowngradeHeading');\n\nexport const headingIdPluginKey = new PluginKey('MILKDOWN_HEADING_ID');\nexport const headingHashPluginKey = new PluginKey('MILKDOWN_HEADING_HASH');\n\nconst createId = (node: Node) =>\n    node.textContent\n        .replace(/[\\p{P}\\p{S}]/gu, '')\n        .replace(/\\s/g, '-')\n        .toLowerCase()\n        .trim();\n\nconst headingIdPlugin = (ctx: Ctx, type: NodeType, getId: (node: Node) => string): Plugin => {\n    let lock = false;\n    const walkThrough = (state: EditorState, callback: (tr: Transaction) => void) => {\n        const tr = state.tr.setMeta('addToHistory', false);\n        let found = false;\n        state.doc.descendants((node, pos) => {\n            if (node.type === type && !lock) {\n                if (node.textContent.trim().length === 0) {\n                    return;\n                }\n                const attrs = node.attrs;\n                const id = getId(node);\n\n                if (attrs['id'] !== id) {\n                    found = true;\n                    tr.setMeta(headingIdPluginKey, true).setNodeMarkup(pos, undefined, {\n                        ...attrs,\n                        id,\n                    });\n                }\n            }\n        });\n        if (found) {\n            callback(tr);\n        }\n    };\n    return new Plugin({\n        key: headingIdPluginKey,\n        props: {\n            handleDOMEvents: {\n                compositionstart: () => {\n                    lock = true;\n                    return false;\n                },\n                compositionend: () => {\n                    lock = false;\n                    const view = ctx.get(editorViewCtx);\n                    setTimeout(() => {\n                        walkThrough(view.state, (tr) => view.dispatch(tr));\n                    }, 0);\n                    return false;\n                },\n            },\n        },\n        appendTransaction: (transactions, _, nextState) => {\n            let tr: Transaction | null = null;\n\n            if (\n                transactions.every((transaction) => !transaction.getMeta(headingIdPluginKey)) &&\n                transactions.some((transaction) => transaction.docChanged)\n            ) {\n                walkThrough(nextState, (t) => {\n                    tr = t;\n                });\n            }\n\n            return tr;\n        },\n        view: (view) => {\n            const doc = view.state.doc;\n            let tr = view.state.tr.setMeta('addToHistory', false);\n            doc.descendants((node, pos) => {\n                if (node.type.name === 'heading' && node.attrs['level']) {\n                    if (!node.attrs['id']) {\n                        tr = tr.setNodeMarkup(pos, undefined, {\n                            ...node.attrs,\n                            id: getId(node),\n                        });\n                    }\n                }\n            });\n            view.dispatch(tr);\n            return {};\n        },\n    });\n};\n\nconst headingHashPlugin = (ctx: Ctx, type: NodeType, utils: ThemeUtils): Plugin => {\n    return new Plugin({\n        key: headingHashPluginKey,\n        state: {\n            init: () => {\n                return DecorationSet.empty;\n            },\n            apply: (tr) => {\n                const view = ctx.get(editorViewCtx);\n                if (!view.hasFocus?.() || !view.editable) return DecorationSet.empty;\n\n                const { $from } = tr.selection;\n                const node = $from.node();\n                if (node.type !== type) {\n                    return DecorationSet.empty;\n                }\n\n                const level = node.attrs['level'];\n                const getHashes = (level: number) => {\n                    return Array(level)\n                        .fill(0)\n                        .map((_) => `#`)\n                        .join('');\n                };\n                const widget = document.createElement('span');\n                widget.textContent = getHashes(level);\n                widget.contentEditable = 'false';\n                utils.themeManager.onFlush(() => {\n                    const style = utils.getStyle(({ css }) => {\n                        const palette = getPalette(utils.themeManager);\n                        return css`\n                            margin-right: 4px;\n                            color: ${palette('primary')};\n                        `;\n                    });\n                    if (style) {\n                        widget.className = style;\n                    }\n                });\n\n                const deco = Decoration.widget($from.before() + 1, widget, { side: -1 });\n                return DecorationSet.create(tr.doc, [deco]);\n            },\n        },\n        props: {\n            handleDOMEvents: {\n                focus: (view) => {\n                    const tr = cloneTr(view.state.tr);\n                    view.dispatch(tr);\n                    return false;\n                },\n            },\n            decorations(this: Plugin, state) {\n                return this.getState(state);\n            },\n        },\n    });\n};\n\nexport const heading = createNode<Keys, { getId: (node: Node) => string; displayHashtag: boolean }>(\n    (utils, options) => {\n        const id = 'heading';\n\n        const getId = options?.getId ?? createId;\n        const displayHashtag = options?.displayHashtag ?? true;\n\n        return {\n            id,\n            schema: () => ({\n                content: 'inline*',\n                group: 'block',\n                defining: true,\n                attrs: {\n                    id: {\n                        default: '',\n                    },\n                    level: {\n                        default: 1,\n                    },\n                },\n                parseDOM: headingIndex.map((x) => ({\n                    tag: `h${x}`,\n                    getAttrs: (node) => {\n                        if (!(node instanceof HTMLElement)) {\n                            throw expectDomTypeError(node);\n                        }\n                        return { level: x, id: node.id };\n                    },\n                })),\n                toDOM: (node) => {\n                    return [\n                        `h${node.attrs['level']}`,\n                        {\n                            id: node.attrs['id'] || getId(node),\n                            class: utils.getClassName(node.attrs, `heading h${node.attrs['level']}`),\n                        },\n                        0,\n                    ];\n                },\n                parseMarkdown: {\n                    match: ({ type }) => type === id,\n                    runner: (state, node, type) => {\n                        const depth = node['depth'] as number;\n                        state.openNode(type, { level: depth });\n                        state.next(node.children);\n                        state.closeNode();\n                    },\n                },\n                toMarkdown: {\n                    match: (node) => node.type.name === id,\n                    runner: (state, node) => {\n                        state.openNode('heading', undefined, { depth: node.attrs['level'] });\n                        const lastIsHardbreak = node.childCount >= 1 && node.lastChild?.type.name === 'hardbreak';\n                        if (lastIsHardbreak) {\n                            const contentArr: Node[] = [];\n                            node.content.forEach((n, _, i) => {\n                                if (i === node.childCount - 1) {\n                                    return;\n                                }\n                                contentArr.push(n);\n                            });\n                            state.next(Fragment.fromArray(contentArr));\n                        } else {\n                            state.next(node.content);\n                        }\n                        state.closeNode();\n                    },\n                },\n            }),\n            inputRules: (type, ctx) =>\n                headingIndex.map((x) =>\n                    textblockTypeInputRule(new RegExp(`^(#{1,${x}})\\\\s$`), type, () => {\n                        const view = ctx.get(editorViewCtx);\n                        const { $from } = view.state.selection;\n                        const node = $from.node();\n                        if (node.type.name === 'heading') {\n                            let level = Number(node.attrs['level']) + Number(x);\n                            if (level > 6) {\n                                level = 6;\n                            }\n                            return {\n                                level,\n                            };\n                        }\n                        return {\n                            level: x,\n                        };\n                    }),\n                ),\n            commands: (type, ctx) => [\n                createCmd(TurnIntoHeading, (level = 1) => {\n                    if (level < 1) {\n                        return setBlockType(level === 0 ? ctx.get(schemaCtx).nodes['paragraph'] || type : type);\n                    }\n                    return setBlockType(level === 0 ? ctx.get(schemaCtx).nodes['paragraph'] || type : type, { level });\n                }),\n                createCmd(DowngradeHeading, () => {\n                    return (state, dispatch, view) => {\n                        const { $from } = state.selection;\n                        const node = $from.node();\n                        if (node.type !== type || !state.selection.empty || $from.parentOffset !== 0) return false;\n\n                        const level = node.attrs['level'] - 1;\n                        if (!level) {\n                            return setBlockType(ctx.get(schemaCtx).nodes['paragraph'] || type)(state, dispatch, view);\n                        }\n\n                        dispatch?.(\n                            state.tr.setNodeMarkup(state.selection.$from.before(), undefined, {\n                                ...node.attrs,\n                                level,\n                            }),\n                        );\n                        return true;\n                    };\n                }),\n            ],\n            shortcuts: {\n                [SupportedKeys.H1]: createShortcut(TurnIntoHeading, 'Mod-Alt-1', 1),\n                [SupportedKeys.H2]: createShortcut(TurnIntoHeading, 'Mod-Alt-2', 2),\n                [SupportedKeys.H3]: createShortcut(TurnIntoHeading, 'Mod-Alt-3', 3),\n                [SupportedKeys.H4]: createShortcut(TurnIntoHeading, 'Mod-Alt-4', 4),\n                [SupportedKeys.H5]: createShortcut(TurnIntoHeading, 'Mod-Alt-5', 5),\n                [SupportedKeys.H6]: createShortcut(TurnIntoHeading, 'Mod-Alt-6', 6),\n                [SupportedKeys.DowngradeHeading]: createShortcut(DowngradeHeading, ['Backspace', 'Delete']),\n            },\n            prosePlugins: (type, ctx) => {\n                const plugins = [headingIdPlugin(ctx, type, getId)];\n                if (displayHashtag) {\n                    plugins.push(headingHashPlugin(ctx, type, utils));\n                }\n                return plugins;\n            },\n        };\n    },\n);\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey, schemaCtx } from '@milkdown/core';\nimport { InputRule } from '@milkdown/prose/inputrules';\nimport { Selection } from '@milkdown/prose/state';\nimport { createNode } from '@milkdown/utils';\n\nconst id = 'hr';\nexport const InsertHr = createCmdKey<string>('InsertHr');\nexport const hr = createNode((utils) => {\n    return {\n        id,\n        schema: () => ({\n            group: 'block',\n            parseDOM: [{ tag: 'hr' }],\n            toDOM: (node) => ['hr', { class: utils.getClassName(node.attrs, id) }],\n            parseMarkdown: {\n                match: ({ type }) => type === 'thematicBreak',\n                runner: (state, _, type) => {\n                    state.addNode(type);\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state) => {\n                    state.addNode('thematicBreak');\n                },\n            },\n        }),\n        inputRules: (type) => [\n            new InputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, (state, match, start, end) => {\n                const { tr } = state;\n\n                if (match[0]) {\n                    tr.replaceWith(start - 1, end, type.create());\n                }\n\n                return tr;\n            }),\n        ],\n        commands: (type, ctx) => [\n            createCmd(InsertHr, () => (state, dispatch) => {\n                if (!dispatch) return true;\n\n                const paragraph = ctx.get(schemaCtx).node('paragraph');\n                const { tr, selection } = state;\n                const { from } = selection;\n                const node = type.create();\n                if (!node) {\n                    return true;\n                }\n                const _tr = tr.replaceSelectionWith(node).insert(from, paragraph);\n                const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true);\n                if (!sel) {\n                    return true;\n                }\n                dispatch(_tr.setSelection(sel).scrollIntoView());\n                return true;\n            }),\n        ],\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { commandsCtx, createCmd, createCmdKey, ThemeImageType, ThemeInputChipType } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { findSelectedNodeOfType } from '@milkdown/prose';\nimport { InputRule } from '@milkdown/prose/inputrules';\nimport { Plugin, PluginKey } from '@milkdown/prose/state';\nimport { EditorView, NodeView } from '@milkdown/prose/view';\nimport { createNode } from '@milkdown/utils';\n\nexport const ModifyImage = createCmdKey<string>('ModifyImage');\nexport const InsertImage = createCmdKey<string>('InsertImage');\nconst id = 'image';\nexport type ImageOptions = {\n    isBlock: boolean;\n    placeholder: string;\n    input: {\n        placeholder: string;\n        buttonText?: string;\n    };\n};\nconst key = new PluginKey('MILKDOWN_IMAGE_INPUT');\n\nexport const image = createNode<string, ImageOptions>((utils, options) => {\n    return {\n        id: 'image',\n        schema: () => ({\n            inline: true,\n            group: 'inline',\n            selectable: true,\n            draggable: true,\n            marks: '',\n            atom: true,\n            defining: true,\n            isolating: true,\n            attrs: {\n                src: { default: '' },\n                alt: { default: '' },\n                title: { default: '' },\n            },\n            parseDOM: [\n                {\n                    tag: 'img[src]',\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        return {\n                            src: dom.getAttribute('src') || '',\n                            alt: dom.getAttribute('alt') || '',\n                            title: dom.getAttribute('title') || dom.getAttribute('alt') || '',\n                        };\n                    },\n                },\n            ],\n            toDOM: (node) => {\n                return [\n                    'img',\n                    {\n                        ...node.attrs,\n                        class: utils.getClassName(node.attrs, id),\n                    },\n                ];\n            },\n            parseMarkdown: {\n                match: ({ type }) => type === id,\n                runner: (state, node, type) => {\n                    const url = node['url'] as string;\n                    const alt = node['alt'] as string;\n                    const title = node['title'] as string;\n                    state.addNode(type, {\n                        src: url,\n                        alt,\n                        title,\n                    });\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    state.addNode('image', undefined, undefined, {\n                        title: node.attrs['title'],\n                        url: node.attrs['src'],\n                        alt: node.attrs['alt'],\n                    });\n                },\n            },\n        }),\n        commands: (type) => [\n            createCmd(InsertImage, (src = '') => (state, dispatch) => {\n                if (!dispatch) return true;\n                const { tr } = state;\n                const node = type.create({ src });\n                if (!node) {\n                    return true;\n                }\n                const _tr = tr.replaceSelectionWith(node);\n                dispatch(_tr.scrollIntoView());\n                return true;\n            }),\n            createCmd(ModifyImage, (src = '') => (state, dispatch) => {\n                const node = findSelectedNodeOfType(state.selection, type);\n                if (!node) return false;\n\n                const { tr } = state;\n                dispatch?.(\n                    tr.setNodeMarkup(node.pos, undefined, { ...node.node.attrs, loading: true, src }).scrollIntoView(),\n                );\n\n                return true;\n            }),\n        ],\n        inputRules: (type) => [\n            new InputRule(\n                /!\\[(?<alt>.*?)]\\((?<filename>.*?)\\s*(?=\"|\\))\"?(?<title>[^\"]+)?\"?\\)/,\n                (state, match, start, end) => {\n                    const [okay, alt, src = '', title] = match;\n                    const { tr } = state;\n                    if (okay) {\n                        tr.replaceWith(start, end, type.create({ src, alt, title }));\n                    }\n\n                    return tr;\n                },\n            ),\n        ],\n        view: () => (node) => {\n            let currNode = node;\n\n            const placeholder = options?.placeholder ?? 'Add an Image';\n            const isBlock = options?.isBlock ?? false;\n            const renderer = utils.themeManager.get<ThemeImageType>('image', {\n                placeholder,\n                isBlock,\n            });\n\n            if (!renderer) {\n                return {} as NodeView;\n            }\n\n            const { dom, onUpdate } = renderer;\n            onUpdate(currNode);\n\n            return {\n                dom,\n                update: (updatedNode) => {\n                    if (updatedNode.type.name !== id) return false;\n\n                    currNode = updatedNode;\n                    onUpdate(currNode);\n\n                    return true;\n                },\n                selectNode: () => {\n                    dom.classList.add('ProseMirror-selectednode');\n                },\n                deselectNode: () => {\n                    dom.classList.remove('ProseMirror-selectednode');\n                },\n            };\n        },\n        prosePlugins: (type, ctx) => {\n            return [\n                new Plugin({\n                    key,\n                    view: (editorView) => {\n                        const inputChipRenderer = utils.themeManager.get<ThemeInputChipType>('input-chip', {\n                            placeholder: options?.input?.placeholder ?? 'Input Image Link',\n                            buttonText: options?.input?.buttonText,\n                            onUpdate: (value) => {\n                                ctx.get(commandsCtx).call(ModifyImage, value);\n                            },\n                        });\n                        if (!inputChipRenderer) return {};\n                        const shouldDisplay = (view: EditorView) => {\n                            return Boolean(\n                                view.hasFocus() && type && findSelectedNodeOfType(view.state.selection, type),\n                            );\n                        };\n                        const getCurrentLink = (view: EditorView) => {\n                            const result = findSelectedNodeOfType(view.state.selection, type);\n                            if (!result) return;\n\n                            const value = result.node.attrs['src'];\n                            return value;\n                        };\n                        const renderByView = (view: EditorView) => {\n                            if (!view.editable) {\n                                return;\n                            }\n                            const display = shouldDisplay(view);\n                            if (display) {\n                                inputChipRenderer.show(view);\n                                inputChipRenderer.update(getCurrentLink(view));\n                            } else {\n                                inputChipRenderer.hide();\n                            }\n                        };\n                        inputChipRenderer.init(editorView);\n                        renderByView(editorView);\n\n                        return {\n                            update: (view, prevState) => {\n                                const isEqualSelection =\n                                    prevState?.doc.eq(view.state.doc) && prevState.selection.eq(view.state.selection);\n                                if (isEqualSelection) return;\n\n                                renderByView(view);\n                            },\n                            destroy: () => {\n                                inputChipRenderer.destroy();\n                            },\n                        };\n                    },\n                }),\n            ];\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { getNodeFromSchema } from '@milkdown/prose';\nimport { wrappingInputRule } from '@milkdown/prose/inputrules';\nimport { NodeType } from '@milkdown/prose/model';\nimport { liftListItem, sinkListItem, splitListItem } from '@milkdown/prose/schema-list';\nimport { EditorState, Plugin, PluginKey, Transaction } from '@milkdown/prose/state';\nimport { createNode, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['SinkListItem'] | SupportedKeys['LiftListItem'] | SupportedKeys['NextListItem'];\n\nconst id = 'list_item';\n\nexport const SplitListItem = createCmdKey('SplitListItem');\nexport const SinkListItem = createCmdKey('SinkListItem');\nexport const LiftListItem = createCmdKey('LiftListItem');\n\nconst keepListOrderPluginKey = new PluginKey('MILKDOWN_KEEP_LIST_ORDER');\n\nconst createKeepListOrderPlugin = (type: NodeType) => {\n    const walkThrough = (state: EditorState, callback: (tr: Transaction) => void) => {\n        const orderedListType = getNodeFromSchema('ordered_list', state.schema);\n        let tr = state.tr;\n        state.doc.descendants((node, pos, parent, index) => {\n            if (node.type === type && parent?.type === orderedListType) {\n                let changed = false;\n                const attrs = { ...node.attrs };\n                if (node.attrs['listType'] !== 'ordered') {\n                    attrs['listType'] = 'ordered';\n                    changed = true;\n                }\n\n                const base = parent?.maybeChild(0);\n                if (base && base.type === type && base.attrs['listType'] === 'ordered') {\n                    const label = base.attrs['label'];\n                    attrs['label'] = `${Number(label.slice(0, -1)) + index}.`;\n                    changed = true;\n                }\n\n                if (node.attrs['label'] === '•') {\n                    attrs['label'] = `${index + 1}.`;\n                    changed = true;\n                }\n\n                if (changed) {\n                    tr = tr.setNodeMarkup(pos, undefined, attrs);\n                }\n            }\n        });\n        callback(tr);\n    };\n    return new Plugin({\n        key: keepListOrderPluginKey,\n        appendTransaction: (transactions, _oldState, nextState) => {\n            let tr: Transaction | null = null;\n            if (transactions.some((transaction) => transaction.docChanged)) {\n                walkThrough(nextState, (t) => {\n                    tr = t;\n                });\n            }\n\n            return tr;\n        },\n    });\n};\n\nexport const listItem = createNode<Keys>((utils) => ({\n    id,\n    schema: () => ({\n        group: 'listItem',\n        content: 'paragraph block*',\n        attrs: {\n            label: {\n                default: '•',\n            },\n            listType: {\n                default: 'bullet',\n            },\n            spread: {\n                default: 'true',\n            },\n        },\n        defining: true,\n        parseDOM: [\n            {\n                tag: 'li.list-item',\n                getAttrs: (dom) => {\n                    if (!(dom instanceof HTMLElement)) {\n                        throw expectDomTypeError(dom);\n                    }\n                    return {\n                        label: dom.dataset['label'],\n                        listType: dom.dataset['list-type'],\n                        spread: dom.dataset['spread'],\n                    };\n                },\n                contentElement: 'div.list-item_body',\n            },\n            { tag: 'li' },\n        ],\n        toDOM: (node) => {\n            return [\n                'li',\n                {\n                    class: utils.getClassName(node.attrs, 'list-item'),\n                    'data-label': node.attrs['label'],\n                    'data-list-type': node.attrs['listType'],\n                    'data-spread': node.attrs['spread'],\n                },\n                ['div', { class: utils.getClassName(node.attrs, 'list-item_label') }, node.attrs['label']],\n                ['div', { class: utils.getClassName(node.attrs, 'list-item_body') }, 0],\n            ];\n        },\n        parseMarkdown: {\n            match: ({ type, checked }) => type === 'listItem' && checked === null,\n            runner: (state, node, type) => {\n                const label = node['label'] != null ? `${node['label']}.` : '•';\n                const listType = node['label'] != null ? 'ordered' : 'bullet';\n                const spread = node['spread'] != null ? `${node['spread']}` : 'true';\n                state.openNode(type, { label, listType, spread });\n                state.next(node.children);\n                state.closeNode();\n            },\n        },\n        toMarkdown: {\n            match: (node) => node.type.name === id,\n            runner: (state, node) => {\n                state.openNode('listItem', undefined, { spread: node.attrs['spread'] === 'true' });\n                state.next(node.content);\n                state.closeNode();\n            },\n        },\n    }),\n    inputRules: (nodeType) => [wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType)],\n    commands: (nodeType) => [\n        createCmd(SplitListItem, () => splitListItem(nodeType)),\n        createCmd(SinkListItem, () => sinkListItem(nodeType)),\n        createCmd(LiftListItem, () => liftListItem(nodeType)),\n    ],\n    shortcuts: {\n        [SupportedKeys.NextListItem]: createShortcut(SplitListItem, 'Enter'),\n        [SupportedKeys.SinkListItem]: createShortcut(SinkListItem, 'Mod-]'),\n        [SupportedKeys.LiftListItem]: createShortcut(LiftListItem, 'Mod-['),\n    },\n    prosePlugins: (nodeType) => [createKeepListOrderPlugin(nodeType)],\n}));\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { wrapIn } from '@milkdown/prose/commands';\nimport { wrappingInputRule } from '@milkdown/prose/inputrules';\nimport { createNode, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['OrderedList'];\n\nexport const WrapInOrderedList = createCmdKey('WrapInOrderedList');\n\nconst id = 'ordered_list';\nexport const orderedList = createNode<Keys>((utils) => ({\n    id,\n    schema: () => ({\n        content: 'listItem+',\n        group: 'block',\n        attrs: {\n            order: {\n                default: 1,\n            },\n            spread: {\n                default: false,\n            },\n        },\n        parseDOM: [\n            {\n                tag: 'ol',\n                getAttrs: (dom) => {\n                    if (!(dom instanceof HTMLElement)) {\n                        throw expectDomTypeError(dom);\n                    }\n                    return {\n                        spread: dom.dataset['spread'],\n                        order: dom.hasAttribute('start') ? Number(dom.getAttribute('start')) : 1,\n                    };\n                },\n            },\n        ],\n        toDOM: (node) => [\n            'ol',\n            {\n                ...(node.attrs['order'] === 1 ? {} : node.attrs['order']),\n                'data-spread': node.attrs['spread'],\n                class: utils.getClassName(node.attrs, 'ordered-list'),\n            },\n            0,\n        ],\n        parseMarkdown: {\n            match: ({ type, ordered }) => type === 'list' && !!ordered,\n            runner: (state, node, type) => {\n                const spread = node['spread'] != null ? `${node['spread']}` : 'true';\n                state.openNode(type, { spread }).next(node.children).closeNode();\n            },\n        },\n        toMarkdown: {\n            match: (node) => node.type.name === id,\n            runner: (state, node) => {\n                state.openNode('list', undefined, { ordered: true, start: 1, spread: node.attrs['spread'] === 'true' });\n                state.next(node.content);\n                state.closeNode();\n            },\n        },\n    }),\n    inputRules: (nodeType) => [\n        wrappingInputRule(\n            /^(\\d+)\\.\\s$/,\n            nodeType,\n            (match) => ({ order: Number(match[1]) }),\n            (match, node) => node.childCount + node.attrs['order'] === Number(match[1]),\n        ),\n    ],\n    commands: (nodeType) => [createCmd(WrapInOrderedList, () => wrapIn(nodeType))],\n    shortcuts: {\n        [SupportedKeys.OrderedList]: createShortcut(WrapInOrderedList, 'Mod-Alt-7'),\n    },\n}));\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { setBlockType } from '@milkdown/prose/commands';\nimport { Fragment, Node } from '@milkdown/prose/model';\nimport { createNode, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from '../supported-keys';\n\ntype Keys = SupportedKeys['Text'];\n\nexport const TurnIntoText = createCmdKey('TurnIntoText');\n\nconst id = 'paragraph';\nexport const paragraph = createNode<Keys>((utils) => {\n    return {\n        id,\n        schema: () => ({\n            content: 'inline*',\n            group: 'block',\n            parseDOM: [{ tag: 'p' }],\n            toDOM: (node) => ['p', { class: utils.getClassName(node.attrs, id) }, 0],\n            parseMarkdown: {\n                match: (node) => node.type === 'paragraph',\n                runner: (state, node, type) => {\n                    state.openNode(type);\n                    if (node.children) {\n                        state.next(node.children);\n                    } else {\n                        state.addText(node['value'] as string);\n                    }\n                    state.closeNode();\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === 'paragraph',\n                runner: (state, node) => {\n                    state.openNode('paragraph');\n                    const lastIsHardbreak = node.childCount >= 1 && node.lastChild?.type.name === 'hardbreak';\n                    if (lastIsHardbreak) {\n                        const contentArr: Node[] = [];\n                        node.content.forEach((n, _, i) => {\n                            if (i === node.childCount - 1) {\n                                return;\n                            }\n                            contentArr.push(n);\n                        });\n                        state.next(Fragment.fromArray(contentArr));\n                    } else {\n                        state.next(node.content);\n                    }\n                    state.closeNode();\n                },\n            },\n        }),\n        commands: (nodeType) => [createCmd(TurnIntoText, () => setBlockType(nodeType))],\n        shortcuts: {\n            [SupportedKeys.Text]: createShortcut(TurnIntoText, 'Mod-Alt-0'),\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createNode } from '@milkdown/utils';\n\nexport const text = createNode(() => ({\n    id: 'text',\n    schema: () => ({\n        group: 'inline',\n        parseMarkdown: {\n            match: ({ type }) => type === 'text',\n            runner: (state, node) => {\n                state.addText(node['value'] as string);\n            },\n        },\n        toMarkdown: {\n            match: (node) => node.type.name === 'text',\n            runner: (state, node) => {\n                state.addNode('text', undefined, node.text as string);\n            },\n        },\n    }),\n}));\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { AtomPlugin } from '@milkdown/utils';\n\nimport { blockquote } from './blockquote';\nimport { bulletList } from './bullet-list';\nimport { codeFence } from './code-fence';\nimport { doc } from './doc';\nimport { hardbreak } from './hardbreak';\nimport { heading } from './heading';\nimport { hr } from './hr';\nimport { image } from './image';\nimport { listItem } from './list-item';\nimport { orderedList } from './ordered-list';\nimport { paragraph } from './paragraph';\nimport { text } from './text';\n\nexport const nodes: AtomPlugin[] = [\n    doc(),\n    paragraph(),\n    hardbreak(),\n    blockquote(),\n    codeFence(),\n    bulletList(),\n    orderedList(),\n    listItem(),\n    heading(),\n    hr(),\n    image(),\n    text(),\n];\n\nexport * from './blockquote';\nexport * from './bullet-list';\nexport * from './code-fence';\nexport * from './doc';\nexport * from './hardbreak';\nexport * from './heading';\nexport * from './hr';\nexport * from './image';\nexport * from './list-item';\nexport * from './ordered-list';\nexport * from './paragraph';\nexport * from './text';\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Node } from 'unist';\nimport { Parent, visit } from 'unist-util-visit';\n\nexport const addOrderInList = () => {\n    function transformer(ast: Node) {\n        visit(ast, 'list', (node: Parent & { ordered?: boolean; start?: number }) => {\n            if (node.ordered) {\n                const start = node.start ?? 1;\n                node.children.forEach((child, index) => {\n                    (child as Node & { label: number }).label = index + start;\n                });\n                return;\n            }\n        });\n    }\n\n    return transformer;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Literal, Node, Parent } from 'unist';\n\nconst isParent = (node: Node): node is Parent => !!(node as Parent).children;\nconst isHTML = (node: Node): node is Literal<string> => node.type === 'html';\n\nfunction flatMapWithDepth(ast: Node, fn: (node: Node, index: number, parent: Node | null) => Node[]) {\n    return transform(ast, 0, null)[0];\n\n    function transform(node: Node, index: number, parent: Node | null) {\n        if (isParent(node)) {\n            const out = [];\n            for (let i = 0, n = node.children.length; i < n; i++) {\n                const nthChild = node.children[i];\n                if (nthChild) {\n                    const xs = transform(nthChild, i, node);\n                    if (xs) {\n                        for (let j = 0, m = xs.length; j < m; j++) {\n                            const item = xs[j];\n                            if (item) {\n                                out.push(item);\n                            }\n                        }\n                    }\n                }\n            }\n            node.children = out;\n        }\n\n        return fn(node, index, parent);\n    }\n}\n\nexport const filterHTMLPlugin = () => {\n    function transformer(tree: Node) {\n        flatMapWithDepth(tree, (node) => {\n            if (!isHTML(node)) {\n                return [node];\n            }\n\n            return [];\n        });\n    }\n    return transformer;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Plugin, PluginKey } from '@milkdown/prose/state';\nimport { Decoration, DecorationSet } from '@milkdown/prose/view';\n\nconst inlineNodesCursorPluginKey = new PluginKey('MILKDOWN_INLINE_NODES_CURSOR');\n\n/**\n * This plugin is to solve the chrome 98 bug:\n * https://discuss.prosemirror.net/t/cursor-jumps-at-the-end-of-line-when-it-betweens-two-inline-nodes/4641\n */\nexport const getInlineNodesCursorPlugin = (): Plugin => {\n    let lock = false;\n    const inlineNodesCursorPlugin: Plugin = new Plugin({\n        key: inlineNodesCursorPluginKey,\n        state: {\n            init() {\n                return false;\n            },\n            apply(tr) {\n                if (!tr.selection.empty) {\n                    return false;\n                }\n                const pos = tr.selection.$from;\n                const left = pos.nodeBefore;\n                const right = pos.nodeAfter;\n                if (left && right && left.isInline && !left.isText && right.isInline && !right.isText) {\n                    return true;\n                }\n\n                return false;\n            },\n        },\n        props: {\n            handleDOMEvents: {\n                compositionend: (view, e) => {\n                    if (lock) {\n                        lock = false;\n                        requestAnimationFrame(() => {\n                            const active = inlineNodesCursorPlugin.getState(view.state);\n                            if (active) {\n                                const from = view.state.selection.from;\n                                e.preventDefault();\n                                view.dispatch(view.state.tr.insertText(e.data || '', from));\n                            }\n                        });\n\n                        return true;\n                    }\n                    return false;\n                },\n                compositionstart: (view) => {\n                    const active = inlineNodesCursorPlugin.getState(view.state);\n                    if (active) {\n                        lock = true;\n                    }\n                    return false;\n                },\n                beforeinput: (view, e) => {\n                    const active = inlineNodesCursorPlugin.getState(view.state);\n                    if (active && e instanceof InputEvent && e.data && !lock) {\n                        const from = view.state.selection.from;\n                        e.preventDefault();\n                        view.dispatch(view.state.tr.insertText(e.data || '', from));\n\n                        return true;\n                    }\n\n                    return false;\n                },\n            },\n            decorations(state) {\n                const active = inlineNodesCursorPlugin.getState(state);\n                if (active) {\n                    const pos = state.selection.$from;\n                    const position = pos.pos;\n                    const left = document.createElement('span');\n                    const leftDec = Decoration.widget(position, left, {\n                        side: -1,\n                    });\n                    const right = document.createElement('span');\n                    const rightDec = Decoration.widget(position, right);\n                    setTimeout(() => {\n                        left.contentEditable = 'true';\n                        right.contentEditable = 'true';\n                    });\n                    return DecorationSet.create(state.doc, [leftDec, rightDec]);\n                }\n                return DecorationSet.empty;\n            },\n        },\n    });\n\n    return inlineNodesCursorPlugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, editorViewCtx, parserCtx, serializerCtx } from '@milkdown/core';\nimport { Attrs, Node } from '@milkdown/prose/model';\nimport { EditorState, Plugin, PluginKey, TextSelection, Transaction } from '@milkdown/prose/state';\nimport { pipe } from '@milkdown/utils';\n\nconst linkRegexp = /\\[(?<span>((www|https:\\/\\/|http:\\/\\/)\\S+))]\\((?<url>\\S+)\\)/;\n\nconst holePlaceholder = '∅';\n\n// punctuation placeholder\nconst punPlaceholder = '⁂';\n// character placeholder\nconst chaPlaceholder = '∴';\n\nconst regexp = new RegExp(`\\\\\\\\(?=[^\\\\w\\\\s${holePlaceholder}\\\\\\\\]|_)`, 'g');\n\nconst keepLink = (str: string) => {\n    let text = str;\n    let match = text.match(linkRegexp);\n    while (match && match.groups) {\n        const { span } = match.groups;\n        text = text.replace(linkRegexp, span as string);\n\n        match = text.match(linkRegexp);\n    }\n    return text;\n};\n\nconst swap = (text: string, first: number, last: number) => {\n    const arr = text.split('');\n    const temp = arr[first];\n    if (arr[first] && arr[last]) {\n        arr[first] = arr[last] as string;\n        arr[last] = temp as string;\n    }\n    return arr.join('').toString();\n};\n\nconst movePlaceholder = (text: string) => {\n    const symbolsNeedToMove = ['*', '_'];\n\n    let index = text.indexOf(holePlaceholder);\n    while (symbolsNeedToMove.includes(text[index - 1] || '') && symbolsNeedToMove.includes(text[index + 1] || '')) {\n        text = swap(text, index, index + 1);\n        index = index + 1;\n    }\n\n    return text;\n};\n\nconst removeLf = (text: string) => text.slice(0, -1);\nconst replacePunctuation = (text: string) => text.replace(regexp, '');\nconst handleText = pipe(removeLf, replacePunctuation, movePlaceholder, keepLink);\n\nconst calculatePlaceholder = (text: string) => {\n    const index = text.indexOf(holePlaceholder);\n    const left = text.charAt(index - 1);\n    const right = text.charAt(index + 1);\n    const notAWord = /[^\\w]|_/;\n\n    // cursor on the right\n    if (!right) {\n        return punPlaceholder;\n    }\n\n    // cursor on the left\n    if (!left) {\n        return chaPlaceholder;\n    }\n\n    if (notAWord.test(left) && notAWord.test(right)) {\n        return punPlaceholder;\n    }\n\n    return chaPlaceholder;\n};\n\nconst getOffset = (node: Node, from: number, placeholder: string) => {\n    let offset = from;\n    let find = false;\n    node.descendants((n) => {\n        if (find) return false;\n        if (n.isText) {\n            const i = n.text?.indexOf(placeholder);\n            if (i != null && i >= 0) {\n                find = true;\n                offset += i;\n                return false;\n            }\n        }\n        offset += n.nodeSize;\n        return;\n    });\n    return offset;\n};\n\nexport const inlineSyncPluginKey = new PluginKey('MILKDOWN_INLINE_SYNC');\nexport const getInlineSyncPlugin = (ctx: Ctx) => {\n    const getContextByState = (state: EditorState) => {\n        const { selection } = state;\n        const { $from } = selection;\n\n        const node = $from.node();\n        const doc = state.schema.topNodeType.create(undefined, node);\n        const isInlineBlock = Boolean(node.type.spec.content?.includes('inline'));\n\n        const parser = ctx.get(parserCtx);\n        const serializer = ctx.get(serializerCtx);\n\n        const markdown = serializer(doc);\n\n        const text = handleText(markdown);\n        const placeholder = calculatePlaceholder(text);\n\n        const parsed = parser(text.replace(holePlaceholder, placeholder));\n        if (!parsed) return null;\n\n        const target = parsed.firstChild;\n\n        if (!target || node.type !== target.type) return null;\n\n        // @ts-expect-error hijack the node attribute\n        target.attrs = { ...node.attrs };\n\n        target.descendants((node) => {\n            const marks = node.marks;\n            const link = marks.find((mark) => mark.type.name === 'link');\n            if (link && node.text?.includes(placeholder) && link.attrs['href'].includes(placeholder)) {\n                // @ts-expect-error hijack the mark attribute\n                link.attrs['href'] = link.attrs['href'].replace(placeholder, '');\n            }\n        });\n\n        return {\n            text,\n            isInlineBlock,\n            prevNode: node,\n            nextNode: target,\n            placeholder,\n        };\n    };\n\n    const runReplacer = (state: EditorState, dispatch: (tr: Transaction) => void, attrs: Attrs) => {\n        // insert a placeholder to restore the selection\n        let tr = state.tr.setMeta(inlineSyncPluginKey, true).insertText(holePlaceholder, state.selection.from);\n\n        const nextState = state.apply(tr);\n        const context = getContextByState(nextState);\n\n        if (!context) return;\n\n        const { $from } = nextState.selection;\n        const from = $from.before();\n        const to = $from.after();\n\n        const offset = getOffset(context.nextNode, from, context.placeholder);\n\n        tr = tr\n            .replaceWith(from, to, context.nextNode)\n            .setNodeMarkup(from, undefined, attrs)\n            // delete the placeholder\n            .delete(offset + 1, offset + 2);\n\n        tr = tr.setSelection(TextSelection.near(tr.doc.resolve(offset + 1)));\n        dispatch(tr);\n    };\n\n    const inlineSyncPlugin = new Plugin<null>({\n        key: inlineSyncPluginKey,\n        state: {\n            init: () => {\n                return null;\n            },\n            apply: (tr, _value, _oldState, newState) => {\n                if (!tr.docChanged) return null;\n\n                const meta = tr.getMeta(inlineSyncPluginKey);\n                if (meta) {\n                    return null;\n                }\n\n                const context = getContextByState(newState);\n                if (!context) return null;\n\n                const { isInlineBlock, prevNode, nextNode } = context;\n\n                if (!isInlineBlock) return null;\n                if (!nextNode || prevNode.type !== nextNode.type || prevNode.eq(nextNode)) return null;\n\n                requestAnimationFrame(() => {\n                    const { dispatch, state } = ctx.get(editorViewCtx);\n\n                    runReplacer(state, dispatch, prevNode.attrs);\n                });\n\n                return null;\n            },\n        },\n    });\n\n    return inlineSyncPlugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createPlugin } from '@milkdown/utils';\nimport links from 'remark-inline-links';\n\nimport { addOrderInList } from './add-order-in-list';\nimport { filterHTMLPlugin } from './filter-html';\nimport { getInlineNodesCursorPlugin } from './inline-nodes-cursor';\nimport { getInlineSyncPlugin } from './inline-sync';\n\nexport const commonmarkPlugins = [\n    createPlugin(() => ({\n        prosePlugins: (_, ctx) => [getInlineNodesCursorPlugin(), getInlineSyncPlugin(ctx)],\n        remarkPlugins: () => [links, filterHTMLPlugin, addOrderInList],\n    }))(),\n];\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { AtomList } from '@milkdown/utils';\n\nimport { marks, ModifyLink, ToggleBold, ToggleInlineCode, ToggleItalic, ToggleLink } from './mark';\nimport {\n    InsertHardbreak,\n    InsertHr,\n    InsertImage,\n    LiftListItem,\n    ModifyImage,\n    nodes,\n    SinkListItem,\n    SplitListItem,\n    TurnIntoCodeFence,\n    TurnIntoHeading,\n    TurnIntoText,\n    WrapInBlockquote,\n    WrapInBulletList,\n    WrapInOrderedList,\n} from './node';\nimport { commonmarkPlugins } from './plugin';\n\nexport * from './mark';\nexport * from './node';\nexport * from './supported-keys';\n\nexport const commonmarkNodes = AtomList.create([...nodes, ...marks]);\nexport { commonmarkPlugins };\nexport const commonmark = AtomList.create([...commonmarkPlugins, ...commonmarkNodes]);\n\nexport const commands = {\n    ToggleInlineCode,\n    ToggleItalic,\n    ToggleLink,\n    ToggleBold,\n\n    ModifyLink,\n    ModifyImage,\n\n    WrapInBlockquote,\n    WrapInBulletList,\n    WrapInOrderedList,\n\n    TurnIntoCodeFence,\n    TurnIntoHeading,\n    TurnIntoText,\n\n    InsertHardbreak,\n    InsertHr,\n    InsertImage,\n\n    SplitListItem,\n    SinkListItem,\n    LiftListItem,\n} as const;\nexport type Commands = typeof commands;\n"],"names":["id","key"],"mappings":"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"}