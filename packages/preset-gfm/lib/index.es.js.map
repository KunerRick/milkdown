{"version":3,"file":"index.es.js","sources":["../src/footnote/utils.ts","../src/footnote/definition.ts","../src/footnote/reference.ts","../src/table/plugin/table-map.ts","../src/table/plugin/cell-selection.ts","../src/table/plugin/schema.ts","../src/table/plugin/util.ts","../src/table/command.ts","../src/table/plugin/commands.ts","../src/table/utils.ts","../src/table/operator-plugin/helper.ts","../src/table/operator-plugin/actions.ts","../src/table/operator-plugin/calc-pos.ts","../src/table/operator-plugin/constant.ts","../src/table/operator-plugin/style.ts","../src/table/operator-plugin/widget.ts","../src/table/operator-plugin/index.ts","../src/table/plugin/auto-insert-zero-space.ts","../src/table/plugin/table-view.ts","../src/table/plugin/column-resizing.ts","../src/table/plugin/copy-paste.ts","../src/table/plugin/fix-tables.ts","../src/table/plugin/table-editing.ts","../src/table/nodes/index.ts","../src/supported-keys.ts","../src/strike-through.ts","../src/task-list-item.ts","../src/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nexport const getFootnoteRefId = (label: string) => `footnote-ref-${label}`;\n\nexport const getFootnoteDefId = (label: string) => `footnote-def-${label}`;\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { commandsCtx, createCmd, createCmdKey, editorViewCtx, ThemeInputChipType } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { findSelectedNodeOfType } from '@milkdown/prose';\nimport { wrappingInputRule } from '@milkdown/prose/inputrules';\nimport { NodeSelection, Plugin, PluginKey } from '@milkdown/prose/state';\nimport { EditorView } from '@milkdown/prose/view';\nimport { createNode } from '@milkdown/utils';\n\nimport { getFootnoteDefId, getFootnoteRefId } from './utils';\n\nconst key = new PluginKey('MILKDOWN_FOOTNOTE_DEF_INPUT');\nexport const ModifyFootnoteDef = createCmdKey<string>('ModifyFootnoteDef');\n\nexport const footnoteDefinition = createNode((utils) => {\n    const id = 'footnote_definition';\n    const markdownId = 'footnoteDefinition';\n\n    return {\n        id,\n        schema: (ctx) => ({\n            group: 'block',\n            content: 'block+',\n            defining: true,\n            attrs: {\n                label: {\n                    default: '',\n                },\n            },\n            parseDOM: [\n                {\n                    tag: `div[data-type=\"${id}\"]`,\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        return {\n                            label: dom.dataset['label'],\n                        };\n                    },\n                    contentElement: 'dd',\n                },\n            ],\n            toDOM: (node) => {\n                const label = node.attrs['label'];\n                const className = utils.getClassName(node.attrs, 'footnote-definition');\n\n                const dt = document.createElement('dt');\n                dt.textContent = `[${label}]:`;\n                dt.onclick = () => {\n                    const view = ctx.get(editorViewCtx);\n                    const selection = NodeSelection.create(view.state.doc, view.state.selection.from - 2);\n                    view.dispatch(view.state.tr.setSelection(selection));\n                };\n\n                const a = document.createElement('a');\n                a.href = `#${getFootnoteRefId(label)}`;\n                a.contentEditable = 'false';\n                a.textContent = '↩';\n                a.onmousedown = (e) => {\n                    e.preventDefault();\n                };\n\n                return [\n                    'div',\n                    {\n                        class: className,\n                        'data-label': label,\n                        'data-type': id,\n                        id: getFootnoteDefId(label),\n                    },\n                    ['div', { class: 'footnote-definition_content' }, dt, ['dd', 0]],\n                    ['div', { class: 'footnote-definition_anchor' }, a],\n                ];\n            },\n            parseMarkdown: {\n                match: ({ type }) => type === markdownId,\n                runner: (state, node, type) => {\n                    state\n                        .openNode(type, {\n                            label: node['label'] as string,\n                        })\n                        .next(node.children)\n                        .closeNode();\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    state\n                        .openNode(markdownId, undefined, {\n                            label: node.attrs['label'],\n                            identifier: node.attrs['label'],\n                        })\n                        .next(node.content)\n                        .closeNode();\n                },\n            },\n        }),\n        commands: (nodeType) => [\n            createCmd(ModifyFootnoteDef, (label = '') => (state, dispatch) => {\n                const node = findSelectedNodeOfType(state.selection, nodeType);\n                if (!node) return false;\n\n                const { tr } = state;\n                const _tr = tr.setNodeMarkup(node.pos, undefined, { ...node.node.attrs, label });\n                dispatch?.(_tr.setSelection(NodeSelection.create(_tr.doc, node.pos)));\n\n                return true;\n            }),\n        ],\n        inputRules: (nodeType) => [\n            wrappingInputRule(\n                /(?:\\[\\^)([^:]+)(?::)$/,\n                nodeType,\n                (match) => {\n                    const label = match[1] ?? 'footnote';\n                    return {\n                        label,\n                    };\n                },\n                () => false,\n            ),\n        ],\n        prosePlugins: (type, ctx) => {\n            return [\n                new Plugin({\n                    key,\n                    view: (editorView) => {\n                        const inputChipRenderer = utils.themeManager.get<ThemeInputChipType>('input-chip', {\n                            width: '12em',\n                            placeholder: 'Input Footnote Label',\n                            onUpdate: (value) => {\n                                ctx.get(commandsCtx).call(ModifyFootnoteDef, value);\n                            },\n                            isBindMode: true,\n                        });\n                        if (!inputChipRenderer) return {};\n                        const shouldDisplay = (view: EditorView) =>\n                            Boolean(type && findSelectedNodeOfType(view.state.selection, type));\n                        const getCurrentLabel = (view: EditorView) => {\n                            const result = findSelectedNodeOfType(view.state.selection, type);\n                            if (!result) return;\n\n                            const value = result.node.attrs['label'];\n                            return value;\n                        };\n                        const renderByView = (view: EditorView) => {\n                            if (!view.editable) {\n                                return;\n                            }\n                            const display = shouldDisplay(view);\n                            if (display) {\n                                inputChipRenderer.show(view);\n                                inputChipRenderer.update(getCurrentLabel(view));\n                            } else {\n                                inputChipRenderer.hide();\n                            }\n                        };\n                        inputChipRenderer.init(editorView);\n                        renderByView(editorView);\n\n                        return {\n                            update: (view, prevState) => {\n                                const isEqualSelection =\n                                    prevState?.doc.eq(view.state.doc) && prevState.selection.eq(view.state.selection);\n                                if (isEqualSelection) return;\n\n                                renderByView(view);\n                            },\n                            destroy: () => {\n                                inputChipRenderer.destroy();\n                            },\n                        };\n                    },\n                }),\n            ];\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { commandsCtx, createCmd, createCmdKey, editorViewCtx, ThemeInputChipType } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { findSelectedNodeOfType } from '@milkdown/prose';\nimport { InputRule } from '@milkdown/prose/inputrules';\nimport { NodeSelection, Plugin, PluginKey } from '@milkdown/prose/state';\nimport { EditorView } from '@milkdown/prose/view';\nimport { createNode } from '@milkdown/utils';\n\nimport { getFootnoteDefId, getFootnoteRefId } from './utils';\n\nexport const ModifyFootnoteRef = createCmdKey<string>('ModifyFootnoteRef');\nconst key = new PluginKey('MILKDOWN_FOOTNOTE_REF_INPUT');\n\nexport const footnoteReference = createNode((utils) => {\n    const id = 'footnote_reference';\n\n    return {\n        id,\n        schema: (ctx) => ({\n            group: 'inline',\n            inline: true,\n            atom: true,\n            attrs: {\n                label: {\n                    default: '',\n                },\n            },\n            parseDOM: [\n                {\n                    tag: `sup[data-type=\"${id}\"]`,\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        return {\n                            label: dom.dataset['label'],\n                        };\n                    },\n                },\n            ],\n            toDOM: (node) => {\n                const label = node.attrs['label'];\n                const a = document.createElement('a');\n                const href = `#${getFootnoteDefId(label)}`;\n                a.href = href;\n                a.textContent = `[${label}]`;\n                a.onclick = (e) => {\n                    const view = ctx.get(editorViewCtx);\n                    if (view.editable) {\n                        e.preventDefault();\n                    }\n                };\n                a.ondblclick = () => {\n                    const view = ctx.get(editorViewCtx);\n                    if (view.editable) {\n                        window.location.href = href;\n                    }\n                };\n                return [\n                    'sup',\n                    {\n                        'data-label': label,\n                        'data-type': id,\n                        id: getFootnoteRefId(label),\n                    },\n                    a,\n                ];\n            },\n            parseMarkdown: {\n                match: ({ type }) => type === 'footnoteReference',\n                runner: (state, node, type) => {\n                    state.addNode(type, {\n                        label: node['label'] as string,\n                    });\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    state.addNode('footnoteReference', undefined, undefined, {\n                        label: node.attrs['label'],\n                        identifier: node.attrs['label'],\n                    });\n                },\n            },\n        }),\n        commands: (nodeType) => [\n            createCmd(ModifyFootnoteRef, (label = '') => (state, dispatch) => {\n                const node = findSelectedNodeOfType(state.selection, nodeType);\n                if (!node) return false;\n\n                const { tr } = state;\n                const _tr = tr.setNodeMarkup(node.pos, undefined, { ...node.node.attrs, label });\n                dispatch?.(_tr.setSelection(NodeSelection.create(_tr.doc, node.pos)));\n\n                return true;\n            }),\n        ],\n        inputRules: (nodeType) => [\n            new InputRule(/(?:\\[\\^)([^\\]]+)(?:\\])$/, (state, match, start, end) => {\n                const $start = state.doc.resolve(start);\n                const index = $start.index();\n                const $end = state.doc.resolve(end);\n                if (!$start.parent.canReplaceWith(index, $end.index(), nodeType)) {\n                    return null;\n                }\n                const label = match[1];\n                return state.tr.replaceRangeWith(\n                    start,\n                    end,\n                    nodeType.create({\n                        label,\n                    }),\n                );\n            }),\n        ],\n        prosePlugins: (type, ctx) => {\n            const inputChipRenderer = utils.themeManager.get<ThemeInputChipType>('input-chip', {\n                width: '12em',\n                placeholder: 'Input Footnote Label',\n                onUpdate: (value) => {\n                    ctx.get(commandsCtx).call(ModifyFootnoteRef, value);\n                },\n                isBindMode: true,\n            });\n            if (!inputChipRenderer) return [];\n            const shouldDisplay = (view: EditorView) =>\n                Boolean(type && findSelectedNodeOfType(view.state.selection, type));\n            const getCurrentLabel = (view: EditorView) => {\n                const result = findSelectedNodeOfType(view.state.selection, type);\n                if (!result) return;\n\n                const value = result.node.attrs['label'];\n                return value;\n            };\n            const renderByView = (view: EditorView) => {\n                if (!view.editable) {\n                    return;\n                }\n                const display = shouldDisplay(view);\n                if (display) {\n                    inputChipRenderer.show(view);\n                    inputChipRenderer.update(getCurrentLabel(view));\n                } else {\n                    inputChipRenderer.hide();\n                }\n            };\n            return [\n                new Plugin({\n                    key,\n                    view: (editorView) => {\n                        inputChipRenderer.init(editorView);\n                        renderByView(editorView);\n\n                        return {\n                            update: (view, prevState) => {\n                                const isEqualSelection =\n                                    prevState?.doc.eq(view.state.doc) && prevState.selection.eq(view.state.selection);\n                                if (isEqualSelection) return;\n\n                                renderByView(view);\n                            },\n                            destroy: () => {\n                                inputChipRenderer.destroy();\n                            },\n                        };\n                    },\n                }),\n            ];\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Attrs, Node } from '@milkdown/prose/model';\n\nconst cache = new WeakMap<Node, TableMap>();\nconst readFromCache = (key: Node) => cache.get(key);\nconst addToCache = (key: Node, value: TableMap) => {\n    cache.set(key, value);\n    return value;\n};\n\nexport class Rect {\n    public tableStart?: number;\n    public map?: TableMap;\n    public table?: Node;\n    constructor(public left: number, public top: number, public right: number, public bottom: number) {}\n}\n\n// ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\nexport class TableMap {\n    constructor(public width: number, public height: number, public map: number[], public problems?: Problem[]) {\n        // :: number The width of the table\n        this.width = width;\n        // :: number The table's height\n        this.height = height;\n        // :: [number] A width * height array with the start position of\n        // the cell covering that part of the table in each slot\n        this.map = map;\n        // An optional array of problems (cell overlap or non-rectangular\n        // shape) for the table, used by the table normalizer.\n        this.problems = problems;\n    }\n\n    // Find the dimensions of the cell at the given position.\n    findCell(pos: number): Rect {\n        for (let i = 0; i < this.map.length; i++) {\n            const curPos = this.map[i];\n            if (curPos != pos) continue;\n            const left = i % this.width,\n                top = (i / this.width) | 0;\n            let right = left + 1,\n                bottom = top + 1;\n            for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) right++;\n            for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) bottom++;\n            return new Rect(left, top, right, bottom);\n        }\n        throw new RangeError('No cell with offset ' + pos + ' found');\n    }\n\n    colCount(pos: number): number {\n        for (let i = 0; i < this.map.length; i++) if (this.map[i] == pos) return i % this.width;\n        throw new RangeError('No cell with offset ' + pos + ' found');\n    }\n\n    // :: (number, string, number) → ?number\n    // Find the next cell in the given direction, starting from the cell\n    // at `pos`, if any.\n    nextCell(pos: number, axis: string, dir: number): number | undefined {\n        const { left, right, top, bottom } = this.findCell(pos);\n        if (axis == 'horiz') {\n            if (dir < 0 ? left == 0 : right == this.width) return undefined;\n            return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n        } else {\n            if (dir < 0 ? top == 0 : bottom == this.height) return undefined;\n            return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n        }\n    }\n\n    // :: (number, number) → Rect\n    // Get the rectangle spanning the two given cells.\n    rectBetween(a: number, b: number): Rect {\n        const { left: leftA, right: rightA, top: topA, bottom: bottomA } = this.findCell(a);\n        const { left: leftB, right: rightB, top: topB, bottom: bottomB } = this.findCell(b);\n        return new Rect(\n            Math.min(leftA, leftB),\n            Math.min(topA, topB),\n            Math.max(rightA, rightB),\n            Math.max(bottomA, bottomB),\n        );\n    }\n\n    // :: (Rect) → [number]\n    // Return the position of all cells that have the top left corner in\n    // the given rectangle.\n    cellsInRect(rect: Rect): number[] {\n        const result: number[] = [],\n            seen: Record<number, boolean> = {};\n        for (let row = rect.top; row < rect.bottom; row++) {\n            for (let col = rect.left; col < rect.right; col++) {\n                const index = row * this.width + col,\n                    pos = this.map[index] as number;\n                if (seen[pos]) continue;\n                seen[pos] = true;\n                if (\n                    (col != rect.left || !col || this.map[index - 1] != pos) &&\n                    (row != rect.top || !row || this.map[index - this.width] != pos)\n                )\n                    result.push(pos);\n            }\n        }\n        return result;\n    }\n\n    // :: (number, number, Node) → number\n    // Return the position at which the cell at the given row and column\n    // starts, or would start, if a cell started there.\n    positionAt(row: number, col: number, table: Node): number {\n        for (let i = 0, rowStart = 0; ; i++) {\n            const rowEnd = rowStart + table.child(i).nodeSize;\n            if (i == row) {\n                let index = col + row * this.width;\n                const rowEndIndex = (row + 1) * this.width;\n                // Skip past cells from previous rows (via rowspan)\n                while (index < rowEndIndex && (this.map[index] as number) < rowStart) index++;\n                return index == rowEndIndex ? rowEnd - 1 : (this.map[index] as number);\n            }\n            rowStart = rowEnd;\n        }\n    }\n\n    // Find the table map for the given table node.\n    static get(table: Node): TableMap {\n        return readFromCache(table) || addToCache(table, computeMap(table));\n    }\n}\n\nexport type Problem =\n    | {\n          type: 'missing';\n          row: number;\n          n: number;\n      }\n    | {\n          type: 'overlong_rowspan';\n          pos: number;\n          n: number;\n      }\n    | {\n          type: 'collision';\n          row: number;\n          pos: number;\n          n: number;\n      }\n    | {\n          type: 'colwidth mismatch';\n          pos: number;\n          colwidth: boolean;\n      };\n\n// Compute a table map.\nfunction computeMap(table: Node) {\n    if (table.type.spec['tableRole'] != 'table') throw new RangeError('Not a table node: ' + table.type.name);\n    const width = findWidth(table),\n        height = table.childCount;\n    const map: number[] = [];\n    const colWidths: number[] = [];\n    let mapPos = 0,\n        problems: Problem[] | undefined = undefined;\n    for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n\n    for (let row = 0, pos = 0; row < height; row++) {\n        const rowNode = table.child(row);\n        pos++;\n        for (let i = 0; ; i++) {\n            while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n            if (i == rowNode.childCount) break;\n            const cellNode = rowNode.child(i),\n                { colspan, rowspan, colwidth } = cellNode.attrs;\n            for (let h = 0; h < rowspan; h++) {\n                if (h + row >= height) {\n                    (problems || (problems = [])).push({\n                        type: 'overlong_rowspan',\n                        pos,\n                        n: rowspan - h,\n                    });\n                    break;\n                }\n                const start = mapPos + h * width;\n                for (let w = 0; w < colspan; w++) {\n                    if (map[start + w] == 0) map[start + w] = pos;\n                    else\n                        (problems || (problems = [])).push({\n                            type: 'collision',\n                            row,\n                            pos,\n                            n: colspan - w,\n                        });\n                    const colW = colwidth && colwidth[w];\n                    if (colW) {\n                        const widthIndex = ((start + w) % width) * 2,\n                            prev = colWidths[widthIndex];\n                        if (prev == null || (prev != colW && colWidths[widthIndex + 1] == 1)) {\n                            colWidths[widthIndex] = colW;\n                            colWidths[widthIndex + 1] = 1;\n                        } else if (prev == colW) {\n                            colWidths[widthIndex + 1]++;\n                        }\n                    }\n                }\n            }\n            mapPos += colspan;\n            pos += cellNode.nodeSize;\n        }\n        const expectedPos = (row + 1) * width;\n        let missing = 0;\n        while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n        if (missing) (problems || (problems = [])).push({ type: 'missing', row, n: missing });\n        pos++;\n    }\n\n    const tableMap = new TableMap(width, height, map, problems);\n    let badWidths = false;\n\n    // For columns that have defined widths, but whose widths disagree\n    // between rows, fix up the cells whose width doesn't match the\n    // computed one.\n    for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n        if (colWidths[i] != null && (colWidths[i + 1] as number) < height) badWidths = true;\n    if (badWidths) findBadColWidths(tableMap, colWidths, table);\n\n    return tableMap;\n}\n\nfunction findWidth(table: Node) {\n    let width = -1,\n        hasRowSpan = false;\n    for (let row = 0; row < table.childCount; row++) {\n        const rowNode = table.child(row);\n        let rowWidth = 0;\n        if (hasRowSpan)\n            for (let j = 0; j < row; j++) {\n                const prevRow = table.child(j);\n                for (let i = 0; i < prevRow.childCount; i++) {\n                    const cell = prevRow.child(i);\n                    if (j + cell.attrs['rowspan'] > row) rowWidth += cell.attrs['colspan'];\n                }\n            }\n        for (let i = 0; i < rowNode.childCount; i++) {\n            const cell = rowNode.child(i);\n            rowWidth += cell.attrs['colspan'];\n            if (cell.attrs['rowspan'] > 1) hasRowSpan = true;\n        }\n        if (width == -1) width = rowWidth;\n        else if (width != rowWidth) width = Math.max(width, rowWidth);\n    }\n    return width;\n}\n\nfunction findBadColWidths(map: TableMap, colWidths: number[], table: Node) {\n    if (!map.problems) map.problems = [];\n    for (let i = 0, seen: Record<number, boolean> = {}; i < map.map.length; i++) {\n        const pos = map.map[i] as number;\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const node = table.nodeAt(pos) as Node;\n        let updated = null;\n        for (let j = 0; j < node.attrs['colspan']; j++) {\n            const col = (i + j) % map.width,\n                colWidth = colWidths[col * 2];\n            if (colWidth != null && (!node.attrs['colwidth'] || node.attrs['colwidth'][j] != colWidth))\n                (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth;\n        }\n        if (updated)\n            map.problems.unshift({\n                type: 'colwidth mismatch',\n                pos,\n                colwidth: updated,\n            });\n    }\n}\n\nfunction freshColWidth(attrs: Attrs) {\n    if (attrs['colwidth']) return attrs['colwidth'].slice();\n    const result = [];\n    for (let i = 0; i < attrs['colspan']; i++) result.push(0);\n    return result;\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Fragment, Node, ResolvedPos, Slice } from '@milkdown/prose/model';\nimport {\n    EditorState,\n    NodeSelection,\n    Selection,\n    SelectionRange,\n    TextSelection,\n    Transaction,\n} from '@milkdown/prose/state';\nimport { Mappable } from '@milkdown/prose/transform';\nimport { Decoration, DecorationSet } from '@milkdown/prose/view';\n\nimport { TableMap } from './table-map';\nimport { inSameTable, pointsAtCell, removeColSpan, setAttr } from './util';\n\n// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\nexport class CellSelection extends Selection {\n    // :: (ResolvedPos, ?ResolvedPos)\n    // A table selection is identified by its anchor and head cells. The\n    // positions given to this constructor should point _before_ two\n    // cells in the same table. They may be the same, to select a single\n    // cell.\n    constructor(public $anchorCell: ResolvedPos, public $headCell = $anchorCell) {\n        const table = $anchorCell.node(-1),\n            map = TableMap.get(table),\n            start = $anchorCell.start(-1);\n        const rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);\n        const doc = $anchorCell.node(0);\n        const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - start);\n        // Make the head cell the first range, so that it counts as the\n        // primary part of the selection\n        cells.unshift($headCell.pos - start);\n        const ranges = cells.map((pos) => {\n            const cell = table.nodeAt(pos) as Node,\n                from = pos + start + 1;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return new (SelectionRange as any)(doc.resolve(from), doc.resolve(from + cell.content.size));\n        });\n        super(ranges[0].$from, ranges[0].$to, ranges);\n        // :: ResolvedPos\n        // A resolved position pointing _in front of_ the anchor cell (the one\n        // that doesn't move when extending the selection).\n        this.$anchorCell = $anchorCell;\n        // :: ResolvedPos\n        // A resolved position pointing in front of the head cell (the one\n        // moves when extending the selection).\n        this.$headCell = $headCell;\n    }\n\n    map(doc: Node, mapping: Mappable): Selection {\n        const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n        const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n        if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n            const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n            if (tableChanged && this.isRowSelection()) return CellSelection.rowSelection($anchorCell, $headCell);\n            else if (tableChanged && this.isColSelection()) return CellSelection.colSelection($anchorCell, $headCell);\n            else return new CellSelection($anchorCell, $headCell);\n        }\n        return TextSelection.between($anchorCell, $headCell);\n    }\n\n    // :: () → Slice\n    // Returns a rectangular slice of table rows containing the selected\n    // cells.\n    override content(): Slice {\n        const table = this.$anchorCell.node(-1),\n            map = TableMap.get(table),\n            start = this.$anchorCell.start(-1);\n        const rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start);\n        const seen: Record<number, boolean> = {},\n            rows = [];\n        for (let row = rect.top; row < rect.bottom; row++) {\n            const rowContent = [];\n            for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n                const pos = map.map[index] as number;\n                if (!seen[pos]) {\n                    seen[pos] = true;\n                    const cellRect = map.findCell(pos);\n                    let cell = table.nodeAt(pos) as Node;\n                    const extraLeft = rect.left - cellRect.left,\n                        extraRight = cellRect.right - rect.right;\n                    if (extraLeft > 0 || extraRight > 0) {\n                        let attrs = cell.attrs;\n                        if (extraLeft > 0) attrs = removeColSpan(attrs, 0, extraLeft);\n                        if (extraRight > 0) attrs = removeColSpan(attrs, attrs['colspan'] - extraRight, extraRight);\n                        if (cellRect.left < rect.left) cell = cell.type.createAndFill(attrs) as Node;\n                        else cell = cell.type.create(attrs, cell.content);\n                    }\n                    if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n                        const attrs = setAttr(\n                            cell.attrs,\n                            'rowspan',\n                            Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top),\n                        );\n                        if (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs) as Node;\n                        else cell = cell.type.create(attrs, cell.content);\n                    }\n                    rowContent.push(cell);\n                }\n            }\n            rows.push(table.child(row).copy(Fragment.from(rowContent)));\n        }\n\n        const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n        return new Slice(Fragment.from(fragment), 1, 1);\n    }\n\n    override replace(tr: Transaction, content = Slice.empty) {\n        const mapFrom = tr.steps.length,\n            ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            const { $from, $to } = ranges[i] as SelectionRange,\n                mapping = tr.mapping.slice(mapFrom);\n            tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n        }\n        const sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n        if (sel) tr.setSelection(sel);\n    }\n\n    override replaceWith(tr: Transaction, node: Node) {\n        this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n    }\n\n    forEachCell(f: (node: Node, index: number) => void) {\n        const table = this.$anchorCell.node(-1),\n            map = TableMap.get(table),\n            start = this.$anchorCell.start(-1);\n        const cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start));\n        for (let i = 0; i < cells.length; i++)\n            f(table.nodeAt(cells[i] as number) as Node, start + (cells[i] as number));\n    }\n\n    // :: () → bool\n    // True if this selection goes all the way from the top to the\n    // bottom of the table.\n    isColSelection() {\n        const anchorTop = this.$anchorCell.index(-1),\n            headTop = this.$headCell.index(-1);\n        if (Math.min(anchorTop, headTop) > 0) return false;\n        const anchorBot = anchorTop + (this.$anchorCell.nodeAfter as Node).attrs['rowspan'],\n            headBot = headTop + (this.$headCell.nodeAfter as Node).attrs['rowspan'];\n        return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;\n    }\n\n    // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n    // Returns the smallest column selection that covers the given anchor\n    // and head cell.\n    static colSelection($anchorCell: ResolvedPos, $headCell = $anchorCell) {\n        const map = TableMap.get($anchorCell.node(-1)),\n            start = $anchorCell.start(-1);\n        const anchorRect = map.findCell($anchorCell.pos - start),\n            headRect = map.findCell($headCell.pos - start);\n        const doc = $anchorCell.node(0);\n        if (anchorRect.top <= headRect.top) {\n            if (anchorRect.top > 0) {\n                const left = map.map[anchorRect.left] as number;\n                $anchorCell = doc.resolve(start + left);\n            }\n            if (headRect.bottom < map.height) {\n                const pos = map.map[map.width * (map.height - 1) + headRect.right - 1] as number;\n                $headCell = doc.resolve(start + pos);\n            }\n        } else {\n            if (headRect.top > 0) {\n                const left = map.map[anchorRect.left] as number;\n                $headCell = doc.resolve(start + left);\n            }\n            if (anchorRect.bottom < map.height) {\n                const pos = map.map[map.width * (map.height - 1) + anchorRect.right - 1] as number;\n                $anchorCell = doc.resolve(start + pos);\n            }\n        }\n        return new CellSelection($anchorCell, $headCell);\n    }\n\n    // :: () → bool\n    // True if this selection goes all the way from the left to the\n    // right of the table.\n    isRowSelection() {\n        const map = TableMap.get(this.$anchorCell.node(-1)),\n            start = this.$anchorCell.start(-1);\n        const anchorLeft = map.colCount(this.$anchorCell.pos - start),\n            headLeft = map.colCount(this.$headCell.pos - start);\n        if (Math.min(anchorLeft, headLeft) > 0) return false;\n        const anchorRight = anchorLeft + (this.$anchorCell.nodeAfter as Node).attrs['colspan'],\n            headRight = headLeft + (this.$headCell.nodeAfter as Node).attrs['colspan'];\n        return Math.max(anchorRight, headRight) == map.width;\n    }\n\n    eq(other: Selection): boolean {\n        return (\n            other instanceof CellSelection &&\n            other.$anchorCell.pos == this.$anchorCell.pos &&\n            other.$headCell.pos == this.$headCell.pos\n        );\n    }\n\n    // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n    // Returns the smallest row selection that covers the given anchor\n    // and head cell.\n    static rowSelection($anchorCell: ResolvedPos, $headCell = $anchorCell) {\n        const map = TableMap.get($anchorCell.node(-1)),\n            start = $anchorCell.start(-1);\n        const anchorRect = map.findCell($anchorCell.pos - start),\n            headRect = map.findCell($headCell.pos - start);\n        const doc = $anchorCell.node(0);\n        if (anchorRect.left <= headRect.left) {\n            if (anchorRect.left > 0) {\n                const pos = map.map[anchorRect.top * map.width] as number;\n                $anchorCell = doc.resolve(start + pos);\n            }\n            if (headRect.right < map.width) {\n                const pos = map.map[map.width * (headRect.top + 1) - 1] as number;\n                $headCell = doc.resolve(start + pos);\n            }\n        } else {\n            if (headRect.left > 0) {\n                const pos = map.map[headRect.top * map.width] as number;\n                $headCell = doc.resolve(start + pos);\n            }\n            if (anchorRect.right < map.width) {\n                const pos = map.map[map.width * (anchorRect.top + 1) - 1] as number;\n\n                $anchorCell = doc.resolve(start + pos);\n            }\n        }\n        return new CellSelection($anchorCell, $headCell);\n    }\n\n    toJSON() {\n        return {\n            type: 'cell',\n            anchor: this.$anchorCell.pos,\n            head: this.$headCell.pos,\n        };\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static override fromJSON(doc: Node, json: any) {\n        return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n\n    // :: (Node, number, ?number) → CellSelection\n    static create(doc: Node, anchorCell: number, headCell = anchorCell) {\n        return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n    }\n\n    override getBookmark() {\n        return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n    }\n}\n\nCellSelection.prototype.visible = false;\n\nSelection.jsonID('cell', CellSelection);\n\nclass CellBookmark {\n    constructor(public anchor: number, public head: number) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    map(mapping: Mappable) {\n        return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc: Node): Selection {\n        const $anchorCell = doc.resolve(this.anchor),\n            $headCell = doc.resolve(this.head);\n        if (\n            $anchorCell.parent.type.spec['tableRole'] == 'row' &&\n            $headCell.parent.type.spec['tableRole'] == 'row' &&\n            $anchorCell.index() < $anchorCell.parent.childCount &&\n            $headCell.index() < $headCell.parent.childCount &&\n            inSameTable($anchorCell, $headCell)\n        )\n            return new CellSelection($anchorCell, $headCell);\n        else return Selection.near($headCell, 1);\n    }\n}\n\nexport function drawCellSelection(state: EditorState) {\n    if (!(state.selection instanceof CellSelection)) return null;\n    const cells: Decoration[] = [];\n    state.selection.forEachCell((node, pos) => {\n        cells.push(Decoration.node(pos, pos + node.nodeSize, { class: 'selectedCell' }));\n    });\n    return DecorationSet.create(state.doc, cells);\n}\n\nfunction isCellBoundarySelection({ $from, $to }: Selection) {\n    if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false; // Cheap elimination\n    let afterFrom = $from.pos,\n        beforeTo = $to.pos,\n        depth = $from.depth;\n    for (; depth >= 0; depth--, afterFrom++) if ($from.after(depth + 1) < $from.end(depth)) break;\n    for (let d = $to.depth; d >= 0; d--, beforeTo--) if ($to.before(d + 1) > $to.start(d)) break;\n    return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec['tableRole']);\n}\n\nfunction isTextSelectionAcrossCells({ $from, $to }: Selection) {\n    let fromCellBoundaryNode;\n    let toCellBoundaryNode;\n\n    for (let i = $from.depth; i > 0; i--) {\n        const node = $from.node(i);\n        if (node.type.spec['tableRole'] === 'cell' || node.type.spec['tableRole'] === 'header_cell') {\n            fromCellBoundaryNode = node;\n            break;\n        }\n    }\n\n    for (let i = $to.depth; i > 0; i--) {\n        const node = $to.node(i);\n        if (node.type.spec['tableRole'] === 'cell' || node.type.spec['tableRole'] === 'header_cell') {\n            toCellBoundaryNode = node;\n            break;\n        }\n    }\n\n    return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\n\nexport function normalizeSelection(state: EditorState, tr: Transaction | undefined, allowTableNodeSelection: boolean) {\n    const sel = (tr || state).selection,\n        doc = (tr || state).doc;\n    let normalize, role;\n    if (sel instanceof NodeSelection && (role = sel.node.type.spec['tableRole'])) {\n        if (role == 'cell' || role == 'header_cell') {\n            normalize = CellSelection.create(doc, sel.from);\n        } else if (role == 'row') {\n            const $cell = doc.resolve(sel.from + 1);\n            normalize = CellSelection.rowSelection($cell, $cell);\n        } else if (!allowTableNodeSelection) {\n            const map = TableMap.get(sel.node),\n                start = sel.from + 1;\n            const pos = map.map[map.width * map.height - 1] as number;\n            const lastCell = start + pos;\n            normalize = CellSelection.create(doc, start + 1, lastCell);\n        }\n    } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n        normalize = TextSelection.create(doc, sel.from);\n    } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n        normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n    }\n    if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n    return tr;\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Attrs, Node, NodeSpec, Schema } from '@milkdown/prose/model';\n\nimport { TableNodesOptions } from './types';\n\nfunction getCellAttrs(dom: HTMLElement, extraAttrs: Attrs) {\n    const widthAttr = dom.getAttribute('data-colwidth');\n    const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(',').map((s) => Number(s)) : null;\n    const colspan = Number(dom.getAttribute('colspan') || 1);\n    const result = {\n        colspan,\n        rowspan: Number(dom.getAttribute('rowspan') || 1),\n        colwidth: widths && widths.length == colspan ? widths : null,\n    };\n    for (const prop in extraAttrs) {\n        const getter = extraAttrs[prop].getFromDOM;\n        const value = getter && getter(dom);\n        if (value != null) result[prop as keyof typeof result] = value;\n    }\n    return result;\n}\n\nfunction setCellAttrs(node: Node, extraAttrs: Attrs) {\n    const attrs: Record<string, unknown> = {};\n    if (node.attrs['colspan'] != 1) attrs['colspan'] = node.attrs['colspan'];\n    if (node.attrs['rowspan'] != 1) attrs['rowspan'] = node.attrs['rowspan'];\n    if (node.attrs['colwidth']) attrs['data-colwidth'] = node.attrs['colwidth'].join(',');\n    for (const prop in extraAttrs) {\n        const setter = extraAttrs[prop].setDOMAttr;\n        if (setter) setter(node.attrs[prop], attrs);\n    }\n    return attrs;\n}\n\nfunction tableNodesSpecCreator(options: TableNodesOptions) {\n    const extraAttrs: Attrs = options.cellAttributes || {};\n    const cellAttrs: Record<string, unknown> = {\n        colspan: { default: 1 },\n        rowspan: { default: 1 },\n        colwidth: { default: null },\n    };\n    for (const prop in extraAttrs) cellAttrs[prop] = { default: extraAttrs[prop].default };\n    const finalAttrs = cellAttrs as Attrs;\n\n    const schema: Record<'table' | 'table_row' | 'table_cell' | 'table_header', NodeSpec> = {\n        table: {\n            content: 'table_row+',\n            tableRole: 'table',\n            isolating: true,\n            group: options.tableGroup,\n            parseDOM: [{ tag: 'table' }],\n            toDOM() {\n                return ['table', ['tbody', 0]];\n            },\n        },\n        table_row: {\n            content: '(table_cell | table_header)*',\n            tableRole: 'row',\n            parseDOM: [{ tag: 'tr' }],\n            toDOM() {\n                return ['tr', 0];\n            },\n        },\n        table_cell: {\n            content: options.cellContent,\n            attrs: finalAttrs,\n            tableRole: 'cell',\n            isolating: true,\n            parseDOM: [{ tag: 'td', getAttrs: (dom) => getCellAttrs(dom as HTMLElement, extraAttrs) }],\n            toDOM(node) {\n                return ['td', setCellAttrs(node, extraAttrs), 0];\n            },\n        },\n        table_header: {\n            content: options.cellContent,\n            attrs: finalAttrs,\n            tableRole: 'header_cell',\n            isolating: true,\n            parseDOM: [{ tag: 'th', getAttrs: (dom) => getCellAttrs(dom as HTMLElement, extraAttrs) }],\n            toDOM(node) {\n                return ['th', setCellAttrs(node, extraAttrs), 0];\n            },\n        },\n    };\n\n    return schema;\n}\n\nexport function tableNodeTypes(schema: Schema) {\n    let result = schema.cached['tableNodeTypes'];\n    if (!result) {\n        result = schema.cached['tableNodeTypes'] = {};\n        for (const name in schema.nodes) {\n            const type = schema.nodes[name],\n                role = type?.spec['tableRole'];\n            if (role) result[role] = type;\n        }\n    }\n    return result;\n}\n\nexport const schema = tableNodesSpecCreator({\n    tableGroup: 'block',\n    cellContent: 'paragraph',\n    cellAttributes: {\n        alignment: {\n            default: 'left',\n            getFromDOM: (dom) => (dom as HTMLElement).style.textAlign || 'left',\n            setDOMAttr: (value, attrs) => {\n                attrs['style'] = `text-align: ${value || 'left'}`;\n            },\n        },\n    },\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Attrs, Node, ResolvedPos } from '@milkdown/prose/model';\nimport { EditorState, NodeSelection } from '@milkdown/prose/state';\n\nimport { CellSelection } from './cell-selection';\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './table-map';\n\nexport function cellAround($pos: ResolvedPos) {\n    for (let d = $pos.depth - 1; d > 0; d--)\n        if ($pos.node(d).type.spec['tableRole'] == 'row') return $pos.node(0).resolve($pos.before(d + 1));\n    return undefined;\n}\n\nexport function cellWrapping($pos: ResolvedPos) {\n    for (let d = $pos.depth; d > 0; d--) {\n        // Sometimes the cell can be in the same depth.\n        const role = $pos.node(d).type.spec['tableRole'];\n        if (role === 'cell' || role === 'header_cell') return $pos.node(d);\n    }\n    return null;\n}\n\nexport function pointsAtCell($pos: ResolvedPos): Node | null {\n    if ($pos.parent.type.spec['tableRole'] == 'row') return $pos.nodeAfter;\n    return null;\n}\n\nexport function moveCellForward($pos: ResolvedPos) {\n    return $pos.node(0).resolve($pos.pos + ($pos.nodeAfter as Node).nodeSize);\n}\n\nexport function inSameTable($a: ResolvedPos, $b: ResolvedPos) {\n    return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);\n}\n\nexport function nextCell($pos: ResolvedPos, axis: string, dir: number) {\n    const start = $pos.start(-1),\n        map = TableMap.get($pos.node(-1));\n    const moved = map.nextCell($pos.pos - start, axis, dir);\n    return moved == null ? null : $pos.node(0).resolve(start + moved);\n}\n\nexport function setAttr<T>(attrs: Attrs, name: string, value: T) {\n    const result: Record<string, unknown> = {};\n    for (const prop in attrs) result[prop] = attrs[prop];\n    result[name] = value;\n    return result as Attrs;\n}\n\nexport function removeColSpan(attrs: Attrs, pos: number, n = 1) {\n    const result = setAttr(attrs, 'colspan', attrs['colspan'] - n) as Record<string, unknown>;\n    if (result['colwidth']) {\n        const widths = result['colwidth'] as number[];\n        result['colwidth'] = widths.slice();\n        widths.splice(pos, n);\n        if (!widths.some((w) => w > 0)) result['colwidth'] = null;\n    }\n    return result;\n}\n\nexport function isInTable(state: EditorState) {\n    const $head = state.selection.$head;\n    for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec['tableRole'] == 'row') return true;\n    return false;\n}\n\nexport function selectionCell(state: EditorState) {\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n        return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n    } else if ((sel as NodeSelection).node && (sel as NodeSelection).node.type.spec['tableRole'] == 'cell') {\n        return sel.$anchor;\n    }\n    return cellAround(sel.$head) || cellNear(sel.$head);\n}\n\nfunction cellNear($pos: ResolvedPos) {\n    for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n        const role = after.type.spec['tableRole'];\n        if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos);\n    }\n    for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n        const role = before.type.spec['tableRole'];\n        if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos - before.nodeSize);\n    }\n    return;\n}\n\nexport function addColSpan(attrs: Attrs, pos: number, n = 1) {\n    const result = setAttr(attrs, 'colspan', attrs['colspan'] + n) as Record<string, unknown>;\n    if (result['colwidth']) {\n        const widths = result['colwidth'] as number[];\n        result['colwidth'] = widths.slice();\n        for (let i = 0; i < n; i++) widths.splice(pos, 0, 0);\n    }\n    return result as Attrs;\n}\n\nexport function columnIsHeader(map: TableMap, table: Node, col: number) {\n    const headerCell = tableNodeTypes(table.type.schema).header_cell;\n    for (let row = 0; row < map.height; row++) {\n        const pos = map.map[col + row * map.width] as number;\n        if ((table.nodeAt(pos) as Node).type != headerCell) return false;\n    }\n    return true;\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Node, NodeType } from '@milkdown/prose/model';\nimport { Command, Selection } from '@milkdown/prose/state';\n\nimport { isInTable } from './plugin/util';\n\nexport const exitTable =\n    (node: NodeType): Command =>\n    (state, dispatch) => {\n        if (!isInTable(state)) {\n            return false;\n        }\n        const { $head } = state.selection;\n        const pos = $head.after();\n        const tr = state.tr.replaceWith(pos, pos, node.createAndFill() as Node);\n        tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n        dispatch?.(tr.scrollIntoView());\n        return true;\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Fragment, Node, NodeSpec, NodeType, ResolvedPos } from '@milkdown/prose/model';\nimport { Command, EditorState, TextSelection, Transaction } from '@milkdown/prose/state';\n\nimport { CellSelection } from './cell-selection';\nimport { tableNodeTypes } from './schema';\nimport { Rect, TableMap } from './table-map';\nimport {\n    addColSpan,\n    cellAround,\n    cellWrapping,\n    columnIsHeader,\n    isInTable,\n    moveCellForward,\n    removeColSpan,\n    selectionCell,\n    setAttr,\n} from './util';\n\n// Helper to get the selected rectangle in a table, if any. Adds table\n// map, table node, and table start offset to the object for\n// convenience.\nexport function selectedRect(state: EditorState): Required<Rect> {\n    const sel = state.selection,\n        $pos = selectionCell(state) as ResolvedPos;\n    const table = $pos.node(-1),\n        tableStart = $pos.start(-1),\n        map = TableMap.get(table);\n    let rect;\n    if (sel instanceof CellSelection)\n        rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart);\n    else rect = map.findCell($pos.pos - tableStart);\n    rect.tableStart = tableStart;\n    rect.map = map;\n    rect.table = table;\n    return rect as Required<Rect>;\n}\n\n// Add a column at the given position in a table.\nexport function addColumn(tr: Transaction, { map, tableStart, table }: Rect, col: number) {\n    map = map as TableMap;\n    table = table as Node;\n    tableStart = tableStart as number;\n    let refColumn: number | null = col > 0 ? -1 : 0;\n    if (columnIsHeader(map, table, col + refColumn)) refColumn = col == 0 || col == map.width ? null : 0;\n\n    for (let row = 0; row < map.height; row++) {\n        const index = row * map.width + col;\n        // If this position falls inside a col-spanning cell\n        if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n            const pos = map.map[index] as number,\n                cell = table.nodeAt(pos) as Node;\n            tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos)));\n            // Skip ahead if rowspan > 1\n            row += cell.attrs['rowspan'] - 1;\n        } else {\n            const offset = map.map[index + (refColumn as number)] as number;\n            const type =\n                refColumn == null ? tableNodeTypes(table.type.schema).cell : (table.nodeAt(offset) as Node).type;\n            const pos = map.positionAt(row, col, table);\n            tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n        }\n    }\n    return tr;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\nexport const addColumnBefore: Command = (state, dispatch) => {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        dispatch(addColumn(state.tr, rect, rect.left));\n    }\n    return true;\n};\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\nexport const addColumnAfter: Command = (state, dispatch) => {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        dispatch(addColumn(state.tr, rect, rect.right));\n    }\n    return true;\n};\n\nexport function removeColumn(tr: Transaction, { map, table, tableStart }: Rect, col: number) {\n    map = map as TableMap;\n    table = table as Node;\n    tableStart = tableStart as number;\n    const mapStart = tr.mapping.maps.length;\n    for (let row = 0; row < map.height; ) {\n        const index = row * map.width + col,\n            pos = map.map[index] as number,\n            cell = table.nodeAt(pos) as Node;\n        // If this is part of a col-spanning cell\n        if ((col > 0 && map.map[index - 1] == pos) || (col < map.width - 1 && map.map[index + 1] == pos)) {\n            tr.setNodeMarkup(\n                tr.mapping.slice(mapStart).map(tableStart + pos),\n                null,\n                removeColSpan(cell.attrs, col - map.colCount(pos)),\n            );\n        } else {\n            const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n            tr.delete(start, start + cell.nodeSize);\n        }\n        row += cell.attrs['rowspan'];\n    }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\nexport const deleteColumn: Command = (state, dispatch) => {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state) as Required<Rect>,\n            tr = state.tr;\n        if (rect.left == 0 && rect.right == rect.map.width) return false;\n        for (let i = rect.right - 1; ; i--) {\n            removeColumn(tr, rect, i);\n            if (i == rect.left) break;\n            rect.table = (rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc) as Node;\n            rect.map = TableMap.get(rect.table);\n        }\n        dispatch(tr);\n    }\n    return true;\n};\n\nexport function rowIsHeader(map: TableMap, table: Node, row: number) {\n    const headerCell = tableNodeTypes(table.type.schema).header_cell;\n    for (let col = 0; col < map.width; col++) {\n        const offset = map.map[col + row * map.width] as number;\n        if ((table.nodeAt(offset) as Node).type != headerCell) return false;\n    }\n    return true;\n}\n\nexport function addRow(tr: Transaction, { map, tableStart, table }: Rect, row: number) {\n    map = map as TableMap;\n    table = table as Node;\n    tableStart = tableStart as number;\n    let rowPos = tableStart;\n    for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n    const cells = [];\n    let refRow: number | null = row > 0 ? -1 : 0;\n    if (rowIsHeader(map, table, row + refRow)) refRow = row == 0 || row == map.height ? null : 0;\n    for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n        // Covered by a rowspan cell\n        if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n            const pos = map.map[index] as number,\n                attrs = (table.nodeAt(pos) as Node).attrs;\n            tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, 'rowspan', attrs['rowspan'] + 1));\n            col += attrs['colspan'] - 1;\n        } else {\n            const type =\n                refRow == null\n                    ? tableNodeTypes(table.type.schema).cell\n                    : (table.nodeAt(map.map[index + refRow * map.width] as number) as Node).type;\n            cells.push(type.createAndFill());\n        }\n    }\n    tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n    return tr;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\nexport function addRowBefore(state: EditorState, dispatch?: (tr: Transaction) => boolean) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        dispatch(addRow(state.tr, rect, rect.top));\n    }\n    return true;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\nexport function addRowAfter(state: EditorState, dispatch?: (tr: Transaction) => boolean) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        dispatch(addRow(state.tr, rect, rect.bottom));\n    }\n    return true;\n}\n\nexport function removeRow(tr: Transaction, { map, tableStart, table }: Rect, row: number) {\n    map = map as TableMap;\n    table = table as Node;\n    tableStart = tableStart as number;\n    let rowPos = 0;\n    for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n    const nextRow = rowPos + table.child(row).nodeSize;\n\n    const mapFrom = tr.mapping.maps.length;\n    tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n    for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n        const pos = map.map[index] as number;\n        if (row > 0 && pos == map.map[index - map.width]) {\n            // If this cell starts in the row above, simply reduce its rowspan\n            const attrs = (table.nodeAt(pos) as Node).attrs;\n            tr.setNodeMarkup(\n                tr.mapping.slice(mapFrom).map(pos + tableStart),\n                null,\n                setAttr(attrs, 'rowspan', attrs['rowspan'] - 1),\n            );\n            col += attrs['colspan'] - 1;\n        } else if (row < map.width && pos == map.map[index + map.width]) {\n            // Else, if it continues in the row below, it has to be moved down\n            const cell = table.nodeAt(pos) as Node;\n            const copy = cell.type.create(setAttr(cell.attrs, 'rowspan', cell.attrs['rowspan'] - 1), cell.content);\n            const newPos = map.positionAt(row + 1, col, table);\n            tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n            col += cell.attrs['colspan'] - 1;\n        }\n    }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\nexport const deleteRow: Command = (state, dispatch) => {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state) as Required<Rect>,\n            tr = state.tr;\n        if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n        for (let i = rect.bottom - 1; ; i--) {\n            removeRow(tr, rect, i);\n            if (i == rect.top) break;\n            rect.table = rect.tableStart ? (tr.doc.nodeAt(rect.tableStart - 1) as Node) : tr.doc;\n            rect.map = TableMap.get(rect.table);\n        }\n        dispatch(tr);\n    }\n    return true;\n};\n\nfunction isEmpty(cell: Node) {\n    const c = cell.content;\n    return c.childCount == 1 && (c.firstChild as Node).isTextblock && (c.firstChild as Node).childCount == 0;\n}\n\nfunction cellsOverlapRectangle({ width, height, map }: TableMap, rect: Rect) {\n    let indexTop = rect.top * width + rect.left,\n        indexLeft = indexTop;\n    let indexBottom = (rect.bottom - 1) * width + rect.left,\n        indexRight = indexTop + (rect.right - rect.left - 1);\n    for (let i = rect.top; i < rect.bottom; i++) {\n        if (\n            (rect.left > 0 && map[indexLeft] == map[indexLeft - 1]) ||\n            (rect.right < width && map[indexRight] == map[indexRight + 1])\n        )\n            return true;\n        indexLeft += width;\n        indexRight += width;\n    }\n    for (let i = rect.left; i < rect.right; i++) {\n        if (\n            (rect.top > 0 && map[indexTop] == map[indexTop - width]) ||\n            (rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n        )\n            return true;\n        indexTop++;\n        indexBottom++;\n    }\n    return false;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\nexport function mergeCells(state: EditorState, dispatch?: (tr: Transaction) => boolean) {\n    const sel = state.selection;\n    if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;\n    const rect = selectedRect(state) as Required<Rect>,\n        { map } = rect;\n    if (cellsOverlapRectangle(map as TableMap, rect)) return false;\n    if (dispatch) {\n        const tr = state.tr,\n            seen: Record<number, boolean> = {};\n        let content = Fragment.empty,\n            mergedPos,\n            mergedCell;\n        for (let row = rect.top; row < rect.bottom; row++) {\n            for (let col = rect.left; col < rect.right; col++) {\n                const cellPos = map.map[row * map.width + col] as number,\n                    cell = rect.table.nodeAt(cellPos) as Node;\n                if (seen[cellPos]) continue;\n                seen[cellPos] = true;\n                if (mergedPos == null) {\n                    mergedPos = cellPos;\n                    mergedCell = cell;\n                } else {\n                    if (!isEmpty(cell)) content = content.append(cell.content);\n                    const mapped = tr.mapping.map(cellPos + rect.tableStart);\n                    tr.delete(mapped, mapped + cell.nodeSize);\n                }\n            }\n        }\n        mergedCell = mergedCell as Node;\n        mergedPos = mergedPos as number;\n        tr.setNodeMarkup(\n            mergedPos + rect.tableStart,\n            null,\n            setAttr(\n                addColSpan(\n                    mergedCell.attrs,\n                    mergedCell.attrs['colspan'],\n                    rect.right - rect.left - mergedCell.attrs['colspan'],\n                ),\n                'rowspan',\n                rect.bottom - rect.top,\n            ),\n        );\n        if (content.size) {\n            const end = mergedPos + 1 + mergedCell.content.size;\n            const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n            tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n        }\n        tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n        dispatch(tr);\n    }\n    return true;\n}\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\nexport function splitCell(state: EditorState, dispatch?: (tr: Transaction) => boolean) {\n    const nodeTypes = tableNodeTypes(state.schema);\n    return splitCellWithType(({ node }) => {\n        return nodeTypes[node.type.spec['tableRole']];\n    })(state, dispatch);\n}\n\n// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\nexport function splitCellWithType(getCellType: (pos: { row: number; col: number; node: Node }) => NodeType) {\n    return (state: EditorState, dispatch?: (tr: Transaction) => boolean) => {\n        const sel = state.selection;\n        let cellNode, cellPos;\n        if (!(sel instanceof CellSelection)) {\n            cellNode = cellWrapping(sel.$from);\n            if (!cellNode) return false;\n            cellPos = (cellAround(sel.$from) as ResolvedPos).pos;\n        } else {\n            if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n            cellNode = sel.$anchorCell.nodeAfter as Node;\n            cellPos = sel.$anchorCell.pos;\n        }\n        if (cellNode.attrs['colspan'] == 1 && cellNode.attrs['rowspan'] == 1) {\n            return false;\n        }\n        if (dispatch) {\n            let baseAttrs = cellNode.attrs;\n            const attrs = [],\n                colwidth = baseAttrs['colwidth'];\n            if (baseAttrs['rowspan'] > 1) baseAttrs = setAttr(baseAttrs, 'rowspan', 1);\n            if (baseAttrs['colspan'] > 1) baseAttrs = setAttr(baseAttrs, 'colspan', 1);\n            const rect = selectedRect(state) as Required<Rect>,\n                tr = state.tr;\n            for (let i = 0; i < rect.right - rect.left; i++)\n                attrs.push(\n                    colwidth\n                        ? setAttr(baseAttrs, 'colwidth', colwidth && colwidth[i] ? [colwidth[i]] : null)\n                        : baseAttrs,\n                );\n            let lastCell;\n            for (let row = rect.top; row < rect.bottom; row++) {\n                let pos = rect.map.positionAt(row, rect.left, rect.table);\n                if (row == rect.top) pos += cellNode.nodeSize;\n                for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n                    if (col == rect.left && row == rect.top) continue;\n                    tr.insert(\n                        (lastCell = tr.mapping.map(pos + rect.tableStart, 1)),\n                        getCellType({ node: cellNode, row, col }).createAndFill(attrs[i]) as Node,\n                    );\n                }\n            }\n            tr.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left }), attrs[0]);\n            if (sel instanceof CellSelection) {\n                let pos: ResolvedPos | undefined = undefined;\n                if (lastCell) {\n                    pos = tr.doc.resolve(lastCell);\n                }\n                tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), pos));\n            }\n            dispatch(tr);\n        }\n        return true;\n    };\n}\n\n// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\nexport function setCellAttr<T>(name: string, value: T): Command {\n    return (state, dispatch) => {\n        if (!isInTable(state)) return false;\n        const $cell = selectionCell(state) as ResolvedPos;\n        if (($cell.nodeAfter as Node).attrs[name] === value) return false;\n        if (dispatch) {\n            const tr = state.tr;\n            if (state.selection instanceof CellSelection)\n                state.selection.forEachCell((node, pos) => {\n                    if (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value));\n                });\n            else tr.setNodeMarkup($cell.pos, null, setAttr(($cell.nodeAfter as Node).attrs, name, value));\n            dispatch(tr);\n        }\n        return true;\n    };\n}\n\nfunction isHeaderEnabledByType(type: string, rect: Required<Rect>, types: Record<string, NodeSpec>) {\n    // Get cell positions for first row or first column\n    const cellPositions = rect.map.cellsInRect({\n        left: 0,\n        top: 0,\n        right: type == 'row' ? rect.map.width : 1,\n        bottom: type == 'column' ? rect.map.height : 1,\n    });\n\n    for (let i = 0; i < cellPositions.length; i++) {\n        const cell = rect.table.nodeAt(cellPositions[i] as number);\n        if (cell && cell.type !== types['header_cell']) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\nexport function toggleHeader(type: string) {\n    return function (state: EditorState, dispatch?: (tr: Transaction) => boolean) {\n        if (!isInTable(state)) return false;\n        if (dispatch) {\n            const types = tableNodeTypes(state.schema);\n            const rect = selectedRect(state),\n                tr = state.tr;\n\n            const isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);\n            const isHeaderColumnEnabled = isHeaderEnabledByType('column', rect, types);\n\n            const isHeaderEnabled =\n                type === 'column' ? isHeaderRowEnabled : type === 'row' ? isHeaderColumnEnabled : false;\n\n            const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n\n            const cellsRect =\n                type == 'column'\n                    ? new Rect(0, selectionStartsAt, 1, rect.map.height)\n                    : type == 'row'\n                    ? new Rect(selectionStartsAt, 0, rect.map.width, 1)\n                    : rect;\n\n            const newType =\n                type == 'column'\n                    ? isHeaderColumnEnabled\n                        ? types.cell\n                        : types.header_cell\n                    : type == 'row'\n                    ? isHeaderRowEnabled\n                        ? types.cell\n                        : types.header_cell\n                    : types.cell;\n\n            rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n                const cellPos = relativeCellPos + rect.tableStart;\n                const cell = tr.doc.nodeAt(cellPos);\n\n                if (cell) {\n                    tr.setNodeMarkup(cellPos, newType, cell.attrs);\n                }\n            });\n\n            dispatch(tr);\n        }\n        return true;\n    };\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\nexport const toggleHeaderRow = toggleHeader('row');\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\nexport const toggleHeaderColumn = toggleHeader('column');\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\nexport const toggleHeaderCell = toggleHeader('cell');\n\nfunction findNextCell($cell: ResolvedPos, dir: number) {\n    if (dir < 0) {\n        const before = $cell.nodeBefore;\n        if (before) return $cell.pos - before.nodeSize;\n        for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n            const rowNode = $cell.node(-1).child(row);\n            if (rowNode.childCount) return rowEnd - 1 - (rowNode.lastChild as Node).nodeSize;\n            rowEnd -= rowNode.nodeSize;\n        }\n    } else {\n        if ($cell.index() < $cell.parent.childCount - 1) return $cell.pos + ($cell.nodeAfter as Node).nodeSize;\n        const table = $cell.node(-1);\n        for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n            const rowNode = table.child(row);\n            if (rowNode.childCount) return rowStart + 1;\n            rowStart += rowNode.nodeSize;\n        }\n    }\n    return;\n}\n\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\nexport function goToNextCell(direction: number): Command {\n    return (state, dispatch) => {\n        if (!isInTable(state)) return false;\n        const cell = findNextCell(selectionCell(state) as ResolvedPos, direction);\n        if (cell == null) return false;\n        if (dispatch) {\n            const $cell = state.doc.resolve(cell);\n            dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());\n        }\n        return true;\n    };\n}\n\n// Deletes the table around the selection, if any.\nexport const deleteTable: Command = (state, dispatch) => {\n    const $pos = state.selection.$anchor;\n    for (let d = $pos.depth; d > 0; d--) {\n        const node = $pos.node(d);\n        if (node.type.spec['tableRole'] == 'table') {\n            if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n            return true;\n        }\n    }\n    return false;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { cloneTr, findParentNode } from '@milkdown/prose';\nimport { Node as ProsemirrorNode, Schema } from '@milkdown/prose/model';\nimport { Selection, Transaction } from '@milkdown/prose/state';\n\nimport { CellSelection } from './plugin/cell-selection';\nimport { tableNodeTypes } from './plugin/schema';\nimport { Rect, TableMap } from './plugin/table-map';\n\nexport type CellPos = {\n    pos: number;\n    start: number;\n    node: ProsemirrorNode;\n};\n\nexport const findTable = (selection: Selection) =>\n    findParentNode((node) => node.type.spec['tableRole'] === 'table')(selection);\n\nexport const getCellsInColumn =\n    (columnIndex: number) =>\n    (selection: Selection): CellPos[] | undefined => {\n        const table = findTable(selection);\n        if (!table) return undefined;\n        const map = TableMap.get(table.node);\n        if (columnIndex < 0 || columnIndex >= map.width) {\n            return undefined;\n        }\n\n        return map\n            .cellsInRect({ left: columnIndex, right: columnIndex + 1, top: 0, bottom: map.height })\n            .map((pos) => {\n                const node = table.node.nodeAt(pos);\n                if (!node) return;\n                const start = pos + table.start;\n                return {\n                    pos: start,\n                    start: start + 1,\n                    node,\n                };\n            })\n            .filter((x): x is CellPos => x != null);\n    };\n\nexport const getCellsInRow =\n    (rowIndex: number) =>\n    (selection: Selection): CellPos[] | undefined => {\n        const table = findTable(selection);\n        if (!table) return undefined;\n        const map = TableMap.get(table.node);\n        if (rowIndex < 0 || rowIndex >= map.height) {\n            return undefined;\n        }\n\n        return map\n            .cellsInRect({ left: 0, right: map.width, top: rowIndex, bottom: rowIndex + 1 })\n            .map((pos) => {\n                const node = table.node.nodeAt(pos);\n                if (!node) return;\n                const start = pos + table.start;\n                return {\n                    pos: start,\n                    start: start + 1,\n                    node,\n                };\n            })\n            .filter((x): x is CellPos => x != null);\n    };\n\nexport const createTable = (schema: Schema, rowsCount = 3, colsCount = 3) => {\n    const { cell: tableCell, header_cell: tableHeader, row: tableRow, table } = tableNodeTypes(schema);\n\n    const cells = Array(colsCount)\n        .fill(0)\n        .map(() => tableCell.createAndFill(null) as ProsemirrorNode);\n\n    const headerCells = Array(colsCount)\n        .fill(0)\n        .map(() => tableHeader.createAndFill(null) as ProsemirrorNode);\n\n    const rows = Array(rowsCount)\n        .fill(0)\n        .map((_, i) => tableRow.create(null, i === 0 ? headerCells : cells));\n\n    return table.create(null, rows);\n};\n\nexport const selectLine = (type: 'row' | 'col') => (index: number) => (tr: Transaction) => {\n    const table = findTable(tr.selection);\n    const isRowSelection = type === 'row';\n    if (table) {\n        const map = TableMap.get(table.node);\n\n        // Check if the index is valid\n        if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n            const lastCell = map.positionAt(\n                isRowSelection ? index : map.height - 1,\n                isRowSelection ? map.width - 1 : index,\n                table.node,\n            );\n            const $lastCell = tr.doc.resolve(table.start + lastCell);\n\n            const createCellSelection = isRowSelection ? CellSelection.rowSelection : CellSelection.colSelection;\n\n            const firstCell = map.positionAt(isRowSelection ? index : 0, isRowSelection ? 0 : index, table.node);\n            const $firstCell = tr.doc.resolve(table.start + firstCell);\n            return cloneTr(tr.setSelection(createCellSelection($lastCell, $firstCell) as unknown as Selection));\n        }\n    }\n    return tr;\n};\n\nexport const getCellsInTable = (selection: Selection) => {\n    const table = findTable(selection);\n    if (!table) {\n        return;\n    }\n    const map = TableMap.get(table.node);\n    const cells = map.cellsInRect({\n        left: 0,\n        right: map.width,\n        top: 0,\n        bottom: map.height,\n    });\n    return cells.map((nodePos) => {\n        const node = table.node.nodeAt(nodePos);\n        const pos = nodePos + table.start;\n        return { pos, start: pos + 1, node };\n    });\n};\n\nexport const selectTable = (tr: Transaction) => {\n    const cells = getCellsInTable(tr.selection);\n    if (cells && cells[0]) {\n        const $firstCell = tr.doc.resolve(cells[0].pos);\n        const last = cells[cells.length - 1];\n        if (last) {\n            const $lastCell = tr.doc.resolve(last.pos);\n            return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell) as unknown as Selection));\n        }\n    }\n    return tr;\n};\n\nexport function addRowWithAlignment(tr: Transaction, { map, tableStart, table }: Required<Rect>, row: number) {\n    const rowPos = Array(row)\n        .fill(0)\n        .reduce((acc, _, i) => {\n            return acc + table.child(i).nodeSize;\n        }, tableStart);\n\n    const { cell: cellType, row: rowType } = tableNodeTypes(table.type.schema);\n\n    const cells = Array(map.width)\n        .fill(0)\n        .map((_, col) => {\n            const headerCol = table.nodeAt(map.map[col] as number);\n            return cellType.createAndFill({ alignment: headerCol?.attrs['alignment'] }) as ProsemirrorNode;\n        });\n\n    tr.insert(rowPos, rowType.create(null, cells));\n    return tr;\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { EditorView } from '@milkdown/prose/view';\n\nimport { CellSelection } from '../plugin';\nimport { TableMap } from '../plugin/table-map';\nimport { Item } from './actions';\n\nexport const getCellSelection = (view: EditorView): CellSelection => view.state.selection as unknown as CellSelection;\n\nexport const isFirstRowSelected = (selection: CellSelection) => {\n    const map = TableMap.get(selection.$anchorCell.node(-1));\n    const start = selection.$anchorCell.start(-1);\n    const cells = map.cellsInRect({\n        left: 0,\n        right: map.width,\n        top: 0,\n        bottom: 1,\n    });\n    const selectedCells = map.cellsInRect(\n        map.rectBetween(selection.$anchorCell.pos - start, selection.$headCell.pos - start),\n    );\n\n    for (let i = 0, count = cells.length; i < count; i++) {\n        if (selectedCells.indexOf(cells[i] as number) === -1) {\n            return false;\n        }\n    }\n    return true;\n};\n\nexport const calculateItem = (actions: Record<string, Item>, view: EditorView) => {\n    Object.values(actions).forEach((item) => {\n        const disable = item.disable?.(view);\n        if (disable) {\n            item.$.classList.add('hide');\n            return;\n        }\n        item.$.classList.remove('hide');\n    });\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, ThemeIcon, themeManagerCtx } from '@milkdown/core';\nimport { Command } from '@milkdown/prose/state';\nimport { EditorView } from '@milkdown/prose/view';\n\nimport {\n    addColumnAfter,\n    addColumnBefore,\n    deleteColumn,\n    deleteRow,\n    deleteTable,\n    isInTable,\n    selectedRect,\n    setCellAttr,\n} from '../plugin';\nimport { addRowWithAlignment } from '../utils';\nimport { getCellSelection, isFirstRowSelected } from './helper';\n\nexport type Item = {\n    $: HTMLElement;\n    command: (e: Event, view: EditorView) => Command;\n    disable?: (view: EditorView) => boolean;\n};\n\nexport enum Action {\n    AddColLeft,\n    AddColRight,\n    AddRowTop,\n    AddRowBottom,\n    AlignLeft,\n    AlignCenter,\n    AlignRight,\n    Delete,\n}\n\nexport const createActions: (ctx: Ctx) => Record<Action, Item> = (ctx) => ({\n    [Action.AddColLeft]: {\n        $: ctx.get(themeManagerCtx).get(ThemeIcon, 'leftArrow')?.dom as HTMLElement,\n        command: () => addColumnBefore,\n        disable: (view) => !getCellSelection(view).isColSelection(),\n    },\n    [Action.AddColRight]: {\n        $: ctx.get(themeManagerCtx).get(ThemeIcon, 'rightArrow')?.dom as HTMLElement,\n        command: () => addColumnAfter,\n        disable: (view) => !getCellSelection(view).isColSelection(),\n    },\n    [Action.AddRowTop]: {\n        $: ctx.get(themeManagerCtx).get(ThemeIcon, 'upArrow')?.dom as HTMLElement,\n        command: () => (state, dispatch) => {\n            if (!isInTable(state)) return false;\n            if (dispatch) {\n                const rect = selectedRect(state);\n                dispatch(addRowWithAlignment(state.tr, rect, rect.top));\n            }\n            return true;\n        },\n        disable: (view) =>\n            !getCellSelection(view).isRowSelection() ||\n            getCellSelection(view).$head.parent.type.name === 'table_header',\n    },\n    [Action.AddRowBottom]: {\n        $: ctx.get(themeManagerCtx).get(ThemeIcon, 'downArrow')?.dom as HTMLElement,\n        command: () => (state, dispatch) => {\n            if (!isInTable(state)) return false;\n            if (dispatch) {\n                const rect = selectedRect(state);\n                dispatch(addRowWithAlignment(state.tr, rect, rect.bottom));\n            }\n            return true;\n        },\n        disable: (view) => !getCellSelection(view).isRowSelection(),\n    },\n    [Action.AlignLeft]: {\n        $: ctx.get(themeManagerCtx).get(ThemeIcon, 'alignLeft')?.dom as HTMLElement,\n        command: () => setCellAttr('alignment', 'left'),\n        disable: (view) => !getCellSelection(view).isColSelection(),\n    },\n    [Action.AlignCenter]: {\n        $: ctx.get(themeManagerCtx).get(ThemeIcon, 'alignCenter')?.dom as HTMLElement,\n        command: () => setCellAttr('alignment', 'center'),\n        disable: (view) => !getCellSelection(view).isColSelection(),\n    },\n    [Action.AlignRight]: {\n        $: ctx.get(themeManagerCtx).get(ThemeIcon, 'alignRight')?.dom as HTMLElement,\n        command: () => setCellAttr('alignment', 'right'),\n        disable: (view) => !getCellSelection(view).isColSelection(),\n    },\n    [Action.Delete]: {\n        $: ctx.get(themeManagerCtx).get(ThemeIcon, 'delete')?.dom as HTMLElement,\n        command: (_, view) => {\n            const selection = getCellSelection(view);\n            const isCol = selection.isColSelection();\n            const isRow = selection.isRowSelection();\n            if (isCol && isRow) {\n                return deleteTable;\n            }\n\n            if (isCol) {\n                return deleteColumn;\n            }\n\n            return deleteRow;\n        },\n        disable: (view) => {\n            const selection = getCellSelection(view);\n            if (selection.isRowSelection()) {\n                if (selection.isColSelection()) {\n                    return false;\n                }\n                return isFirstRowSelected(selection);\n            }\n            return false;\n        },\n    },\n});\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { missingRootElement } from '@milkdown/exception';\nimport { calculateNodePosition } from '@milkdown/prose';\nimport { EditorView } from '@milkdown/prose/view';\n\nimport { CellSelection } from '../plugin';\n\nexport const calculatePosition = (view: EditorView, dom: HTMLElement) => {\n    const { selection } = view.state as unknown as { selection: CellSelection };\n    const isCol = selection.isColSelection();\n    const isRow = selection.isRowSelection();\n\n    calculateNodePosition(view, dom, (selected, target, parent) => {\n        const $editor = dom.parentElement;\n        if (!$editor) {\n            throw missingRootElement();\n        }\n        let left = !isRow\n            ? selected.left - parent.left + (selected.width - target.width) / 2\n            : selected.left - parent.left - target.width / 2 - 8;\n        const top = selected.top - parent.top - target.height - (isCol ? 14 : 0) - 14 + $editor.scrollTop;\n\n        if (left < 0) {\n            left = 0;\n        }\n        return [top, left];\n    });\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nexport enum ToolTipPos {\n    Left = 'Left',\n    Top = 'Top',\n    Point = 'Point',\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Emotion, getPalette, ThemeBorder, ThemeManager, ThemeShadow, ThemeSize } from '@milkdown/core';\n\nexport const injectStyle = (themeManager: ThemeManager, { css, injectGlobal }: Emotion) => {\n    const palette = getPalette(themeManager);\n    const radius = themeManager.get(ThemeSize, 'radius');\n    const lineWidth = themeManager.get(ThemeSize, 'lineWidth');\n\n    injectGlobal`\n        .milkdown {\n            .tableWrapper {\n                table {\n                    width: calc(100% - 32px) !important;\n                    margin: 16px 0 16px 16px !important;\n\n                    .milkdown-cell-left,\n                    .milkdown-cell-point,\n                    .milkdown-cell-top {\n                        position: absolute;\n\n                        &::after {\n                            cursor: pointer;\n                            position: absolute;\n                            top: 0;\n                            left: 0;\n                            height: 100%;\n                            width: 100%;\n                            display: block;\n                            transition: all 0.2s ease-in-out;\n                            background: ${palette('secondary', 0.12)};\n                            content: '';\n                        }\n\n                        &:hover::after {\n                            background: ${palette('secondary', 0.38)};\n                        }\n                    }\n\n                    .milkdown-cell-left {\n                        left: -14px;\n                        top: 0;\n                        bottom: 0;\n                        width: 8px;\n                    }\n\n                    .milkdown-cell-top {\n                        left: 0;\n                        right: 0;\n                        top: -14px;\n                        height: 8px;\n                    }\n\n                    .milkdown-cell-point {\n                        left: -18px;\n                        top: -18px;\n                        width: 16px;\n                        height: 16px;\n\n                        .icon {\n                            position: absolute;\n                            top: 0;\n                            bottom: 0;\n                            left: 0;\n                            right: 0;\n                        }\n                    }\n                }\n            }\n        }\n    `;\n\n    return css`\n        display: inline-flex;\n        cursor: pointer;\n        z-index: 2;\n\n        justify-content: space-evenly;\n\n        position: absolute;\n\n        border-radius: ${radius};\n\n        ${themeManager.get(ThemeBorder, undefined)};\n        ${themeManager.get(ThemeShadow, undefined)};\n\n        overflow: hidden;\n        background: ${palette('surface')};\n\n        .icon {\n            position: relative;\n            color: ${palette('solid', 0.87)};\n\n            width: 48px;\n            line-height: 48px;\n            text-align: center;\n            transition: all 0.4s ease-in-out;\n\n            &:hover {\n                background-color: ${palette('secondary', 0.12)};\n            }\n\n            &.active {\n                color: ${palette('primary')};\n            }\n\n            &:not(:last-child)::after {\n                content: '';\n                position: absolute;\n                right: 0;\n                top: 0;\n                width: ${lineWidth};\n                bottom: 0;\n                background: ${palette('line')};\n            }\n        }\n\n        &.hide,\n        .hide {\n            display: none;\n        }\n    `;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, ThemeIcon, themeManagerCtx } from '@milkdown/core';\nimport { Decoration } from '@milkdown/prose/view';\n\nimport { CellPos, selectLine, selectTable } from '../utils';\nimport { ToolTipPos } from './constant';\n\nconst calculateClassName = (pos: ToolTipPos) => {\n    switch (pos) {\n        case ToolTipPos.Left: {\n            return 'milkdown-cell-left';\n        }\n        case ToolTipPos.Top: {\n            return 'milkdown-cell-top';\n        }\n        case ToolTipPos.Point:\n        default: {\n            return 'milkdown-cell-point';\n        }\n    }\n};\n\nexport function createWidget(ctx: Ctx, cell: CellPos, pos: ToolTipPos.Point): Decoration;\nexport function createWidget(ctx: Ctx, cell: CellPos, pos: ToolTipPos.Left, index: number): Decoration;\nexport function createWidget(ctx: Ctx, cell: CellPos, pos: ToolTipPos.Top, index: number): Decoration;\nexport function createWidget(ctx: Ctx, cell: CellPos, pos: ToolTipPos, index = 0) {\n    return Decoration.widget(cell.pos + 1, (view) => {\n        const div = document.createElement('div');\n        div.classList.add(calculateClassName(pos));\n        if (pos === ToolTipPos.Point) {\n            div.appendChild(ctx.get(themeManagerCtx).get(ThemeIcon, 'select')?.dom as HTMLElement);\n        }\n        div.addEventListener('mousedown', (e) => {\n            if (!view) return;\n\n            e.preventDefault();\n            switch (pos) {\n                case ToolTipPos.Point: {\n                    view.dispatch(selectTable(view.state.tr));\n                    return;\n                }\n                case ToolTipPos.Left: {\n                    view.dispatch(selectLine('row')(index)(view.state.tr));\n                    return;\n                }\n                case ToolTipPos.Top: {\n                    view.dispatch(selectLine('col')(index)(view.state.tr));\n                    return;\n                }\n            }\n        });\n        return div;\n    });\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx } from '@milkdown/core';\nimport { Plugin, PluginKey } from '@milkdown/prose/state';\nimport { Decoration, DecorationSet } from '@milkdown/prose/view';\nimport { ThemeUtils } from '@milkdown/utils';\n\nimport { CellSelection } from '../plugin';\nimport { CellPos, getCellsInColumn, getCellsInRow } from '../utils';\nimport { createActions } from './actions';\nimport { calculatePosition } from './calc-pos';\nimport { ToolTipPos } from './constant';\nimport { calculateItem } from './helper';\nimport { injectStyle } from './style';\nimport { createWidget } from './widget';\n\nexport const key = 'MILKDOWN_TABLE';\n\nexport const operatorPlugin = (ctx: Ctx, utils: ThemeUtils) => {\n    return new Plugin({\n        key: new PluginKey('MILKDOWN_TABLE_OP'),\n        props: {\n            decorations: (state) => {\n                const decorations: Decoration[] = [];\n                const leftCells = getCellsInColumn(0)(state.selection);\n                if (!leftCells) return null;\n                const topCells = getCellsInRow(0)(state.selection);\n                if (!topCells) return null;\n\n                const [topLeft] = leftCells;\n\n                decorations.push(createWidget(ctx, topLeft as CellPos, ToolTipPos.Point));\n                leftCells.forEach((cell, i) => {\n                    decorations.push(createWidget(ctx, cell, ToolTipPos.Left, i));\n                });\n                topCells.forEach((cell, i) => {\n                    decorations.push(createWidget(ctx, cell, ToolTipPos.Top, i));\n                });\n\n                return DecorationSet.create(state.doc, decorations);\n            },\n        },\n        view: (editorView) => {\n            const items = Object.fromEntries(Object.entries(createActions(ctx)).filter(([, value]) => value.$ != null));\n            const tooltip = document.createElement('div');\n            utils.themeManager.onFlush(() => {\n                const style = utils.getStyle((emotion) => injectStyle(utils.themeManager, emotion));\n                if (style) {\n                    tooltip.classList.add(style);\n                }\n            });\n            tooltip.classList.add('table-tooltip', 'hide');\n            Object.values(items).forEach(({ $ }) => tooltip.appendChild($));\n            editorView.dom.parentNode?.appendChild(tooltip);\n\n            const listener = (e: Event) => {\n                if (!editorView) return;\n                e.stopPropagation();\n                e.preventDefault();\n                Object.values(items).forEach(({ $, command }) => {\n                    if ($.contains(e.target as Element)) {\n                        command(e, editorView)(editorView.state, editorView.dispatch, editorView);\n                    }\n                });\n            };\n\n            const hide = () => {\n                tooltip.classList.add('hide');\n            };\n\n            tooltip.addEventListener('mousedown', listener);\n\n            return {\n                update: (view, prevState) => {\n                    const state = view.state;\n\n                    if (prevState?.doc.eq(state.doc) && prevState.selection.eq(state.selection)) return;\n\n                    const isCellSelection = state.selection instanceof CellSelection;\n\n                    if (!isCellSelection || !view.editable) {\n                        hide();\n                        return;\n                    }\n\n                    calculateItem(items, view);\n                    if (Object.values(items).every(({ $ }) => $.classList.contains('hide'))) {\n                        hide();\n                        return;\n                    }\n                    tooltip.classList.remove('hide');\n                    calculatePosition(view, tooltip);\n                },\n                destroy: () => {\n                    tooltip.removeEventListener('mousedown', listener);\n                    tooltip.remove();\n                },\n            };\n        },\n    });\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { browser } from '@milkdown/prose';\nimport { Node } from '@milkdown/prose/model';\nimport { Plugin, PluginKey } from '@milkdown/prose/state';\n\nimport { isInTable } from './util';\n\nconst isEmptyParagraph = (node: Node) => {\n    return node.type.name === 'paragraph' && node.nodeSize === 2;\n};\n\nconst isParagraph = (node: Node) => {\n    return node.type.name === 'paragraph';\n};\n\nconst pluginKey = new PluginKey('plugin_autoInsertZeroSpace');\n\nexport const autoInsertZeroSpace = () => {\n    return new Plugin({\n        key: pluginKey,\n        props: {\n            handleDOMEvents: {\n                compositionstart(view) {\n                    const { state, dispatch } = view;\n                    const { tr, selection } = state;\n                    const { $from } = selection;\n                    if (browser.safari && isInTable(state) && selection.empty && isEmptyParagraph($from.parent)) {\n                        dispatch(tr.insertText('\\u2060', $from.start()));\n                    }\n                    return false;\n                },\n                compositionend(view) {\n                    const { state, dispatch } = view;\n                    const { tr, selection } = state;\n                    const { $from } = selection;\n\n                    if (\n                        browser.safari &&\n                        isInTable(state) &&\n                        selection.empty &&\n                        isParagraph($from.parent) &&\n                        $from.parent.textContent.startsWith('\\u2060')\n                    ) {\n                        dispatch(tr.delete($from.start(), $from.start() + 1));\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Node } from '@milkdown/prose/model';\nimport { NodeView } from '@milkdown/prose/view';\n\n/* Copyright 2021, Milkdown by Mirone. */\nexport class TableView implements NodeView {\n    public dom: HTMLElement;\n    public contentDOM: HTMLElement;\n    public table: HTMLTableElement;\n    public colgroup: HTMLTableColElement;\n\n    constructor(public node: Node, public cellMinWidth: number) {\n        this.node = node;\n        this.cellMinWidth = cellMinWidth;\n        this.dom = document.createElement('div');\n        this.dom.className = 'tableWrapper';\n        this.table = this.dom.appendChild(document.createElement('table'));\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n    }\n\n    update(node: Node) {\n        if (node.type != this.node.type) return false;\n        this.node = node;\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n        return true;\n    }\n\n    ignoreMutation(record: MutationRecord) {\n        return record.type == 'attributes' && (record.target == this.table || this.colgroup.contains(record.target));\n    }\n}\n\nexport function updateColumns(\n    node: Node,\n    colgroup: HTMLTableColElement,\n    table: HTMLTableElement,\n    cellMinWidth: number,\n    overrideCol?: number,\n    overrideValue?: number,\n) {\n    let totalWidth = 0,\n        fixedWidth = true;\n    let nextDOM = colgroup.firstChild;\n    const row = node.firstChild as Node;\n    for (let i = 0, col = 0; i < row.childCount; i++) {\n        const { colspan, colwidth } = row.child(i).attrs;\n        for (let j = 0; j < colspan; j++, col++) {\n            const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n            const cssWidth = hasWidth ? hasWidth + 'px' : '';\n            totalWidth += hasWidth || cellMinWidth;\n            if (!hasWidth) fixedWidth = false;\n            if (!nextDOM) {\n                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\n            } else {\n                if ((nextDOM as HTMLElement).style.width != cssWidth) (nextDOM as HTMLElement).style.width = cssWidth;\n                nextDOM = nextDOM.nextSibling;\n            }\n        }\n    }\n\n    while (nextDOM) {\n        const after = nextDOM.nextSibling;\n        nextDOM.parentNode?.removeChild(nextDOM);\n        nextDOM = after;\n    }\n\n    if (fixedWidth) {\n        table.style.width = totalWidth + 'px';\n        table.style.minWidth = '';\n    } else {\n        table.style.width = '';\n        table.style.minWidth = totalWidth + 'px';\n    }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Attrs, Node } from '@milkdown/prose/model';\nimport { EditorState, Plugin, PluginKey, Transaction } from '@milkdown/prose/state';\nimport { Decoration, DecorationSet, EditorView } from '@milkdown/prose/view';\n\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './table-map';\nimport { TableView, updateColumns } from './table-view';\nimport { cellAround, pointsAtCell, setAttr } from './util';\n\nexport const key = new PluginKey('tableColumnResizing');\n\nexport function columnResizing({\n    handleWidth = 5,\n    cellMinWidth = 25,\n    View = TableView,\n    lastColumnResizable = true,\n} = {}) {\n    const plugin = new Plugin({\n        key,\n        state: {\n            init(this: Plugin, _, state) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.spec.props!.nodeViews![tableNodeTypes(state.schema).table.name] = (node) =>\n                    new View(node, cellMinWidth);\n                return new ResizeState(-1, false);\n            },\n            apply(tr, prev) {\n                return prev.apply(tr);\n            },\n        },\n        props: {\n            attributes(state) {\n                const pluginState = key.getState(state);\n                return pluginState.activeHandle > -1 ? { class: 'resize-cursor' } : (undefined as unknown as Attrs);\n            },\n\n            handleDOMEvents: {\n                mousemove(view, event) {\n                    handleMouseMove(view, event as MouseEvent, handleWidth, lastColumnResizable);\n                },\n                mouseleave(view) {\n                    handleMouseLeave(view);\n                },\n                mousedown(view, event) {\n                    handleMouseDown(view, event as MouseEvent, cellMinWidth);\n                },\n            },\n\n            decorations(state) {\n                const pluginState = key.getState(state);\n                if (pluginState.activeHandle > -1) return handleDecorations(state, pluginState.activeHandle);\n\n                return null;\n            },\n\n            nodeViews: {},\n        },\n    });\n    return plugin;\n}\n\nclass ResizeState {\n    constructor(public activeHandle: number, public dragging: null | boolean) {\n        this.activeHandle = activeHandle;\n        this.dragging = dragging;\n    }\n\n    apply(this: ResizeState, tr: Transaction) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let state = this;\n        const action = tr.getMeta(key);\n        if (action && action.setHandle != null) return new ResizeState(action.setHandle, null);\n        if (action && action.setDragging !== undefined) return new ResizeState(state.activeHandle, action.setDragging);\n        if (state.activeHandle > -1 && tr.docChanged) {\n            let handle = tr.mapping.map(state.activeHandle, -1);\n            if (!pointsAtCell(tr.doc.resolve(handle))) handle = 0;\n            state = new ResizeState(handle, state.dragging);\n        }\n        return state;\n    }\n}\n\nfunction handleMouseMove(view: EditorView, event: MouseEvent, handleWidth: number, lastColumnResizable: boolean) {\n    const pluginState = key.getState(view.state);\n\n    if (!pluginState.dragging) {\n        const target = domCellAround(event.target as Element);\n        let cell = -1;\n        if (target) {\n            const { left, right } = target.getBoundingClientRect();\n            if (event.clientX - left <= handleWidth) cell = edgeCell(view, event, 'left');\n            else if (right - event.clientX <= handleWidth) cell = edgeCell(view, event, 'right');\n        }\n\n        if (cell != pluginState.activeHandle) {\n            if (!lastColumnResizable && cell !== -1) {\n                const $cell = view.state.doc.resolve(cell);\n                const table = $cell.node(-1),\n                    map = TableMap.get(table),\n                    start = $cell.start(-1);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const col = map.colCount($cell.pos - start) + $cell.nodeAfter!.attrs['colspan'] - 1;\n\n                if (col == map.width - 1) {\n                    return;\n                }\n            }\n\n            updateHandle(view, cell);\n        }\n    }\n}\n\nfunction handleMouseLeave(view: EditorView) {\n    const pluginState = key.getState(view.state);\n    if (pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);\n}\n\nfunction handleMouseDown(view: EditorView, event: MouseEvent, cellMinWidth: number) {\n    const pluginState = key.getState(view.state);\n    if (pluginState.activeHandle == -1 || pluginState.dragging) return false;\n\n    const cell = view.state.doc.nodeAt(pluginState.activeHandle) as Node;\n    const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n    view.dispatch(\n        view.state.tr.setMeta(key, {\n            setDragging: { startX: event.clientX, startWidth: width },\n        }),\n    );\n\n    function finish(event: MouseEvent) {\n        window.removeEventListener('mouseup', finish);\n        window.removeEventListener('mousemove', move);\n        const pluginState = key.getState(view.state);\n        if (pluginState.dragging) {\n            updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth));\n            view.dispatch(view.state.tr.setMeta(key, { setDragging: null }));\n        }\n    }\n    function move(event: MouseEvent) {\n        if (!event.which) return finish(event);\n        const pluginState = key.getState(view.state);\n        const dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n        displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);\n    }\n\n    window.addEventListener('mouseup', finish);\n    window.addEventListener('mousemove', move);\n    event.preventDefault();\n    return true;\n}\n\nfunction currentColWidth(view: EditorView, cellPos: number, { colspan, colwidth }: Attrs) {\n    const width = colwidth && colwidth[colwidth.length - 1];\n    if (width) return width;\n    const dom = view.domAtPos(cellPos);\n    const node = dom.node.childNodes[dom.offset] as HTMLElement;\n    let domWidth = node.offsetWidth,\n        parts = colspan;\n    if (colwidth)\n        for (let i = 0; i < colspan; i++)\n            if (colwidth[i]) {\n                domWidth -= colwidth[i];\n                parts--;\n            }\n    return domWidth / parts;\n}\n\nfunction domCellAround(target: Element | null) {\n    while (target && target.nodeName != 'TD' && target.nodeName != 'TH')\n        target = target.classList.contains('ProseMirror') ? null : (target.parentNode as Element);\n    return target;\n}\n\nfunction edgeCell(view: EditorView, event: MouseEvent, side: 'left' | 'right') {\n    const found = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (!found) return -1;\n    const { pos } = found;\n    const $cell = cellAround(view.state.doc.resolve(pos));\n    if (!$cell) return -1;\n    if (side == 'right') return $cell.pos;\n    const map = TableMap.get($cell.node(-1)),\n        start = $cell.start(-1);\n    const index = map.map.indexOf($cell.pos - start);\n    return index % map.width == 0 ? -1 : start + (map.map[index - 1] as number);\n}\n\nfunction draggedWidth(dragging: { startX: number; startWidth: number }, event: MouseEvent, cellMinWidth: number) {\n    const offset = event.clientX - dragging.startX;\n    return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\n\nfunction updateHandle(view: EditorView, value: number) {\n    view.dispatch(view.state.tr.setMeta(key, { setHandle: value }));\n}\n\nfunction updateColumnWidth(view: EditorView, cell: number, width: number) {\n    const $cell = view.state.doc.resolve(cell);\n    const table = $cell.node(-1),\n        map = TableMap.get(table),\n        start = $cell.start(-1);\n    const col = map.colCount($cell.pos - start) + ($cell.nodeAfter as Node).attrs['colspan'] - 1;\n    const tr = view.state.tr;\n    for (let row = 0; row < map.height; row++) {\n        const mapIndex = row * map.width + col;\n        // Rowspanning cell that has already been handled\n        if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n        const pos = map.map[mapIndex] as number,\n            { attrs } = table.nodeAt(pos) as Node;\n        const index = attrs['colspan'] == 1 ? 0 : col - map.colCount(pos);\n        if (attrs['colwidth'] && attrs['colwidth'][index] == width) continue;\n        const colwidth = attrs['colwidth'] ? attrs['colwidth'].slice() : zeroes(attrs['colspan']);\n        colwidth[index] = width;\n        tr.setNodeMarkup(start + pos, null, setAttr(attrs, 'colwidth', colwidth));\n    }\n    if (tr.docChanged) view.dispatch(tr);\n}\n\nfunction displayColumnWidth(view: EditorView, cell: number, width: number, cellMinWidth: number) {\n    const $cell = view.state.doc.resolve(cell);\n    const table = $cell.node(-1),\n        start = $cell.start(-1);\n    const col = TableMap.get(table).colCount($cell.pos - start) + ($cell.nodeAfter as Node).attrs['colspan'] - 1;\n    let dom = view.domAtPos($cell.start(-1)).node as HTMLElement;\n    while (dom.nodeName != 'TABLE') dom = dom.parentNode as HTMLElement;\n    updateColumns(table, dom.firstChild as HTMLTableColElement, dom as HTMLTableElement, cellMinWidth, col, width);\n}\n\nfunction zeroes(n: number) {\n    const result = [];\n    for (let i = 0; i < n; i++) result.push(0);\n    return result;\n}\n\nfunction handleDecorations(state: EditorState, cell: number) {\n    const decorations = [];\n    const $cell = state.doc.resolve(cell);\n    const table = $cell.node(-1),\n        map = TableMap.get(table),\n        start = $cell.start(-1);\n    const col = map.colCount($cell.pos - start) + ($cell.nodeAfter as Node).attrs['colspan'];\n    for (let row = 0; row < map.height; row++) {\n        const index = col + row * map.width - 1;\n        // For positions that are have either a different cell or the end\n        // of the table to their right, and either the top of the table or\n        // a different cell above them, add a decoration\n        if (\n            (col == map.width || map.map[index] != map.map[index + 1]) &&\n            (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])\n        ) {\n            const cellPos = map.map[index] as number;\n            const pos = start + cellPos + (table.nodeAt(cellPos) as Node).nodeSize - 1;\n            const dom = document.createElement('div');\n            dom.className = 'column-resize-handle';\n            decorations.push(Decoration.widget(pos, dom));\n        }\n    }\n    return DecorationSet.create(state.doc, decorations);\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Fragment, Node, NodeType, Schema, Slice } from '@milkdown/prose/model';\nimport { EditorState, Transaction } from '@milkdown/prose/state';\nimport { Transform } from '@milkdown/prose/transform';\n\nimport { CellSelection } from './cell-selection';\nimport { tableNodeTypes } from './schema';\nimport { Rect, TableMap } from './table-map';\nimport { removeColSpan, setAttr } from './util';\n\n// Utilities to help with copying and pasting table cells\n\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\nexport function pastedCells(slice: Slice) {\n    if (!slice.size) return null;\n    let { content, openStart, openEnd } = slice;\n    while (\n        content.childCount == 1 &&\n        ((openStart > 0 && openEnd > 0) || (content.firstChild as Node).type.spec['tableRole'] == 'table')\n    ) {\n        openStart--;\n        openEnd--;\n        content = (content.firstChild as Node).content;\n    }\n    const first = content.firstChild as Node,\n        role = first.type.spec['tableRole'];\n    const schema = first.type.schema,\n        rows = [];\n    if (role == 'row') {\n        for (let i = 0; i < content.childCount; i++) {\n            let cells = content.child(i).content;\n            const left = i ? 0 : Math.max(0, openStart - 1);\n            const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n            if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content;\n            rows.push(cells);\n        }\n    } else if (role == 'cell' || role == 'header_cell') {\n        rows.push(\n            openStart || openEnd\n                ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content\n                : content,\n        );\n    } else {\n        return null;\n    }\n    return ensureRectangular(schema, rows);\n}\n\n// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nexport type R = { width: number; height: number; rows: Fragment[] };\nfunction ensureRectangular(schema: Schema, rows: Fragment[]): R {\n    const widths: number[] = [];\n    for (let i = 0; i < rows.length; i++) {\n        const row = rows[i] as Fragment;\n        for (let j = row.childCount - 1; j >= 0; j--) {\n            const { rowspan, colspan } = row.child(j).attrs;\n            for (let r = i; r < i + rowspan; r++) widths[r] = (widths[r] || 0) + colspan;\n        }\n    }\n    let width = 0;\n    for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r] as number);\n    for (let r = 0; r < widths.length; r++) {\n        if (r >= rows.length) rows.push(Fragment.empty);\n        if ((widths[r] as number) < width) {\n            const empty = tableNodeTypes(schema).cell.createAndFill(),\n                cells = [];\n            for (let i = widths[r] as number; i < width; i++) cells.push(empty);\n            rows[r] = (rows[r] as Fragment).append(Fragment.from(cells));\n        }\n    }\n    return { height: rows.length, width, rows };\n}\n\nexport function fitSlice(nodeType: NodeType, slice: Slice) {\n    const node = nodeType.createAndFill() as Node;\n    const tr = new Transform(node).replace(0, node.content.size, slice);\n    return tr.doc;\n}\n\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\nexport function clipCells({ width, height, rows }: R, newWidth: number, newHeight: number): R {\n    if (width != newWidth) {\n        const added: number[] = [],\n            newRows: Fragment[] = [];\n        for (let row = 0; row < rows.length; row++) {\n            const frag = rows[row] as Fragment,\n                cells = [];\n            for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n                let cell = frag.child(i % frag.childCount);\n                if (col + cell.attrs['colspan'] > newWidth)\n                    cell = cell.type.create(\n                        removeColSpan(cell.attrs, cell.attrs['colspan'], col + cell.attrs['colspan'] - newWidth),\n                        cell.content,\n                    );\n                cells.push(cell);\n                col += cell.attrs['colspan'];\n                for (let j = 1; j < cell.attrs['rowspan']; j++)\n                    added[row + j] = (added[row + j] || 0) + cell.attrs['colspan'];\n            }\n            newRows.push(Fragment.from(cells));\n        }\n        rows = newRows;\n        width = newWidth;\n    }\n\n    if (height != newHeight) {\n        const newRows = [];\n        for (let row = 0, i = 0; row < newHeight; row++, i++) {\n            const cells = [],\n                source = rows[i % height] as Fragment;\n            for (let j = 0; j < source.childCount; j++) {\n                let cell = source.child(j);\n                if (row + cell.attrs['rowspan'] > newHeight)\n                    cell = cell.type.create(\n                        setAttr(cell.attrs, 'rowspan', Math.max(1, newHeight - cell.attrs['rowspan'])),\n                        cell.content,\n                    );\n                cells.push(cell);\n            }\n            newRows.push(Fragment.from(cells));\n        }\n        rows = newRows;\n        height = newHeight;\n    }\n\n    return { width, height, rows };\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(\n    tr: Transaction,\n    map: TableMap,\n    table: Node,\n    start: number,\n    width: number,\n    height: number,\n    mapFrom: number,\n) {\n    const schema = tr.doc.type.schema,\n        types = tableNodeTypes(schema);\n    let empty, emptyHead;\n    if (width > map.width) {\n        for (let row = 0, rowEnd = 0; row < map.height; row++) {\n            const rowNode = table.child(row);\n            rowEnd += rowNode.nodeSize;\n            const cells = [];\n            let add;\n            if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n                add = empty || (empty = types.cell.createAndFill());\n            else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n            for (let i = map.width; i < width; i++) cells.push(add);\n            tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n        }\n    }\n    if (height > map.height) {\n        const cells = [];\n        for (let i = 0, start = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n            const header =\n                i >= map.width ? false : (table.nodeAt(map.map[start + i] as number) as Node).type == types.header_cell;\n            cells.push(\n                header\n                    ? emptyHead || (emptyHead = types.header_cell.createAndFill())\n                    : empty || (empty = types.cell.createAndFill()),\n            );\n        }\n\n        const emptyRow = types.row.create(null, Fragment.from(cells)),\n            rows = [];\n        for (let i = map.height; i < height; i++) rows.push(emptyRow);\n        tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n    }\n    return !!(empty || emptyHead);\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(\n    tr: Transaction,\n    map: TableMap,\n    table: Node,\n    start: number,\n    left: number,\n    right: number,\n    top: number,\n    mapFrom: number,\n) {\n    if (top == 0 || top == map.height) return false;\n    let found = false;\n    for (let col = left; col < right; col++) {\n        const index = top * map.width + col,\n            pos = map.map[index] as number;\n        if (map.map[index - map.width] == pos) {\n            found = true;\n            const cell = table.nodeAt(pos) as Node;\n            const { top: cellTop, left: cellLeft } = map.findCell(pos);\n            tr.setNodeMarkup(\n                tr.mapping.slice(mapFrom).map(pos + start),\n                null,\n                setAttr(cell.attrs, 'rowspan', top - cellTop),\n            );\n            tr.insert(\n                tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n                cell.type.createAndFill(setAttr(cell.attrs, 'rowspan', cellTop + cell.attrs['rowspan'] - top)) as Node,\n            );\n            col += cell.attrs['colspan'] - 1;\n        }\n    }\n    return found;\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(\n    tr: Transaction,\n    map: TableMap,\n    table: Node,\n    start: number,\n    top: number,\n    bottom: number,\n    left: number,\n    mapFrom: number,\n) {\n    if (left == 0 || left == map.width) return false;\n    let found = false;\n    for (let row = top; row < bottom; row++) {\n        const index = row * map.width + left,\n            pos = map.map[index] as number;\n        if (map.map[index - 1] == pos) {\n            found = true;\n            const cell = table.nodeAt(pos) as Node,\n                cellLeft = map.colCount(pos);\n            const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n            tr.setNodeMarkup(\n                updatePos,\n                null,\n                removeColSpan(cell.attrs, left - cellLeft, cell.attrs['colspan'] - (left - cellLeft)),\n            );\n            tr.insert(\n                updatePos + cell.nodeSize,\n                cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)) as Node,\n            );\n            row += cell.attrs['rowspan'] - 1;\n        }\n    }\n    return found;\n}\n\n// Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\nexport function insertCells(\n    state: EditorState,\n    dispatch: (tr: Transaction) => void,\n    tableStart: number,\n    rect: Rect,\n    cells: R,\n) {\n    let table = (tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc) as Node,\n        map = TableMap.get(table);\n    const { top, left } = rect;\n    const right = left + cells.width,\n        bottom = top + cells.height;\n    const tr = state.tr;\n    let mapFrom = 0;\n    function recomp() {\n        table = (tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc) as Node;\n        map = TableMap.get(table);\n        mapFrom = tr.mapping.maps.length;\n    }\n    // Prepare the table to be large enough and not have any cells\n    // crossing the boundaries of the rectangle that we want to\n    // insert into. If anything about it changes, recompute the table\n    // map so that subsequent operations can see the current shape.\n    if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n    if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp();\n    if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp();\n    if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp();\n    if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp();\n\n    for (let row = top; row < bottom; row++) {\n        const from = map.positionAt(row, left, table),\n            to = map.positionAt(row, right, table);\n        tr.replace(\n            tr.mapping.slice(mapFrom).map(from + tableStart),\n            tr.mapping.slice(mapFrom).map(to + tableStart),\n            new Slice(cells.rows[row - top] as Fragment, 0, 0),\n        );\n    }\n    recomp();\n    tr.setSelection(\n        new CellSelection(\n            tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n            tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table)),\n        ),\n    );\n    dispatch(tr);\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Node } from '@milkdown/prose/model';\nimport { EditorState, PluginKey, Transaction } from '@milkdown/prose/state';\n\nimport { tableNodeTypes } from './schema';\nimport { Problem, TableMap } from './table-map';\nimport { removeColSpan, setAttr } from './util';\n\nexport const fixTablesKey = new PluginKey('fix-tables');\n\n// Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\nfunction changedDescendants(old: Node, cur: Node, offset: number, f: (node: Node, pos: number) => void | boolean) {\n    const oldSize = old.childCount,\n        curSize = cur.childCount;\n    outer: for (let i = 0, j = 0; i < curSize; i++) {\n        const child = cur.child(i);\n        for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n            if (old.child(scan) == child) {\n                j = scan + 1;\n                offset += child.nodeSize;\n                continue outer;\n            }\n        }\n        f(child, offset);\n        if (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset + 1, f);\n        else child.nodesBetween(0, child.content.size, f, offset + 1);\n        offset += child.nodeSize;\n    }\n}\n\n// :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\nexport function fixTables(state: EditorState, oldState: EditorState) {\n    let tr: undefined | Transaction;\n    const check = (node: Node, pos: number) => {\n        if (node.type.spec['tableRole'] == 'table') tr = fixTable(state, node, pos, tr);\n    };\n    if (!oldState) state.doc.descendants(check);\n    else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);\n    return tr;\n}\n\n// : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nexport function fixTable(state: EditorState, table: Node, tablePos: number, tr?: Transaction) {\n    const map = TableMap.get(table);\n    if (!map.problems) return tr;\n    if (!tr) tr = state.tr;\n\n    // Track which rows we must add cells to, so that we can adjust that\n    // when fixing collisions.\n    const mustAdd = [];\n    for (let i = 0; i < map.height; i++) mustAdd.push(0);\n    for (let i = 0; i < map.problems.length; i++) {\n        const prob = map.problems[i] as Problem;\n        if (prob.type == 'collision') {\n            const cell = table.nodeAt(prob.pos) as Node;\n            for (let j = 0; j < cell.attrs['rowspan']; j++) mustAdd[prob.row + j] += prob.n;\n            tr.setNodeMarkup(\n                tr.mapping.map(tablePos + 1 + prob.pos),\n                null,\n                removeColSpan(cell.attrs, cell.attrs['colspan'] - prob.n, prob.n),\n            );\n        } else if (prob.type == 'missing') {\n            mustAdd[prob.row] += prob.n;\n        } else if (prob.type == 'overlong_rowspan') {\n            const cell = table.nodeAt(prob.pos) as Node;\n            tr.setNodeMarkup(\n                tr.mapping.map(tablePos + 1 + prob.pos),\n                null,\n                setAttr(cell.attrs, 'rowspan', cell.attrs['rowspan'] - prob.n),\n            );\n        } else if (prob.type == 'colwidth mismatch') {\n            const cell = table.nodeAt(prob.pos) as Node;\n            tr.setNodeMarkup(\n                tr.mapping.map(tablePos + 1 + prob.pos),\n                null,\n                setAttr(cell.attrs, 'colwidth', prob.colwidth),\n            );\n        }\n    }\n    let first, last;\n    for (let i = 0; i < mustAdd.length; i++)\n        if (mustAdd[i]) {\n            if (first == null) first = i;\n            last = i;\n        }\n    // Add the necessary cells, using a heuristic for whether to add the\n    // cells at the start or end of the rows (if it looks like a 'bite'\n    // was taken out of the table, add cells at the start of the row\n    // after the bite. Otherwise add them at the end).\n    for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n        const row = table.child(i);\n        const end = pos + row.nodeSize;\n        const add = mustAdd[i] as number;\n        if (add > 0) {\n            let tableNodeType = 'cell';\n            if (row.firstChild) {\n                tableNodeType = row.firstChild.type.spec['tableRole'];\n            }\n            const nodes = [];\n            for (let j = 0; j < add; j++) nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());\n            const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n            tr.insert(tr.mapping.map(side), nodes);\n        }\n        pos = end;\n    }\n    return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { keydownHandler } from '@milkdown/prose/keymap';\nimport { Fragment, ResolvedPos, Slice } from '@milkdown/prose/model';\nimport { Command, EditorState, Plugin, PluginKey, Selection, TextSelection, Transaction } from '@milkdown/prose/state';\nimport { EditorView } from '@milkdown/prose/view';\n\nimport { CellSelection, drawCellSelection, normalizeSelection } from './cell-selection';\nimport { clipCells, fitSlice, insertCells, pastedCells } from './copy-paste';\nimport { fixTables } from './fix-tables';\nimport { tableNodeTypes } from './schema';\nimport { TableMap } from './table-map';\nimport { cellAround, inSameTable, isInTable, nextCell, selectionCell } from './util';\n\nexport const tableEditingKey = new PluginKey('selectingCells');\n\nfunction domInCell(view: EditorView, dom: EventTarget | null) {\n    for (; dom && dom != view.dom; dom = (dom as Element).parentNode as Element)\n        if ((dom as Element).nodeName == 'TD' || (dom as Element).nodeName == 'TH') return dom;\n    return;\n}\n\nfunction cellUnderMouse(view: EditorView, event: MouseEvent) {\n    const mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (!mousePos) return null;\n    return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\nfunction handleMouseDown(view: EditorView, event: Event) {\n    const startEvent = event as MouseEvent;\n    if (startEvent.ctrlKey || startEvent.metaKey) return;\n\n    const startDOMCell = domInCell(view, startEvent.target as Element);\n    let $anchor;\n    if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n        // Adding to an existing cell selection\n        setCellSelection(view.state.selection.$anchorCell, startEvent);\n        startEvent.preventDefault();\n    } else if (\n        startEvent.shiftKey &&\n        startDOMCell &&\n        ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        cellUnderMouse(view, startEvent)!.pos != $anchor.pos\n    ) {\n        // Adding to a selection that starts in another cell (causing a\n        // cell selection to be created).\n        setCellSelection($anchor, startEvent);\n        startEvent.preventDefault();\n    } else if (!startDOMCell) {\n        // Not in a cell, let the default behavior happen.\n        return;\n    }\n\n    // Create and dispatch a cell selection between the given anchor and\n    // the position under the mouse.\n    function setCellSelection($anchor: ResolvedPos, event: MouseEvent) {\n        let $head = cellUnderMouse(view, event);\n        const starting = tableEditingKey.getState(view.state) == null;\n        if (!$head || !inSameTable($anchor, $head)) {\n            if (starting) $head = $anchor;\n            else return;\n        }\n        const selection = new CellSelection($anchor, $head);\n        if (starting || !view.state.selection.eq(selection)) {\n            const tr = view.state.tr.setSelection(selection);\n            if (starting) tr.setMeta(tableEditingKey, $anchor.pos);\n            view.dispatch(tr);\n        }\n    }\n\n    // Stop listening to mouse motion events.\n    function stop() {\n        view.root.removeEventListener('mouseup', stop);\n        view.root.removeEventListener('dragstart', stop);\n        view.root.removeEventListener('mousemove', move);\n        if (tableEditingKey.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n    }\n\n    function move(event: Event) {\n        const anchor = tableEditingKey.getState(view.state);\n        let $anchor;\n        if (anchor != null) {\n            // Continuing an existing cross-cell selection\n            $anchor = view.state.doc.resolve(anchor);\n        } else if (domInCell(view, event.target) != startDOMCell) {\n            // Moving out of the initial cell -- start a new cell selection\n            $anchor = cellUnderMouse(view, startEvent);\n            if (!$anchor) return stop();\n        }\n        if ($anchor) setCellSelection($anchor, event as MouseEvent);\n    }\n    view.root.addEventListener('mouseup', stop);\n    view.root.addEventListener('dragstart', stop);\n    view.root.addEventListener('mousemove', move);\n}\n\nfunction handleTripleClick(view: EditorView, pos: number) {\n    const doc = view.state.doc,\n        $cell = cellAround(doc.resolve(pos));\n    if (!$cell) return false;\n    view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n    return true;\n}\n\nfunction maybeSetSelection(\n    state: EditorState,\n    dispatch: undefined | ((tr: Transaction) => void),\n    selection: Selection,\n) {\n    if (selection.eq(state.selection)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n    return true;\n}\n\nfunction atEndOfCell(view: EditorView, axis: string, dir: number) {\n    if (!(view.state.selection instanceof TextSelection)) return null;\n    const { $head } = view.state.selection;\n    for (let d = $head.depth - 1; d >= 0; d--) {\n        const parent = $head.node(d),\n            index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n        if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n        if (parent.type.spec['tableRole'] == 'cell' || parent.type.spec['tableRole'] == 'header_cell') {\n            const cellPos = $head.before(d);\n            const dirStr = axis == 'vert' ? (dir > 0 ? 'down' : 'up') : dir > 0 ? 'right' : 'left';\n            return view.endOfTextblock(dirStr) ? cellPos : null;\n        }\n    }\n    return null;\n}\n\nfunction arrow(axis: string, dir: number): Command {\n    return (state, dispatch, view) => {\n        const sel = state.selection;\n        if (sel instanceof CellSelection) {\n            return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir));\n        }\n        if (axis != 'horiz' && !sel.empty) return false;\n        const end = atEndOfCell(view as EditorView, axis, dir);\n        if (end == null) return false;\n        if (axis == 'horiz') {\n            return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir));\n        } else {\n            const $cell = state.doc.resolve(end),\n                $next = nextCell($cell, axis, dir);\n            let newSel;\n            if ($next) newSel = Selection.near($next, 1);\n            else if (dir < 0) newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);\n            else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);\n            return maybeSetSelection(state, dispatch, newSel);\n        }\n    };\n}\n\nfunction shiftArrow(axis: string, dir: number): Command {\n    return (state, dispatch, view) => {\n        let sel = state.selection;\n        if (!(sel instanceof CellSelection)) {\n            const end = atEndOfCell(view as EditorView, axis, dir);\n            if (end == null) return false;\n            sel = new CellSelection(state.doc.resolve(end));\n        }\n        const $head = nextCell((sel as CellSelection).$headCell, axis, dir);\n        if (!$head) return false;\n        return maybeSetSelection(state, dispatch, new CellSelection((sel as CellSelection).$anchorCell, $head));\n    };\n}\n\nfunction deleteCellSelection(state: EditorState, dispatch?: (tr: Transaction) => void) {\n    const sel = state.selection;\n    if (!(sel instanceof CellSelection)) return false;\n    if (dispatch) {\n        const tr = state.tr,\n            baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n        sel.forEachCell((cell, pos) => {\n            if (!cell.content.eq(baseContent))\n                tr.replace(\n                    tr.mapping.map(pos + 1),\n                    tr.mapping.map(pos + cell.nodeSize - 1),\n                    new Slice(baseContent, 0, 0),\n                );\n        });\n        if (tr.docChanged) dispatch(tr);\n    }\n    return true;\n}\n\nconst handleKeyDown = keydownHandler({\n    ArrowLeft: arrow('horiz', -1),\n    ArrowRight: arrow('horiz', 1),\n    ArrowUp: arrow('vert', -1),\n    ArrowDown: arrow('vert', 1),\n\n    'Shift-ArrowLeft': shiftArrow('horiz', -1),\n    'Shift-ArrowRight': shiftArrow('horiz', 1),\n    'Shift-ArrowUp': shiftArrow('vert', -1),\n    'Shift-ArrowDown': shiftArrow('vert', 1),\n\n    Backspace: deleteCellSelection,\n    'Mod-Backspace': deleteCellSelection,\n    Delete: deleteCellSelection,\n    'Mod-Delete': deleteCellSelection,\n});\n\nexport function handlePaste(view: EditorView, _: Event, slice: Slice) {\n    if (!isInTable(view.state)) return false;\n    let cells = pastedCells(slice);\n    const sel = view.state.selection;\n    if (sel instanceof CellSelection) {\n        if (!cells)\n            cells = {\n                width: 1,\n                height: 1,\n                rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))],\n            };\n        const table = sel.$anchorCell.node(-1),\n            start = sel.$anchorCell.start(-1);\n        const rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n        cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n        insertCells(view.state, view.dispatch, start, rect, cells);\n        return true;\n    } else if (cells) {\n        const $cell = selectionCell(view.state) as ResolvedPos,\n            start = $cell.start(-1);\n        insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexport function tableEditing({ allowTableNodeSelection = false } = {}) {\n    return new Plugin({\n        key: tableEditingKey,\n\n        // This piece of state is used to remember when a mouse-drag\n        // cell-selection is happening, so that it can continue even as\n        // transactions (which might move its anchor cell) come in.\n        state: {\n            init() {\n                return null;\n            },\n            apply(tr, cur) {\n                const set = tr.getMeta(tableEditingKey);\n                if (set != null) return set == -1 ? null : set;\n                if (cur == null || !tr.docChanged) return cur;\n                const { deleted, pos } = tr.mapping.mapResult(cur);\n                return deleted ? null : pos;\n            },\n        },\n\n        props: {\n            decorations: drawCellSelection,\n\n            handleDOMEvents: {\n                mousedown: handleMouseDown,\n            },\n\n            createSelectionBetween(view) {\n                if (tableEditingKey.getState(view.state) != null) return view.state.selection;\n\n                return null;\n            },\n\n            handleTripleClick,\n\n            handleKeyDown,\n\n            handlePaste,\n        },\n\n        appendTransaction(_, oldState, state) {\n            return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n        },\n    });\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey, MarkdownNode, schemaCtx } from '@milkdown/core';\nimport { InputRule } from '@milkdown/prose/inputrules';\nimport { NodeType } from '@milkdown/prose/model';\nimport { Selection, TextSelection } from '@milkdown/prose/state';\nimport { createPlugin, createShortcut } from '@milkdown/utils';\n\nimport { exitTable } from '../command';\nimport { operatorPlugin } from '../operator-plugin';\nimport { autoInsertZeroSpace } from '../plugin/auto-insert-zero-space';\nimport { columnResizing } from '../plugin/column-resizing';\nimport { goToNextCell } from '../plugin/commands';\nimport { schema } from '../plugin/schema';\nimport { tableEditing } from '../plugin/table-editing';\nimport { createTable } from '../utils';\n\nexport const SupportedKeys = {\n    NextCell: 'NextCell',\n    PrevCell: 'PrevCell',\n    ExitTable: 'ExitTable',\n} as const;\nexport type SupportedKeys = typeof SupportedKeys;\n\ntype Keys = keyof SupportedKeys;\n\nexport const PrevCell = createCmdKey('PrevCell');\nexport const NextCell = createCmdKey('NextCell');\nexport const BreakTable = createCmdKey('BreakTable');\nexport const InsertTable = createCmdKey('InsertTable');\n\nexport const table = createPlugin<Keys, Record<string, unknown>, keyof typeof schema>((utils) => {\n    return {\n        schema: () => ({\n            node: {\n                table: {\n                    ...schema.table,\n                    parseMarkdown: {\n                        match: (node) => node.type === 'table',\n                        runner: (state, node, type) => {\n                            const align = node['align'] as (string | null)[];\n                            const children = (node.children as MarkdownNode[]).map((x, i) => ({\n                                ...x,\n                                align,\n                                isHeader: i === 0,\n                            }));\n                            state.openNode(type);\n                            state.next(children);\n                            state.closeNode();\n                        },\n                    },\n                    toMarkdown: {\n                        match: (node) => node.type.name === 'table',\n                        runner: (state, node) => {\n                            const firstLine = node.content.firstChild?.content;\n                            if (!firstLine) return;\n\n                            const align: (string | null)[] = [];\n                            firstLine.forEach((cell) => {\n                                align.push(cell.attrs['alignment']);\n                            });\n                            state.openNode('table', undefined, { align });\n                            state.next(node.content);\n                            state.closeNode();\n                        },\n                    },\n                },\n                table_row: {\n                    ...schema.table_row,\n                    parseMarkdown: {\n                        match: (node) => node.type === 'tableRow',\n                        runner: (state, node, type) => {\n                            const align = node['align'] as (string | null)[];\n                            const children = (node.children as MarkdownNode[]).map((x, i) => ({\n                                ...x,\n                                align: align[i],\n                                isHeader: node['isHeader'],\n                            }));\n                            state.openNode(type);\n                            state.next(children);\n                            state.closeNode();\n                        },\n                    },\n                    toMarkdown: {\n                        match: (node) => node.type.name === 'table_row',\n                        runner: (state, node) => {\n                            state.openNode('tableRow');\n                            state.next(node.content);\n                            state.closeNode();\n                        },\n                    },\n                },\n                table_cell: {\n                    ...schema.table_cell,\n                    parseMarkdown: {\n                        match: (node) => node.type === 'tableCell' && !node['isHeader'],\n                        runner: (state, node, type) => {\n                            const align = node['align'] as string;\n                            state\n                                .openNode(type, { alignment: align })\n                                .openNode(state.schema.nodes['paragraph'] as NodeType)\n                                .next(node.children)\n                                .closeNode()\n                                .closeNode();\n                        },\n                    },\n                    toMarkdown: {\n                        match: (node) => node.type.name === 'table_cell',\n                        runner: (state, node) => {\n                            state.openNode('tableCell').next(node.content).closeNode();\n                        },\n                    },\n                },\n                table_header: {\n                    ...schema.table_header,\n                    parseMarkdown: {\n                        match: (node) => node.type === 'tableCell' && !!node['isHeader'],\n                        runner: (state, node, type) => {\n                            const align = node['align'] as string;\n                            state.openNode(type, { alignment: align });\n                            state.openNode(state.schema.nodes['paragraph'] as NodeType);\n                            state.next(node.children);\n                            state.closeNode();\n                            state.closeNode();\n                        },\n                    },\n                    toMarkdown: {\n                        match: (node) => node.type.name === 'table_header',\n                        runner: (state, node) => {\n                            state.openNode('tableCell');\n                            state.next(node.content);\n                            state.closeNode();\n                        },\n                    },\n                },\n            },\n        }),\n        inputRules: (nodeType, ctx) => [\n            new InputRule(/^\\|\\|\\s$/, (state, _match, start, end) => {\n                const $start = state.doc.resolve(start);\n                if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType.table))\n                    return null;\n\n                const tableNode = createTable(ctx.get(schemaCtx));\n                const tr = state.tr.replaceRangeWith(start, end, tableNode).scrollIntoView();\n                return tr.setSelection(TextSelection.create(tr.doc, start + 3));\n            }),\n        ],\n        commands: (_, ctx) => [\n            createCmd(PrevCell, () => goToNextCell(-1)),\n            createCmd(NextCell, () => goToNextCell(1)),\n            createCmd(BreakTable, () => exitTable(ctx.get(schemaCtx).nodes['paragraph'] as NodeType)),\n            createCmd(InsertTable, () => (state, dispatch) => {\n                const { selection, tr } = state;\n                const { from } = selection;\n                const table = createTable(ctx.get(schemaCtx));\n                const _tr = tr.replaceSelectionWith(table);\n                const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true);\n                if (sel) {\n                    dispatch?.(_tr.setSelection(sel));\n                }\n                return true;\n            }),\n        ],\n        shortcuts: {\n            [SupportedKeys.NextCell]: createShortcut(NextCell, 'Mod-]'),\n            [SupportedKeys.PrevCell]: createShortcut(PrevCell, 'Mod-['),\n            [SupportedKeys.ExitTable]: createShortcut(BreakTable, 'Mod-Enter'),\n        },\n        prosePlugins: (_, ctx) => {\n            return [operatorPlugin(ctx, utils), autoInsertZeroSpace(), columnResizing(), tableEditing()];\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { SupportedKeys as CommonmarkKeys } from '@milkdown/preset-commonmark';\n\nimport { SupportedKeys as TableKeys } from './table';\n\nexport const SupportedKeys = {\n    ...CommonmarkKeys,\n    ...TableKeys,\n    StrikeThrough: 'StrikeThrough',\n    TaskList: 'TaskList',\n} as const;\nexport type SupportedKeys = typeof SupportedKeys;\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { toggleMark } from '@milkdown/prose/commands';\nimport { createMark, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from './supported-keys';\n\ntype Keys = SupportedKeys['StrikeThrough'];\n\nexport const ToggleStrikeThrough = createCmdKey('ToggleStrikeThrough');\n\nconst id = 'strike_through';\nexport const strikeThrough = createMark<Keys>((utils) => {\n    return {\n        id,\n        schema: () => ({\n            inclusive: false,\n            parseDOM: [\n                { tag: 'del' },\n                { style: 'text-decoration', getAttrs: (value) => (value === 'line-through') as false },\n            ],\n            toDOM: (mark) => ['del', { class: utils.getClassName(mark.attrs, 'strike-through') }],\n            parseMarkdown: {\n                match: (node) => node.type === 'delete',\n                runner: (state, node, markType) => {\n                    state.openMark(markType);\n                    state.next(node.children);\n                    state.closeMark(markType);\n                },\n            },\n            toMarkdown: {\n                match: (mark) => mark.type.name === id,\n                runner: (state, mark) => {\n                    state.withMark(mark, 'delete');\n                },\n            },\n        }),\n        commands: (markType) => [createCmd(ToggleStrikeThrough, () => toggleMark(markType))],\n        shortcuts: {\n            [SupportedKeys.StrikeThrough]: createShortcut(ToggleStrikeThrough, 'Mod-Alt-x'),\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey, editorViewCtx, ThemeTaskListItemType } from '@milkdown/core';\nimport { expectDomTypeError } from '@milkdown/exception';\nimport { wrapIn } from '@milkdown/prose/commands';\nimport { wrappingInputRule } from '@milkdown/prose/inputrules';\nimport { liftListItem, sinkListItem, splitListItem } from '@milkdown/prose/schema-list';\nimport { NodeView } from '@milkdown/prose/view';\nimport { createNode, createShortcut } from '@milkdown/utils';\n\nimport { SupportedKeys } from './supported-keys';\n\ntype Keys = Extract<keyof SupportedKeys, 'SinkListItem' | 'LiftListItem' | 'NextListItem' | 'TaskList'>;\n\nexport const SplitTaskListItem = createCmdKey('SplitTaskListItem');\nexport const SinkTaskListItem = createCmdKey('SinkTaskListItem');\nexport const LiftTaskListItem = createCmdKey('LiftTaskListItem');\nexport const TurnIntoTaskList = createCmdKey('TurnIntoTaskList');\n\nexport const taskListItem = createNode<Keys>((utils) => {\n    const id = 'task_list_item';\n\n    return {\n        id,\n        schema: (ctx) => ({\n            group: 'listItem',\n            content: 'paragraph block*',\n            defining: true,\n            priority: 60,\n            attrs: {\n                checked: {\n                    default: false,\n                },\n            },\n            parseDOM: [\n                {\n                    tag: 'li[data-type=\"task-item\"]',\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw expectDomTypeError(dom);\n                        }\n                        return { checked: dom.dataset['checked'] === 'true' };\n                    },\n                },\n            ],\n            toDOM: (node) => {\n                const checkbox = document.createElement('input');\n                checkbox.type = 'checkbox';\n                checkbox.checked = node.attrs['checked'];\n                checkbox.className = utils.getClassName(node.attrs, 'task-list-item_checkbox');\n                checkbox.onchange = (event) => {\n                    const target = event.target;\n                    if (!(target instanceof HTMLInputElement)) return;\n                    const view = ctx.get(editorViewCtx);\n\n                    if (!view.editable) {\n                        checkbox.checked = !checkbox.checked;\n\n                        return;\n                    }\n\n                    const { top, left } = target.getBoundingClientRect();\n                    const result = view.posAtCoords({ top, left });\n                    if (!result) return;\n\n                    const { tr } = view.state;\n\n                    view.dispatch(\n                        tr.setNodeMarkup(result.inside, undefined, {\n                            checked: target.checked,\n                        }),\n                    );\n                };\n                return [\n                    'li',\n                    {\n                        'data-type': 'task-item',\n                        'data-checked': node.attrs['checked'] ? 'true' : 'false',\n                        class: utils.getClassName(node.attrs, 'task-list-item'),\n                    },\n                    checkbox,\n                    ['span', { class: utils.getClassName(node.attrs, 'task-list-item_body') }, 0],\n                ];\n            },\n            parseMarkdown: {\n                match: ({ type, checked }) => {\n                    return type === 'listItem' && checked !== null;\n                },\n                runner: (state, node, type) => {\n                    state.openNode(type, { checked: node['checked'] as boolean });\n                    state.next(node.children);\n                    state.closeNode();\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    state.openNode('listItem', undefined, { checked: node.attrs['checked'] });\n                    state.next(node.content);\n                    state.closeNode();\n                },\n            },\n        }),\n        inputRules: (nodeType) => [\n            wrappingInputRule(/^\\s*(\\[([ |x])\\])\\s$/, nodeType, (match) => ({\n                checked: match[match.length - 1] === 'x',\n            })),\n        ],\n        commands: (nodeType) => [\n            createCmd(SplitTaskListItem, () => splitListItem(nodeType)),\n            createCmd(SinkTaskListItem, () => sinkListItem(nodeType)),\n            createCmd(LiftTaskListItem, () => liftListItem(nodeType)),\n            createCmd(TurnIntoTaskList, () => wrapIn(nodeType)),\n        ],\n        shortcuts: {\n            [SupportedKeys.NextListItem]: createShortcut(SplitTaskListItem, 'Enter'),\n            [SupportedKeys.SinkListItem]: createShortcut(SinkTaskListItem, 'Mod-]'),\n            [SupportedKeys.LiftListItem]: createShortcut(LiftTaskListItem, 'Mod-['),\n            [SupportedKeys.TaskList]: createShortcut(TurnIntoTaskList, 'Mod-Alt-9'),\n        },\n        view: () => (node, view, getPos) => {\n            let currNode = node;\n\n            const renderer = utils.themeManager.get<ThemeTaskListItemType>('task-list-item', {\n                editable: () => view.editable,\n                onChange: (selected) => {\n                    const { tr } = view.state;\n                    view.dispatch(\n                        tr.setNodeMarkup(getPos(), undefined, {\n                            checked: selected,\n                        }),\n                    );\n                },\n            });\n\n            if (!renderer) return {} as NodeView;\n\n            const { dom, contentDOM, onUpdate } = renderer;\n            onUpdate(currNode);\n\n            return {\n                dom,\n                contentDOM,\n                update: (updatedNode) => {\n                    if (updatedNode.type.name !== id) return false;\n\n                    currNode = updatedNode;\n                    onUpdate(currNode);\n\n                    return true;\n                },\n            };\n        },\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { commands as commonmarkCommands, commonmark } from '@milkdown/preset-commonmark';\nimport { $remark, AtomList } from '@milkdown/utils';\nimport remarkGFM from 'remark-gfm';\n\nimport { footnoteReference } from './footnote';\nimport { footnoteDefinition } from './footnote/definition';\nimport { strikeThrough, ToggleStrikeThrough } from './strike-through';\nimport { table } from './table';\nimport {\n    LiftTaskListItem,\n    SinkTaskListItem,\n    SplitTaskListItem,\n    taskListItem,\n    TurnIntoTaskList,\n} from './task-list-item';\n\nexport * from './footnote';\nexport * from './strike-through';\nexport { SupportedKeys } from './supported-keys';\nexport {\n    BreakTable,\n    // command\n    createTable,\n    InsertTable,\n    NextCell,\n    PrevCell,\n    // gather\n    table,\n} from './table';\nexport * from './task-list-item';\nexport {\n    blockquote,\n    bulletList,\n    codeFence,\n    codeInline,\n    commonmark,\n    // gather\n    commonmarkNodes,\n    commonmarkPlugins,\n    // node\n    doc,\n    em,\n    HardbreakFilterPluginKey as hardbreak,\n    heading,\n    hr,\n    image,\n    // command\n    InsertHardbreak,\n    InsertHr,\n    InsertImage,\n    LiftListItem,\n    link,\n    listItem,\n    ModifyImage,\n    ModifyLink,\n    orderedList,\n    paragraph,\n    SinkListItem,\n    SplitListItem,\n    strong,\n    text,\n    ToggleBold,\n    ToggleInlineCode,\n    ToggleItalic,\n    ToggleLink,\n    TurnIntoCodeFence,\n    TurnIntoHeading,\n    TurnIntoText,\n    WrapInBlockquote,\n    WrapInBulletList,\n    WrapInOrderedList,\n} from '@milkdown/preset-commonmark';\n\nexport const gfm = AtomList.create([\n    ...commonmark,\n    $remark(() => remarkGFM),\n    table(),\n    strikeThrough(),\n    taskListItem(),\n    footnoteReference(),\n    footnoteDefinition(),\n]);\n\nexport const commands = {\n    ...commonmarkCommands,\n    ToggleStrikeThrough,\n    TurnIntoTaskList,\n    SinkTaskListItem,\n    LiftTaskListItem,\n    SplitTaskListItem,\n} as const;\nexport type Commands = typeof commands;\n"],"names":["key","handleMouseDown","SupportedKeys","CommonmarkKeys","TableKeys","commonmarkCommands"],"mappings":"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"}