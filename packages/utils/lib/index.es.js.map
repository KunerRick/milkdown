{"version":3,"file":"index.es.js","sources":["../src/atom/atom-list.ts","../src/composable/utils.ts","../src/composable/$command.ts","../src/composable/$inputRule.ts","../src/composable/$mark.ts","../src/composable/$node.ts","../src/composable/$prose.ts","../src/composable/$remark.ts","../src/composable/$shortcut.ts","../src/composable/$view.ts","../src/factory/common.ts","../src/pipe.ts","../src/factory/pieces.ts","../src/factory/pipeline.ts","../src/factory/create-mark.ts","../src/factory/create-node.ts","../src/factory/create-plugin.ts","../src/macro/call-command.ts","../src/macro/destroy.ts","../src/macro/force-update.ts","../src/macro/get-html.ts","../src/macro/get-markdown.ts","../src/macro/insert.ts","../src/macro/outline.ts","../src/macro/replace-all.ts","../src/macro/set-attr.ts","../src/macro/switch-theme.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\n\nimport { MilkdownPlugin } from '@milkdown/core';\n\nimport { AddMetadata, Metadata } from '../types';\n\nexport type MilkdownPluginWithMetadata = MilkdownPlugin & Metadata;\nexport type AtomPlugin = MilkdownPlugin | MilkdownPluginWithMetadata;\n\nconst hasMetadata = (x: AtomPlugin): x is MilkdownPluginWithMetadata =>\n    Object.prototype.hasOwnProperty.call(x, 'origin');\n\nexport class AtomList<T extends AtomPlugin = AtomPlugin> extends Array<T> {\n    private findThenRun<U extends AddMetadata>(target: U, callback: (index: number) => void): this {\n        const index = this.findIndex((x) => hasMetadata(x) && x.origin === target);\n        if (index < 0) return this;\n\n        callback(index);\n\n        return this;\n    }\n\n    configure<U extends AddMetadata>(target: U, config: Parameters<U>[0]): this {\n        return this.findThenRun(target, (index) => {\n            this.splice(index, 1, target(config) as T);\n        });\n    }\n\n    replace<U extends AddMetadata, Next extends AtomPlugin>(target: U, next: Next): this {\n        return this.findThenRun(target, (index) => {\n            this.splice(index, 1, next as AtomPlugin as T);\n        });\n    }\n\n    remove<U extends AddMetadata>(target: U): this {\n        return this.findThenRun(target, (index) => {\n            this.splice(index, 1);\n        });\n    }\n\n    headless(): this {\n        this.filter(hasMetadata).forEach((x) => {\n            this.configure((x as MilkdownPluginWithMetadata).origin as AddMetadata, { headless: true });\n        });\n        return this;\n    }\n\n    static create<T extends AtomPlugin = AtomPlugin>(from: T[]): AtomList<T> {\n        return new AtomList(...from);\n    }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createTimer, Ctx, MilkdownPlugin, Slice, Timer } from '@milkdown/core';\nimport { customAlphabet } from 'nanoid';\n\nexport const nanoid = customAlphabet('abcedfghicklmn', 10);\n\nexport const addTimer = <T extends MilkdownPlugin, PluginWithTimer extends T = T & { timer: Timer }>(\n    runner: (ctx: Ctx, plugin: PluginWithTimer, done: () => void) => Promise<void>,\n    injectTo: Slice<Timer[], string>,\n    timerName?: string,\n): PluginWithTimer => {\n    const timer = createTimer(timerName || nanoid());\n    let doneCalled = false;\n\n    const plugin: MilkdownPlugin = () => {\n        return async (ctx) => {\n            const done = () => {\n                ctx.done(timer);\n                doneCalled = true;\n            };\n            ctx.update(injectTo, (x) => x.concat(timer));\n\n            await runner(ctx, <PluginWithTimer>plugin, done);\n\n            if (!doneCalled) {\n                ctx.done(timer);\n            }\n        };\n    };\n    (<T & { timer: Timer }>plugin).timer = timer;\n\n    return <PluginWithTimer>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { CmdKey, CmdTuple, commandsCtx, commandsTimerCtx, Ctx, MilkdownPlugin, SchemaReady } from '@milkdown/core';\n\nimport { addTimer } from './utils';\n\nexport type $Command<T> = MilkdownPlugin & {\n    run: (payload?: T) => boolean;\n    key: CmdKey<T>;\n};\n\nexport const $command = <T>(cmd: (ctx: Ctx) => CmdTuple<T>): $Command<T> => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const [key, command] = cmd(ctx);\n        ctx.get(commandsCtx).create(key, command);\n        (<$Command<T>>plugin).run = (payload?: T) => ctx.get(commandsCtx).call(key, payload);\n        (<$Command<T>>plugin).key = key;\n    };\n\n    return <$Command<T>>plugin;\n};\n\nexport const $commandAsync = <T>(cmd: (ctx: Ctx) => Promise<CmdTuple<T>>, timerName?: string) => {\n    return addTimer<$Command<T>>(\n        async (ctx, plugin) => {\n            await ctx.wait(SchemaReady);\n            const [key, command] = await cmd(ctx);\n            ctx.get(commandsCtx).create(key, command);\n            (<$Command<T>>plugin).run = (payload?: T) => ctx.get(commandsCtx).call(key, payload);\n            (<$Command<T>>plugin).key = key;\n        },\n        commandsTimerCtx,\n        timerName,\n    );\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, editorStateTimerCtx, inputRulesCtx, MilkdownPlugin, SchemaReady } from '@milkdown/core';\nimport { InputRule } from '@milkdown/prose/inputrules';\n\nimport { addTimer } from './utils';\n\nexport type $InputRule = MilkdownPlugin & {\n    inputRule: InputRule;\n};\n\nexport const $inputRule = (inputRule: (ctx: Ctx) => InputRule): $InputRule => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const ir = inputRule(ctx);\n        ctx.update(inputRulesCtx, (irs) => [...irs, ir]);\n        (<$InputRule>plugin).inputRule = ir;\n    };\n\n    return <$InputRule>plugin;\n};\n\nexport const $inputRuleAsync = (inputRule: (ctx: Ctx) => Promise<InputRule>, timerName?: string) => {\n    return addTimer<$InputRule>(\n        async (ctx, plugin) => {\n            await ctx.wait(SchemaReady);\n            const ir = await inputRule(ctx);\n            ctx.update(inputRulesCtx, (irs) => [...irs, ir]);\n            plugin.inputRule = ir;\n        },\n        editorStateTimerCtx,\n        timerName,\n    );\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport {\n    Ctx,\n    MarkSchema,\n    marksCtx,\n    MilkdownPlugin,\n    schemaCtx,\n    SchemaReady,\n    schemaTimerCtx,\n    ThemeReady,\n} from '@milkdown/core';\nimport { missingMarkInSchema } from '@milkdown/exception';\nimport { MarkType } from '@milkdown/prose/model';\n\nimport { addTimer } from './utils';\n\nexport type $Mark = MilkdownPlugin & {\n    id: string;\n    type: MarkType;\n    schema: MarkSchema;\n};\n\nexport const $mark = (id: string, schema: (ctx: Ctx) => MarkSchema): $Mark => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(ThemeReady);\n        const markSchema = schema(ctx);\n        ctx.update(marksCtx, (ns) => [...ns, [id, markSchema] as [string, MarkSchema]]);\n\n        (<$Mark>plugin).id = id;\n        (<$Mark>plugin).schema = markSchema;\n\n        await ctx.wait(SchemaReady);\n\n        const markType = ctx.get(schemaCtx).marks[id];\n\n        if (!markType) {\n            throw missingMarkInSchema(id);\n        }\n\n        (<$Mark>plugin).type = markType;\n    };\n\n    return <$Mark>plugin;\n};\n\nexport const $markAsync = (id: string, schema: (ctx: Ctx) => Promise<MarkSchema>, timerName?: string) => {\n    return addTimer<$Mark>(\n        async (ctx, plugin, done) => {\n            await ctx.wait(ThemeReady);\n            const markSchema = await schema(ctx);\n            ctx.update(marksCtx, (ns) => [...ns, [id, markSchema] as [string, MarkSchema]]);\n\n            plugin.id = id;\n            plugin.schema = markSchema;\n            done();\n\n            await ctx.wait(SchemaReady);\n\n            const markType = ctx.get(schemaCtx).marks[id];\n            if (!markType) {\n                throw missingMarkInSchema(id);\n            }\n\n            plugin.type = markType;\n        },\n        schemaTimerCtx,\n        timerName,\n    );\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport {\n    Ctx,\n    MilkdownPlugin,\n    NodeSchema,\n    nodesCtx,\n    schemaCtx,\n    SchemaReady,\n    schemaTimerCtx,\n    ThemeReady,\n} from '@milkdown/core';\nimport { missingNodeInSchema } from '@milkdown/exception';\nimport { NodeType } from '@milkdown/prose/model';\n\nimport { addTimer } from './utils';\n\nexport type $Node = MilkdownPlugin & {\n    id: string;\n    type: NodeType;\n    schema: NodeSchema;\n};\n\nexport const $node = (id: string, schema: (ctx: Ctx) => NodeSchema): $Node => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(ThemeReady);\n        const nodeSchema = schema(ctx);\n        ctx.update(nodesCtx, (ns) => [...ns, [id, nodeSchema] as [string, NodeSchema]]);\n\n        (<$Node>plugin).id = id;\n        (<$Node>plugin).schema = nodeSchema;\n\n        await ctx.wait(SchemaReady);\n\n        const nodeType = ctx.get(schemaCtx).nodes[id];\n\n        if (!nodeType) {\n            throw missingNodeInSchema(id);\n        }\n\n        (<$Node>plugin).type = nodeType;\n    };\n\n    return <$Node>plugin;\n};\n\nexport const $nodeAsync = (id: string, schema: (ctx: Ctx) => Promise<NodeSchema>, timerName?: string) => {\n    return addTimer<$Node>(\n        async (ctx, plugin, done) => {\n            await ctx.wait(ThemeReady);\n            const nodeSchema = await schema(ctx);\n            ctx.update(nodesCtx, (ns) => [...ns, [id, nodeSchema] as [string, NodeSchema]]);\n\n            plugin.id = id;\n            plugin.schema = nodeSchema;\n            done();\n\n            await ctx.wait(SchemaReady);\n\n            const nodeType = ctx.get(schemaCtx).nodes[id];\n\n            if (!nodeType) {\n                throw missingNodeInSchema(id);\n            }\n\n            plugin.type = nodeType;\n        },\n        schemaTimerCtx,\n        timerName,\n    );\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, editorStateTimerCtx, MilkdownPlugin, prosePluginsCtx, SchemaReady } from '@milkdown/core';\nimport { Plugin } from '@milkdown/prose/state';\n\nimport { addTimer } from './utils';\n\nexport type $Prose = MilkdownPlugin & {\n    plugin: Plugin;\n};\n\nexport const $prose = (prose: (ctx: Ctx) => Plugin): $Prose => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const prosePlugin = prose(ctx);\n        ctx.update(prosePluginsCtx, (ps) => [...ps, prosePlugin]);\n        (<$Prose>plugin).plugin = prosePlugin;\n    };\n\n    return <$Prose>plugin;\n};\n\nexport const $proseAsync = (prose: (ctx: Ctx) => Promise<Plugin>, timerName?: string) => {\n    return addTimer<$Prose>(\n        async (ctx, plugin) => {\n            await ctx.wait(SchemaReady);\n            const prosePlugin = await prose(ctx);\n            ctx.update(prosePluginsCtx, (ps) => [...ps, prosePlugin]);\n            plugin.plugin = prosePlugin;\n        },\n        editorStateTimerCtx,\n        timerName,\n    );\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, InitReady, MilkdownPlugin, RemarkPlugin, remarkPluginsCtx, schemaTimerCtx } from '@milkdown/core';\n\nimport { addTimer } from './utils';\n\nexport type $Remark = MilkdownPlugin & {\n    plugin: RemarkPlugin;\n};\n\nexport const $remark = (remark: (ctx: Ctx) => RemarkPlugin): $Remark => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(InitReady);\n        const re = remark(ctx);\n        ctx.update(remarkPluginsCtx, (rp) => [...rp, re]);\n        (<$Remark>plugin).plugin = re;\n    };\n\n    return <$Remark>plugin;\n};\n\nexport const $remarkAsync = (remark: (ctx: Ctx) => Promise<RemarkPlugin>, timerName?: string) =>\n    addTimer<$Remark>(\n        async (ctx, plugin) => {\n            await ctx.wait(InitReady);\n            const re = await remark(ctx);\n            ctx.update(remarkPluginsCtx, (rp) => [...rp, re]);\n            plugin.plugin = re;\n        },\n        schemaTimerCtx,\n        timerName,\n    );\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, editorStateTimerCtx, MilkdownPlugin, prosePluginsCtx, SchemaReady } from '@milkdown/core';\nimport { keymap } from '@milkdown/prose/keymap';\nimport { Command } from '@milkdown/prose/state';\n\nimport { addTimer } from './utils';\n\ntype Keymap = Record<string, Command>;\n\nexport type $Shortcut = MilkdownPlugin & {\n    keymap: Keymap;\n};\n\nexport const $shortcut = (shortcut: (ctx: Ctx) => Keymap): $Shortcut => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const k = shortcut(ctx);\n        ctx.update(prosePluginsCtx, (ps) => [...ps, keymap(k)]);\n        (<$Shortcut>plugin).keymap = k;\n    };\n\n    return <$Shortcut>plugin;\n};\n\nexport const $shortcutAsync = (shortcut: (ctx: Ctx) => Promise<Keymap>, timerName?: string) =>\n    addTimer<$Shortcut>(\n        async (ctx, plugin) => {\n            await ctx.wait(SchemaReady);\n            const k = await shortcut(ctx);\n            ctx.update(prosePluginsCtx, (ps) => [...ps, keymap(k)]);\n            plugin.keymap = k;\n        },\n        editorStateTimerCtx,\n        timerName,\n    );\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, editorViewTimerCtx, markViewCtx, MilkdownPlugin, nodeViewCtx, SchemaReady } from '@milkdown/core';\nimport { NodeType } from '@milkdown/prose/model';\nimport { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view';\n\nimport { $Mark, $Node } from '.';\nimport { addTimer } from './utils';\n\nexport type $View<T extends $Node | $Mark, V extends NodeViewConstructor | MarkViewConstructor> = MilkdownPlugin & {\n    view: V;\n    type: T;\n};\n\nexport const $view = <\n    T extends $Node | $Mark,\n    V extends NodeViewConstructor | MarkViewConstructor = T extends $Node\n        ? NodeViewConstructor\n        : T extends $Mark\n        ? MarkViewConstructor\n        : NodeViewConstructor | MarkViewConstructor,\n>(\n    type: T,\n    view: (ctx: Ctx) => V,\n): $View<T, V> => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const v = view(ctx);\n        if (type.type instanceof NodeType) {\n            ctx.update(nodeViewCtx, (ps) => [...ps, [type.id, v] as [string, NodeViewConstructor]]);\n        } else {\n            ctx.update(markViewCtx, (ps) => [...ps, [type.id, v] as [string, MarkViewConstructor]]);\n        }\n        (<$View<T, V>>plugin).view = v;\n        (<$View<T, V>>plugin).type = type;\n    };\n\n    return <$View<T, V>>plugin;\n};\n\nexport const $viewAsync = <\n    T extends $Node | $Mark,\n    V extends NodeViewConstructor | MarkViewConstructor = T extends $Node\n        ? NodeViewConstructor\n        : T extends $Mark\n        ? MarkViewConstructor\n        : NodeViewConstructor | MarkViewConstructor,\n>(\n    type: T,\n    view: (ctx: Ctx) => Promise<V>,\n    timerName?: string,\n) =>\n    addTimer<$View<T, V>>(\n        async (ctx, plugin) => {\n            await ctx.wait(SchemaReady);\n            const v = await view(ctx);\n            if (type.type instanceof NodeType) {\n                ctx.update(nodeViewCtx, (ps) => [...ps, [type.id, v] as [string, NodeViewConstructor]]);\n            } else {\n                ctx.update(markViewCtx, (ps) => [...ps, [type.id, v] as [string, MarkViewConstructor]]);\n            }\n            plugin.view = v;\n            plugin.type = type;\n        },\n        editorViewTimerCtx,\n        timerName,\n    );\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Attrs, CmdKey, Ctx, emotionCtx, Slice, themeManagerCtx } from '@milkdown/core';\nimport { themeMustInstalled } from '@milkdown/exception';\n\nimport {\n    AddMetadata,\n    CommandConfig,\n    CommonOptions,\n    Factory,\n    GetPlugin,\n    ThemeUtils,\n    UnknownRecord,\n    WithExtend,\n} from '../types';\n\nexport const getClassName =\n    (className: CommonOptions['className']) =>\n    (attrs: Attrs, ...defaultValue: (string | null | undefined)[]): string => {\n        const classList = className?.(attrs, ...defaultValue) ?? defaultValue;\n        return Array.isArray(classList) ? classList.filter((x) => x).join(' ') : classList;\n    };\n\nexport const createShortcut = <T>(commandKey: CmdKey<T>, defaultKey: string | string[], args?: T) =>\n    [commandKey, defaultKey, args] as CommandConfig<unknown>;\n\nexport const getThemeUtils = <Options extends UnknownRecord>(ctx: Ctx, options?: Options): ThemeUtils => {\n    try {\n        const themeManager = ctx.get(themeManagerCtx);\n        const emotion = ctx.get(emotionCtx);\n        if (!emotion.css) {\n            throw themeMustInstalled();\n        }\n\n        return {\n            getClassName: getClassName(options?.['className'] as undefined),\n            getStyle: (style) => (options?.['headless'] ? '' : (style(emotion) as string | undefined)),\n            themeManager,\n        };\n    } catch {\n        throw themeMustInstalled();\n    }\n};\n\n/**\n * @deprecated Use `getThemeUtils` instead.\n */\nexport const getUtils = getThemeUtils;\n\nexport const addMetadata = <SupportedKeys extends string = string, Options extends UnknownRecord = UnknownRecord>(\n    x: GetPlugin<SupportedKeys, Options>,\n): AddMetadata<SupportedKeys, Options> => {\n    const fn: AddMetadata<SupportedKeys, Options> = (options) => {\n        const result = x(options) as ReturnType<AddMetadata<SupportedKeys, Options>>;\n        result.origin = fn;\n        return result;\n    };\n    return fn;\n};\n\nexport const withExtend =\n    <SupportedKeys extends string, Options extends UnknownRecord, Type, Rest>(\n        factory: Factory<SupportedKeys, Options, Type, Rest>,\n        creator: (\n            factory: Factory<SupportedKeys, Options, Type, Rest>,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            inject?: Slice<any>[],\n        ) => WithExtend<SupportedKeys, Options, Type, Rest>,\n    ) =>\n    (origin: AddMetadata<SupportedKeys, Options>): WithExtend<SupportedKeys, Options, Type, Rest> => {\n        type Ext = WithExtend<SupportedKeys, Options, Type, Rest>;\n        const next = origin as Ext;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const extend = (extendFactory: Parameters<Ext['extend']>[0], inject?: Slice<any>[]) =>\n            creator((...args) => extendFactory(factory(...args), ...args), inject);\n\n        next.extend = extend as Ext['extend'];\n\n        return next;\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type Many<T> = T | ReadonlyArray<T>;\n\ninterface Pipe {\n    pipe<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n        f1: (...args: A) => R1,\n        f2: (a: R1) => R2,\n        f3: (a: R2) => R3,\n        f4: (a: R3) => R4,\n        f5: (a: R4) => R5,\n        f6: (a: R5) => R6,\n        f7: (a: R6) => R7,\n    ): (...args: A) => R7;\n    pipe<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n        f1: (...args: A) => R1,\n        f2: (a: R1) => R2,\n        f3: (a: R2) => R3,\n        f4: (a: R3) => R4,\n        f5: (a: R4) => R5,\n        f6: (a: R5) => R6,\n        f7: (a: R6) => R7,\n        ...func: Array<Many<(a: any) => any>>\n    ): (...args: A) => any;\n    pipe<A extends any[], R1, R2, R3, R4, R5, R6>(\n        f1: (...args: A) => R1,\n        f2: (a: R1) => R2,\n        f3: (a: R2) => R3,\n        f4: (a: R3) => R4,\n        f5: (a: R4) => R5,\n        f6: (a: R5) => R6,\n    ): (...args: A) => R6;\n    pipe<A extends any[], R1, R2, R3, R4, R5>(\n        f1: (...args: A) => R1,\n        f2: (a: R1) => R2,\n        f3: (a: R2) => R3,\n        f4: (a: R3) => R4,\n        f5: (a: R4) => R5,\n    ): (...args: A) => R5;\n    pipe<A extends any[], R1, R2, R3, R4>(\n        f1: (...args: A) => R1,\n        f2: (a: R1) => R2,\n        f3: (a: R2) => R3,\n        f4: (a: R3) => R4,\n    ): (...args: A) => R4;\n    pipe<A extends any[], R1, R2, R3>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (...args: A) => R3;\n    pipe<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;\n    pipe(...func: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n}\n\nexport const pipe: Pipe['pipe'] = (...funcs: any[]) => {\n    const length = funcs.length;\n    let index = length;\n    while (index--) {\n        if (typeof funcs[index] !== 'function') {\n            throw new TypeError('Expected a function');\n        }\n    }\n    return (...args: any[]) => {\n        let index = 0;\n        let result = length ? funcs[index](...args) : args[0];\n        while (++index < length) {\n            result = funcs[index](result);\n        }\n        return result;\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport {\n    CmdTuple,\n    commandsCtx,\n    createSlice,\n    Ctx,\n    InitReady,\n    inputRulesCtx,\n    MarkSchema,\n    marksCtx,\n    markViewCtx,\n    NodeSchema,\n    nodesCtx,\n    nodeViewCtx,\n    prosePluginsCtx,\n    RemarkPlugin,\n    remarkPluginsCtx,\n    schemaCtx,\n    SchemaReady,\n    ThemeReady,\n} from '@milkdown/core';\nimport { InputRule } from '@milkdown/prose/inputrules';\nimport { keymap } from '@milkdown/prose/keymap';\nimport { MarkType, NodeType } from '@milkdown/prose/model';\nimport { Plugin } from '@milkdown/prose/state';\nimport { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view';\n\nimport { AnySlice, CommandConfig, CommonOptions } from '../types';\nimport { Pipeline } from './pipeline';\n\nexport type UserSchema = (ctx: Ctx) => {\n    node?: Record<string, NodeSchema>;\n    mark?: Record<string, MarkSchema>;\n};\n\nexport type PluginType = Record<string, NodeType | MarkType>;\n\nexport type PluginView = Record<string, NodeViewConstructor | MarkViewConstructor>;\n\ntype Maybe<T> = T | undefined;\n\nexport const injectSlices =\n    (inject?: AnySlice[]): Pipeline =>\n    async (env, next) => {\n        inject?.forEach((slice) => env.pre.inject(slice));\n        await next();\n    };\n\nexport const waitThemeReady: Pipeline = async (env, next) => {\n    const { ctx } = env;\n    await ctx.wait(ThemeReady);\n\n    await next();\n};\n\nexport const getRemarkPluginsPipeCtx = createSlice<Maybe<(ctx: Ctx) => RemarkPlugin[]>>(\n    undefined,\n    'getRemarkPluginsPipeCtx',\n);\nexport const applyRemarkPlugins: Pipeline = async (env, next) => {\n    const { ctx, pipelineCtx } = env;\n\n    await ctx.wait(InitReady);\n\n    const remarkPlugins = pipelineCtx.get(getRemarkPluginsPipeCtx);\n\n    if (remarkPlugins) {\n        const plugins = remarkPlugins(ctx);\n\n        ctx.update(remarkPluginsCtx, (ps) => ps.concat(plugins));\n    }\n\n    await next();\n};\n\nexport const getSchemaPipeCtx = createSlice<Maybe<UserSchema>>(undefined, 'getSchemaPipeCtx');\nexport const typePipeCtx = createSlice<PluginType, 'Type'>({} as PluginType, 'Type');\nexport const applySchema: Pipeline = async (env, next) => {\n    const { ctx, pipelineCtx } = env;\n\n    const getSchema = pipelineCtx.get(getSchemaPipeCtx);\n\n    const userSchema = getSchema?.(env.ctx) ?? {};\n\n    let node: Record<string, NodeSchema> = {};\n    let mark: Record<string, MarkSchema> = {};\n\n    if (userSchema.node) {\n        node = userSchema.node;\n        const nodes = Object.entries<NodeSchema>(userSchema.node);\n        ctx.update(nodesCtx, (ns) => [...ns, ...nodes]);\n    }\n\n    if (userSchema.mark) {\n        mark = userSchema.mark;\n        const marks = Object.entries<MarkSchema>(userSchema.mark);\n        ctx.update(marksCtx, (ms) => [...ms, ...marks]);\n    }\n\n    await ctx.wait(SchemaReady);\n\n    const schema = ctx.get(schemaCtx);\n    const nodeTypes = Object.keys(node).map((id) => [id, schema.nodes[id]] as const);\n    const markTypes = Object.keys(mark).map((id) => [id, schema.marks[id]] as const);\n\n    const type = Object.fromEntries([...nodeTypes, ...markTypes]);\n    pipelineCtx.set(typePipeCtx, type);\n\n    await next();\n};\n\nexport const getCommandsPipeCtx = createSlice<Maybe<(types: PluginType, ctx: Ctx) => CmdTuple[]>>(\n    undefined,\n    'getCommandsPipeCtx',\n);\nexport const createCommands: Pipeline = async (env, next) => {\n    const { ctx, pipelineCtx } = env;\n    const commands = pipelineCtx.get(getCommandsPipeCtx);\n    if (commands) {\n        const type = pipelineCtx.get(typePipeCtx);\n        commands(type, ctx).forEach(([key, command]) => {\n            ctx.get(commandsCtx).create(key, command);\n        });\n    }\n    await next();\n};\n\nexport const getInputRulesPipeCtx = createSlice<Maybe<(types: PluginType, ctx: Ctx) => InputRule[]>>(\n    undefined,\n    'getInputRulesPipeCtx',\n);\nexport const createInputRules: Pipeline = async (env, next) => {\n    const { ctx, pipelineCtx } = env;\n    const inputRules = pipelineCtx.get(getInputRulesPipeCtx);\n    if (inputRules) {\n        const type = pipelineCtx.get(typePipeCtx);\n        ctx.update(inputRulesCtx, (ir) => [...ir, ...inputRules(type, ctx)]);\n    }\n\n    await next();\n};\n\nexport const shortcutsPipeCtx = createSlice<Record<string, CommandConfig>>({}, 'shortcutsPipeCtx');\nexport const createShortcuts: Pipeline = async (env, next) => {\n    const { pipelineCtx, ctx } = env;\n\n    const shortcuts = pipelineCtx.get(shortcutsPipeCtx);\n\n    const options = pipelineCtx.get(optionsPipeCtx);\n    const getKey = (key: string, defaultValue: string | string[]): string | string[] => {\n        return options?.keymap?.[key] ?? defaultValue;\n    };\n\n    const tuples = Object.entries<CommandConfig>(shortcuts)\n        .flatMap(([id, [commandKey, defaultKey, args]]) => {\n            const runner = () => ctx.get(commandsCtx).call(commandKey, args);\n            const key = getKey(id, defaultKey);\n            if (Array.isArray(key)) {\n                return key.map((k) => ({ key: k, runner }));\n            }\n            return { key, runner };\n        })\n        .map((x) => [x.key, x.runner] as [string, () => boolean]);\n    ctx.update(prosePluginsCtx, (ps) => ps.concat(keymap(Object.fromEntries(tuples))));\n\n    await next();\n};\n\nexport const getProsePluginsPipeCtx = createSlice<Maybe<(types: PluginType, ctx: Ctx) => Plugin[]>>(\n    undefined,\n    'getProsePluginsPipeCtx',\n);\nexport const applyProsePlugins: Pipeline = async (env, next) => {\n    const { pipelineCtx, ctx } = env;\n\n    const prosePlugins = pipelineCtx.get(getProsePluginsPipeCtx);\n    if (prosePlugins) {\n        const type = pipelineCtx.get(typePipeCtx);\n        ctx.update(prosePluginsCtx, (ps) => [...ps, ...prosePlugins(type, ctx)]);\n    }\n\n    await next();\n};\n\nexport const getViewPipeCtx = createSlice<Maybe<(ctx: Ctx) => PluginView>>(undefined, 'getViewPipeCtx');\nexport const applyView: Pipeline = async (env, next) => {\n    const { pipelineCtx, ctx } = env;\n\n    const getView = pipelineCtx.get(getViewPipeCtx);\n\n    const options = pipelineCtx.get(optionsPipeCtx);\n\n    const view = options.view ? options.view(ctx) : getView?.(ctx);\n\n    if (view) {\n        const nodeViews = Object.entries(view).filter(\n            ([id]) => ctx.get(nodesCtx).findIndex((ns) => ns[0] === id) !== -1,\n        );\n        const markViews = Object.entries(view).filter(\n            ([id]) => ctx.get(marksCtx).findIndex((ns) => ns[0] === id) !== -1,\n        );\n        ctx.update(nodeViewCtx, (v) => [...v, ...(nodeViews as [string, NodeViewConstructor][])]);\n        ctx.update(markViewCtx, (v) => [...v, ...(markViews as [string, MarkViewConstructor][])]);\n    }\n\n    await next();\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type PluginOptions = Omit<CommonOptions<string, {}>, 'view'> & { view?: (ctx: Ctx) => PluginView };\nexport const optionsPipeCtx = createSlice<PluginOptions>({}, 'optionsPipeCtx');\n\nexport const idPipeCtx = createSlice('', 'idPipeCtx');\n\nexport const injectPipeEnv: Pipeline = async (env, next) => {\n    const { pipelineCtx } = env;\n    pipelineCtx\n        .inject(idPipeCtx)\n        .inject(optionsPipeCtx)\n        .inject(getRemarkPluginsPipeCtx)\n        .inject(getSchemaPipeCtx)\n        .inject(typePipeCtx)\n        .inject(getCommandsPipeCtx)\n        .inject(getInputRulesPipeCtx)\n        .inject(shortcutsPipeCtx)\n        .inject(getProsePluginsPipeCtx)\n        .inject(getViewPipeCtx);\n\n    await next();\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { createClock, createContainer, Ctx, Env, Pre } from '@milkdown/core';\n\nexport type PipelineEnv = {\n    readonly pre: Pre;\n    readonly ctx: Ctx;\n    readonly pipelineCtx: Env;\n};\n\nexport type Pipeline = (env: PipelineEnv, next: () => Promise<void>) => Promise<void>;\n\nconst runPipeline = (pipelines: Pipeline[]) => {\n    return (env: PipelineEnv, next?: Pipeline): Promise<void> => {\n        let index = -1;\n        const dispatch = (i: number): Promise<void> => {\n            if (i <= index) return Promise.reject(new Error('next() called multiple times'));\n            index = i;\n            let fn = pipelines[i];\n            if (i === pipelines.length) fn = next;\n            if (!fn) return Promise.resolve();\n            try {\n                return Promise.resolve(fn(env, () => dispatch(i + 1)));\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        };\n        return dispatch(0);\n    };\n};\n\nexport const run = (pipelines: Pipeline[]) => {\n    const runner = runPipeline(pipelines);\n    const container = createContainer();\n    const clock = createClock();\n    const pipelineCtx = new Env(container, clock);\n\n    return (pre: Pre, ctx: Ctx) =>\n        runner({\n            pre,\n            ctx,\n            pipelineCtx,\n        });\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, MarkSchema, MilkdownPlugin } from '@milkdown/core';\nimport { MarkType } from '@milkdown/prose/model';\nimport { MarkViewConstructor } from '@milkdown/prose/view';\n\nimport { pipe } from '../pipe';\nimport { AnySlice, CommonOptions, Factory, UnknownRecord, WithExtend } from '../types';\nimport { addMetadata, getThemeUtils, withExtend } from './common';\nimport {\n    applyProsePlugins,\n    applyRemarkPlugins,\n    applySchema,\n    applyView,\n    createCommands,\n    createInputRules,\n    createShortcuts,\n    getCommandsPipeCtx,\n    getInputRulesPipeCtx,\n    getProsePluginsPipeCtx,\n    getRemarkPluginsPipeCtx,\n    getSchemaPipeCtx,\n    getViewPipeCtx,\n    idPipeCtx,\n    injectPipeEnv,\n    injectSlices,\n    optionsPipeCtx,\n    shortcutsPipeCtx,\n    waitThemeReady,\n} from './pieces';\nimport { Pipeline, run } from './pipeline';\n\nexport type MarkRest = {\n    id: string;\n    schema: (ctx: Ctx) => MarkSchema;\n    view?: (ctx: Ctx) => MarkViewConstructor;\n};\n\nexport type MarkFactory<SupportedKeys extends string, Options extends UnknownRecord> = Factory<\n    SupportedKeys,\n    Options,\n    MarkType,\n    MarkRest\n>;\n\nexport type MarkCreator<SupportedKeys extends string, Options extends UnknownRecord> = WithExtend<\n    SupportedKeys,\n    Options,\n    MarkType,\n    MarkRest\n>;\n\nexport const createMark = <SupportedKeys extends string = string, Options extends UnknownRecord = UnknownRecord>(\n    factory: MarkFactory<SupportedKeys, Options>,\n    inject?: AnySlice[],\n): MarkCreator<string, Options> =>\n    pipe(\n        addMetadata,\n        withExtend(factory, createMark),\n    )(\n        (options?: Partial<CommonOptions<SupportedKeys, Options>>): MilkdownPlugin =>\n            (pre) =>\n            async (ctx) => {\n                const setPipelineEnv: Pipeline = async ({ pipelineCtx }, next) => {\n                    const utils = getThemeUtils(ctx, options);\n                    const plugin = factory(utils, options);\n\n                    const { id, commands, remarkPlugins, schema, inputRules, shortcuts, prosePlugins, view } = plugin;\n\n                    const pluginOptions = {\n                        ...(options || {}),\n                        view: options?.view\n                            ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                              (ctx: Ctx) => ({ [id]: options!.view!(ctx) })\n                            : undefined,\n                    };\n\n                    pipelineCtx.set(idPipeCtx, id);\n                    pipelineCtx.set(optionsPipeCtx, pluginOptions);\n                    pipelineCtx.set(getRemarkPluginsPipeCtx, remarkPlugins);\n                    pipelineCtx.set(getSchemaPipeCtx, (ctx) => ({ mark: { [id]: schema(ctx) } }));\n                    if (commands) {\n                        pipelineCtx.set(getCommandsPipeCtx, (type, ctx) => commands(type[id] as MarkType, ctx));\n                    }\n                    if (inputRules) {\n                        pipelineCtx.set(getInputRulesPipeCtx, (type, ctx) => inputRules(type[id] as MarkType, ctx));\n                    }\n                    if (shortcuts) {\n                        pipelineCtx.set(shortcutsPipeCtx, shortcuts);\n                    }\n                    if (prosePlugins) {\n                        pipelineCtx.set(getProsePluginsPipeCtx, (type, ctx) => prosePlugins(type[id] as MarkType, ctx));\n                    }\n                    if (view) {\n                        pipelineCtx.set(getViewPipeCtx, (ctx) => ({ [id]: view(ctx) }));\n                    }\n                    await next();\n                };\n\n                const runner = run([\n                    injectPipeEnv,\n                    injectSlices(inject),\n                    waitThemeReady,\n                    setPipelineEnv,\n                    applyRemarkPlugins,\n                    applySchema,\n                    createCommands,\n                    createInputRules,\n                    createShortcuts,\n                    applyProsePlugins,\n                    applyView,\n                ]);\n\n                await runner(pre, ctx);\n            },\n    );\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, MilkdownPlugin, NodeSchema } from '@milkdown/core';\nimport { NodeType } from '@milkdown/prose/model';\nimport { NodeViewConstructor } from '@milkdown/prose/view';\n\nimport { pipe } from '../pipe';\nimport { AnySlice, CommonOptions, Factory, UnknownRecord, WithExtend } from '../types';\nimport { addMetadata, getThemeUtils, withExtend } from './common';\nimport {\n    applyProsePlugins,\n    applyRemarkPlugins,\n    applySchema,\n    applyView,\n    createCommands,\n    createInputRules,\n    createShortcuts,\n    getCommandsPipeCtx,\n    getInputRulesPipeCtx,\n    getProsePluginsPipeCtx,\n    getRemarkPluginsPipeCtx,\n    getSchemaPipeCtx,\n    getViewPipeCtx,\n    idPipeCtx,\n    injectPipeEnv,\n    injectSlices,\n    optionsPipeCtx,\n    shortcutsPipeCtx,\n    waitThemeReady,\n} from './pieces';\nimport { Pipeline, run } from './pipeline';\n\nexport type NodeRest = {\n    id: string;\n    schema: (ctx: Ctx) => NodeSchema;\n    view?: (ctx: Ctx) => NodeViewConstructor;\n};\n\nexport type NodeFactory<SupportedKeys extends string, Options extends UnknownRecord> = Factory<\n    SupportedKeys,\n    Options,\n    NodeType,\n    NodeRest\n>;\n\nexport type NodeCreator<\n    SupportedKeys extends string = string,\n    Options extends UnknownRecord = UnknownRecord,\n> = WithExtend<SupportedKeys, Options, NodeType, NodeRest>;\n\nexport const createNode = <SupportedKeys extends string = string, Options extends UnknownRecord = UnknownRecord>(\n    factory: NodeFactory<SupportedKeys, Options>,\n    inject?: AnySlice[],\n): NodeCreator<SupportedKeys, Options> =>\n    pipe(\n        addMetadata,\n        withExtend(factory, createNode),\n    )(\n        (options?: Partial<CommonOptions<SupportedKeys, Options>>): MilkdownPlugin =>\n            (pre) =>\n            async (ctx) => {\n                const setPipelineEnv: Pipeline = async ({ pipelineCtx }, next) => {\n                    const utils = getThemeUtils(ctx, options);\n                    const plugin = factory(utils, options);\n\n                    const { id, commands, remarkPlugins, schema, inputRules, shortcuts, prosePlugins, view } = plugin;\n\n                    const pluginOptions = {\n                        ...(options || {}),\n                        view: options?.view\n                            ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                              (ctx: Ctx) => ({ [id]: options!.view!(ctx) })\n                            : undefined,\n                    };\n\n                    pipelineCtx.set(idPipeCtx, id);\n                    pipelineCtx.set(optionsPipeCtx, pluginOptions);\n                    pipelineCtx.set(getRemarkPluginsPipeCtx, remarkPlugins);\n                    pipelineCtx.set(getSchemaPipeCtx, (ctx) => ({ node: { [id]: schema(ctx) } }));\n                    if (commands) {\n                        pipelineCtx.set(getCommandsPipeCtx, (type, ctx) => commands(type[id] as NodeType, ctx));\n                    }\n                    if (inputRules) {\n                        pipelineCtx.set(getInputRulesPipeCtx, (type, ctx) => inputRules(type[id] as NodeType, ctx));\n                    }\n                    if (shortcuts) {\n                        pipelineCtx.set(shortcutsPipeCtx, shortcuts);\n                    }\n                    if (prosePlugins) {\n                        pipelineCtx.set(getProsePluginsPipeCtx, (type, ctx) => prosePlugins(type[id] as NodeType, ctx));\n                    }\n                    if (view) {\n                        pipelineCtx.set(getViewPipeCtx, (ctx) => ({ [id]: view(ctx) }));\n                    }\n                    await next();\n                };\n\n                const runner = run([\n                    injectPipeEnv,\n                    injectSlices(inject),\n                    waitThemeReady,\n                    setPipelineEnv,\n                    applyRemarkPlugins,\n                    applySchema,\n                    createCommands,\n                    createInputRules,\n                    createShortcuts,\n                    applyProsePlugins,\n                    applyView,\n                ]);\n\n                await runner(pre, ctx);\n            },\n    );\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, MarkSchema, MilkdownPlugin, NodeSchema } from '@milkdown/core';\nimport { MarkType, NodeType } from '@milkdown/prose/model';\nimport { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view';\n\nimport { pipe } from '../pipe';\nimport { AnySlice, CommonOptions, Factory, UnknownRecord, WithExtend } from '../types';\nimport { addMetadata, getThemeUtils, withExtend } from './common';\nimport {\n    applyProsePlugins,\n    applyRemarkPlugins,\n    applySchema,\n    applyView,\n    createCommands,\n    createInputRules,\n    createShortcuts,\n    getCommandsPipeCtx,\n    getInputRulesPipeCtx,\n    getProsePluginsPipeCtx,\n    getRemarkPluginsPipeCtx,\n    getSchemaPipeCtx,\n    getViewPipeCtx,\n    injectPipeEnv,\n    injectSlices,\n    optionsPipeCtx,\n    shortcutsPipeCtx,\n    waitThemeReady,\n} from './pieces';\nimport { Pipeline, run } from './pipeline';\n\nexport type TypeMapping<NodeKeys extends string, MarkKeys extends string> = {\n    [K in NodeKeys]: NodeType;\n} & {\n    [K in MarkKeys]: MarkType;\n};\n\nexport type ViewMapping<NodeKeys extends string, MarkKeys extends string> = {\n    [K in NodeKeys]: NodeViewConstructor;\n} & {\n    [K in MarkKeys]: MarkViewConstructor;\n};\n\nexport type PluginRest<NodeKeys extends string, MarkKeys extends string> = {\n    schema?: (ctx: Ctx) => {\n        node?: Record<NodeKeys, NodeSchema>;\n        mark?: Record<MarkKeys, MarkSchema>;\n    };\n    view?: (ctx: Ctx) => Partial<ViewMapping<NodeKeys, MarkKeys>>;\n};\nexport type PluginFactory<\n    SupportedKeys extends string = string,\n    Options extends UnknownRecord = UnknownRecord,\n    NodeKeys extends string = string,\n    MarkKeys extends string = string,\n> = Factory<SupportedKeys, Options, TypeMapping<NodeKeys, MarkKeys>, PluginRest<NodeKeys, MarkKeys>>;\n\nexport const createPlugin = <\n    SupportedKeys extends string = string,\n    Options extends UnknownRecord = UnknownRecord,\n    NodeKeys extends string = string,\n    MarkKeys extends string = string,\n>(\n    factory: PluginFactory<SupportedKeys, Options, NodeKeys, MarkKeys>,\n    inject?: AnySlice[],\n): WithExtend<SupportedKeys, Options, TypeMapping<NodeKeys, MarkKeys>, PluginRest<NodeKeys, MarkKeys>> =>\n    pipe(\n        addMetadata,\n        withExtend(factory, createPlugin),\n    )(\n        (options?: Partial<CommonOptions<SupportedKeys, Options>>): MilkdownPlugin =>\n            (pre) =>\n            async (ctx) => {\n                const setPipelineEnv: Pipeline = async ({ pipelineCtx }, next) => {\n                    const utils = getThemeUtils(ctx, options);\n                    const plugin = factory(utils, options);\n\n                    const { commands, remarkPlugins, schema, inputRules, shortcuts, prosePlugins, view } = plugin;\n\n                    pipelineCtx.set(optionsPipeCtx, (options || {}) as Options);\n                    pipelineCtx.set(getRemarkPluginsPipeCtx, remarkPlugins);\n                    if (schema) {\n                        pipelineCtx.set(getSchemaPipeCtx, schema);\n                    }\n                    if (commands) {\n                        pipelineCtx.set(getCommandsPipeCtx, commands as never);\n                    }\n                    if (inputRules) {\n                        pipelineCtx.set(getInputRulesPipeCtx, inputRules as never);\n                    }\n                    if (shortcuts) {\n                        pipelineCtx.set(shortcutsPipeCtx, shortcuts);\n                    }\n                    if (prosePlugins) {\n                        pipelineCtx.set(getProsePluginsPipeCtx, prosePlugins as never);\n                    }\n                    if (view) {\n                        pipelineCtx.set(getViewPipeCtx, view as never);\n                    }\n                    await next();\n                };\n\n                const runner = run([\n                    injectPipeEnv,\n                    injectSlices(inject),\n                    waitThemeReady,\n                    setPipelineEnv,\n                    applyRemarkPlugins,\n                    applySchema,\n                    createCommands,\n                    createInputRules,\n                    createShortcuts,\n                    applyProsePlugins,\n                    applyView,\n                ]);\n\n                await runner(pre, ctx);\n            },\n    );\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { CmdKey, commandsCtx, Ctx } from '@milkdown/core';\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never;\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function callCommand<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): (ctx: Ctx) => boolean;\nexport function callCommand<T>(slice: CmdKey<T>, payload?: T): (ctx: Ctx) => boolean;\nexport function callCommand(slice: string | CmdKey<any>, payload?: any): (ctx: Ctx) => boolean;\nexport function callCommand(slice: string | CmdKey<any>, payload?: any): (ctx: Ctx) => boolean {\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return (ctx: Ctx) => {\n        return ctx.get(commandsCtx).call(slice, payload);\n    };\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, editorViewCtx } from '@milkdown/core';\n\nexport const destroy = () => (ctx: Ctx) => ctx.get(editorViewCtx).destroy();\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, editorViewCtx } from '@milkdown/core';\n\nexport const forceUpdate =\n    () =>\n    (ctx: Ctx): void => {\n        const view = ctx.get(editorViewCtx);\n        const { tr } = view.state;\n\n        const nextTr = Object.assign(Object.create(tr), tr).setTime(Date.now());\n        return view.dispatch(nextTr);\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, editorViewCtx, schemaCtx } from '@milkdown/core';\nimport { DOMSerializer } from '@milkdown/prose/model';\n\nexport const getHTML =\n    () =>\n    (ctx: Ctx): string => {\n        const div = document.createElement('div');\n        const schema = ctx.get(schemaCtx);\n        const view = ctx.get(editorViewCtx);\n        const fragment = DOMSerializer.fromSchema(schema).serializeFragment(view.state.doc.content);\n\n        div.appendChild(fragment);\n\n        return div.innerHTML;\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, editorViewCtx, serializerCtx } from '@milkdown/core';\n\nexport const getMarkdown =\n    () =>\n    (ctx: Ctx): string => {\n        const view = ctx.get(editorViewCtx);\n        const serializer = ctx.get(serializerCtx);\n\n        return serializer(view.state.doc);\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, editorViewCtx, parserCtx } from '@milkdown/core';\nimport { Slice } from '@milkdown/prose/model';\n\nexport const insert = (markdown: string) => (ctx: Ctx) => {\n    const view = ctx.get(editorViewCtx);\n    const parser = ctx.get(parserCtx);\n    const doc = parser(markdown);\n    if (!doc) return;\n\n    const contentSlice = view.state.selection.content();\n    return view.dispatch(\n        view.state.tr\n            .replaceSelection(new Slice(doc.content, contentSlice.openStart, contentSlice.openEnd))\n            .scrollIntoView(),\n    );\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, editorViewCtx } from '@milkdown/core';\n\nexport const outline =\n    () =>\n    (ctx: Ctx): Array<{ text: string; level: number; id: string }> => {\n        const view = ctx.get(editorViewCtx);\n        const data: { text: string; level: number; id: string }[] = [];\n        const doc = view.state.doc;\n        doc.descendants((node) => {\n            if (node.type.name === 'heading' && node.attrs['level']) {\n                data.push({ text: node.textContent, level: node.attrs['level'], id: node.attrs['id'] });\n            }\n        });\n        return data;\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport {\n    Ctx,\n    editorStateOptionsCtx,\n    editorViewCtx,\n    parserCtx,\n    prosePluginsCtx,\n    schemaCtx,\n    themeManagerCtx,\n} from '@milkdown/core';\nimport { Slice } from '@milkdown/prose/model';\nimport { EditorState } from '@milkdown/prose/state';\n\nexport const replaceAll =\n    (markdown: string, flush = false) =>\n    (ctx: Ctx): void => {\n        const view = ctx.get(editorViewCtx);\n        const parser = ctx.get(parserCtx);\n        const doc = parser(markdown);\n        if (!doc) return;\n\n        if (!flush) {\n            const { state } = view;\n            return view.dispatch(state.tr.replace(0, state.doc.content.size, new Slice(doc.content, 0, 0)));\n        }\n\n        const schema = ctx.get(schemaCtx);\n        const options = ctx.get(editorStateOptionsCtx);\n        const plugins = ctx.get(prosePluginsCtx);\n        const themeManager = ctx.get(themeManagerCtx);\n\n        const state = EditorState.create({\n            schema,\n            doc,\n            plugins,\n            ...options,\n        });\n\n        view.updateState(state);\n        themeManager.flush(ctx);\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Attrs, Ctx, editorViewCtx } from '@milkdown/core';\n\nexport const setAttr = (pos: number, update: (prevAttrs: Attrs) => Attrs) => (ctx: Ctx) => {\n    const view = ctx.get(editorViewCtx);\n    const { tr } = view.state;\n    const node = tr.doc.nodeAt(pos);\n    if (!node) return;\n    const nextAttr = update(node.attrs);\n    return view.dispatch(tr.setNodeMarkup(pos, undefined, nextAttr));\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, themeManagerCtx, ThemePlugin } from '@milkdown/core';\n\nexport const switchTheme = (theme: ThemePlugin) => (ctx: Ctx) => ctx.get(themeManagerCtx).switch(ctx, theme);\n"],"names":[],"mappings":"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"}